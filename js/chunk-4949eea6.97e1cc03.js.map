{"version":3,"sources":["webpack:///./src/util/shaders/wgl2.glsl","webpack:///./node_modules/wgl2npm/dist/native-js.js","webpack:///./node_modules/wgl2npm/dist/src/core/api.js","webpack:///./node_modules/wgl2npm/dist/src/core/symbol.js","webpack:///./node_modules/wgl2npm/dist/src/core/node.js","webpack:///./node_modules/wgl2npm/dist/src/core/type.js","webpack:///./node_modules/wgl2npm/dist/native.js","webpack:///./node_modules/wgl2npm/dist/src/core/swizzle.js","webpack:///./node_modules/wgl2npm/dist/src/core/folder.js","webpack:///./node_modules/wgl2npm/dist/src/core/range.js","webpack:///./node_modules/wgl2npm/dist/src/core/tokenizer.js","webpack:///./node_modules/wgl2npm/dist/src/core/pratt.js","webpack:///./node_modules/wgl2npm/dist/src/core/scope.js","webpack:///./node_modules/wgl2npm/dist/src/core/parser.js","webpack:///./node_modules/wgl2npm/dist/src/core/controlflow.js","webpack:///./node_modules/wgl2npm/dist/src/core/resolver.js","webpack:///./node_modules/wgl2npm/dist/src/core/compiler.js","webpack:///./node_modules/wgl2npm/dist/src/core/emitter.js","webpack:///./node_modules/wgl2npm/dist/src/core/ide.js","webpack:///./node_modules/wgl2npm/dist/src/core/log.js","webpack:///./node_modules/wgl2npm/dist/src/core/source.js","webpack:///./node_modules/wgl2npm/dist/src/exports/ide.js"],"names":["module","exports","assert","truth","Error","List_set1","self","index","value","length","List_removeLast","pop","List_get2","List_last","List_append2","values","push","List_removeIf","callback","i","count1","List_first","List_takeLast","StringMap_set2","key","set","StringMap_insert","StringMap_get3","defaultValue","get","StringMap_get11","has","IntMap_set3","IntMap_get4","string_compare2","x","string_slice1","start","slice","string_slice2","end","string_get12","charCodeAt","string_get5","__asString","API_NAME","SymbolFlags","NodeKind","DefineStatement","name","this","id","range","scope","flags","comments","constantValue","requiredExtension","_resolvedType","useCount","CONST","UNIFORM","EXPORTED","StructSymbol","VariableSymbol","isStruct","isFunction","isVariable","super","variables","_arguments","returnType","block","previousOverload","sibling","_function","count","type","resolvedType","kind","node","arrayCount","ref","variableInitializer","SymbolFlags_toString","text","ATTRIBUTE","VARYING","HIGHP","LOWP","MEDIUMP","IN","INOUT","OUT","symbol","isArrayOf","containsArray","containsSampler","_arrayTypes","Map","arrayType","UVEC2","BVEC2","VEC2","IVEC2","MAT2","UVEC3","BVEC3","VEC3","IVEC3","MAT3","UVEC4","BVEC4","VEC4","IVEC4","MAT4","BOOL","FLOAT","INT","UINT","hasIntComponents","hasFloatComponents","ERROR","SAMPLER2D","_setContainsSampler","SAMPLERCUBE","VOID","SAMPLER3D","ISAMPLERCUBE","USAMPLERCUBE","SAMPLER2DARRAY","ISAMPLER2DARRAY","USAMPLER2DARRAY","SAMPLER2DSHADOW","SAMPLERCUBESHADOW","SAMPLER2DARRAYSHADOW","USAMPLER2DARRAYSHADOW","ISAMPLER2D","USAMPLER2D","ISAMPLER3D","USAMPLER3D","ISAMPLER2DARRAYSHADOW","BUILT_INS","_createID","internalRange","_literal","_text","_parent","_firstChild","_lastChild","_previousSibling","_nextSibling","hasControlFlowAtEnd","clone","_copyMembersFrom","cloneWithoutChildren","child","appendChild","childCount","hasChildren","after","before","asBool","parent","CALL","callTarget","NodeKind_isUnaryAssign","NodeKind_isBinaryAssign","binaryLeft","SEQUENCE","asFloat","asInt","NAME","TYPE","DOT","dotTarget","looksTheSameAs","asString","HOOK","hookTest","hookTrue","hookFalse","left","firstChild","right","nextSibling","NodeKind_isUnary","unaryValue","NodeKind_isBinary","binaryRight","GLOBAL","STRUCT_BLOCK","VARIABLE","withSymbol","BLOCK","BREAK","CONTINUE","DISCARD","body","test","NodeKind_isStatement","NodeKind_isExpression","DO_WHILE","EXPRESSION","behavior","EXTENSION","withText","withInt","DEFINE","setup","update","VARIABLES","FOR","createSequence","FUNCTION","yes","no","IF","MODIFIER_BLOCK","PRECISION","RETURN","STRUCT","version","VERSION","WHILE","createCall","createType","withType","PARSE_ERROR","UNKNOWN_CONSTANT","withBool","withFloat","isEmptySequence","_nextID","ASSIGN_SUBTRACT","NEGATIVE","POSTFIX_INCREMENT","NodeKind_isUnaryPrefix","PREFIX_INCREMENT","NodeKind_isUnaryPostfix","POSTFIX_DECREMENT","PREFIX_DECREMENT","ADD","ASSIGN","NodeKind_isLoop","List_setLast","int_compare1","RELEASE","strings","componentCount","_STRINGS_2","_STRINGS_3","_STRINGS_4","swizzleType","comonentType","fold","_fold","folded","_check","target","componentType","struct","asStruct","child1","_foldName","_foldSequence","_foldHook","_foldDot","INDEX","_foldIndex","_foldCall","_foldUnaryFloatOrInt","NOT","_foldUnaryBool","POSITIVE","_foldBinaryFloatOrInt","a","b","SUBTRACT","MULTIPLY","_foldMultiply","DIVIDE","EQUAL","NOT_EQUAL","_foldBinaryEquality","LOGICAL_AND","_foldBinaryBool","LOGICAL_OR","LOGICAL_XOR","GREATER_THAN","_foldBinaryFloatOrIntToBool","GREATER_THAN_OR_EQUAL","LESS_THAN","LESS_THAN_OR_EQUAL","isConst","asVariable","createUnknownConstant","lastChild","foldedTest","foldedTrue","foldedFalse","isVector","indexOf","childAt","remove","sType","result","createConstructorCall","i1","count2","variable","foldedLeft","foldedRight","indexCount","isMatrix","indexCount1","index1","indexType","matrixStride","casted","_castValue","_foldComponentConstructor","_foldStruct","_floatValues","leftType","rightType","stride","leftValues","rightValues","total","col","createFloat","stride1","result1","leftValues1","rightValues1","count3","total1","row","stride2","result2","leftValues2","rightValues2","row1","count6","col1","count5","total2","i2","count4","_foldFloat2","_foldInt2","value1","createBool","createInt","argument","isOffMatrixDiagonal","argument1","_foldComponentwiseUnary","argumentKind","op","_foldFloat1","_foldInt1","_foldComponentwiseBinary","leftHasComponents","rightHasComponents","leftChild","rightChild","folded1","floatOp","intOp","source","contents","offsetStart","offsetEnd","indexToLineColumn","TokenKind","Token","collectDefines","log","_defineRegex","exec","statement","defines","replaceDefines","defineStatement","Array","from","replace","RegExp","tokenize","purpose","parts","split","_tokenRegex","tokens","prevCommentTokenCount","part","c","keyword","keywords","END_OF_FILE","reservedWords","syntaxErrorReservedWord","IDENTIFIER","_intRegex","INT_LITERAL","FLOAT_LITERAL","PRAGMA","INCLUDE","STRING_LITERAL","kind1","operators","startsWith","SINGLE_LINE_COMMENT","MULTI_LINE_COMMENT","syntaxErrorExtraData","DO","ELSE","FALSE","INVARIANT","TRUE","EXPORT","IMPORT","COMPLEMENT","DECREMENT","INCREMENT","BITWISE_AND","BITWISE_OR","BITWISE_XOR","MINUS","PLUS","REMAINDER","SHIFT_LEFT","SHIFT_RIGHT","ASSIGN_ADD","ASSIGN_BITWISE_AND","ASSIGN_BITWISE_OR","ASSIGN_BITWISE_XOR","ASSIGN_DIVIDE","ASSIGN_MULTIPLY","ASSIGN_REMAINDER","ASSIGN_SHIFT_LEFT","ASSIGN_SHIFT_RIGHT","COLON","COMMA","LEFT_BRACE","LEFT_BRACKET","LEFT_PARENTHESIS","QUESTION","RIGHT_BRACE","RIGHT_BRACKET","RIGHT_PARENTHESIS","SEMICOLON","Include","originalRange","includedRange","_tokens","compilationData","resolver","processedIncludes","includes","_index","_scope","token","current","previous","span","peek","next","eat","lineColumn","line","syntaxErrorExpectedToken1","rangeAtEnd","syntaxErrorExpectedToken2","syntaxErrorUnexpectedToken","newScope","Parselet","precedence","prefix","infix","_table","parselet","created","context","unexpectedToken","resume","parse","symbols","find","ParseResult","typeParselet","withRange","unaryPrefix","createUnary","withInternalRange","unaryPostfix","binaryParselet","createBinary","Number","parseInt","createExpressionParser","pratt","invalidUnaryOperator","syntaxErrorInvalidOperator","invalidBinaryOperator","literal","toString","postfix","infixRight","syntaxErrorBadSymbolReference","createParseError","extensionBehavior","syntaxErrorDisabledExtension","createName","spanSince","dot","expect","createDot","parseCommaSeparatedList","middle","createHook","stop","isFirst","firstToken","parseDoWhile","pushScope","parseStatement","popScope","checkForSemicolon","createDoWhile","parseExportOrImport","old","IMPORTED","createModifierBlock","parseStatements","parseExtension","currentExtensions","variablesType","_knownWebGLExtensions","syntaxWarningUnknownExtension","_extensionBehaviors","createExtension","parseFor","parseLeadingComments","parseFlags","parseType","parseAfterType","createFor","parseIf","createIf","parseVersion","createVersion","parseDefine","startLine","createDefine","parseWhile","createWhile","parseReturn","createReturn","parsePrecision","flag","createPrecision","parseStruct","nextSymbolID","tryToDefineUniquelyInScope","createStructBlock","syntaxErrorStructVariableInitializer","syntaxErrorInsideStruct","parseVariables","createStruct","checkForLoopAndSemicolon","found","syntaxErrorOutsideLoop","allow","createExpression","parseFunction","nextRangeStart","leadingComments","comment","whitespace","newlineCount","j","reverse","mode","createBreak","createContinue","createDiscard","parseBlock","createBlock","checkStatementLocation","isOutsideFunction","shouldBeOutsideFunction","syntaxErrorInsideFunction","syntaxErrorOutsideFunction","parseInclude","path","JSON","_a","syntaxErrorInvalidString","fileAccess","semanticErrorIncludeWithoutFileAccess","semanticErrorIncludeBadPath","entireRange","nestedContext","syntaxErrorBadQualifier","originalScope","argumentFlags","argumentType","argumentName","parseArraySize","hasBlock","define","syntaxErrorDuplicateSymbolDefinition","link","asFunction","hasSameArgumentTypesAs","syntaxErrorDifferentReturnType","redefine","createFunction","syntaxErrorMissingArraySize","resolveNode","checkConversion","syntaxErrorConstantRequired","syntaxErrorInvalidArraySize","syntaxErrorMultidimensionalArray","createVariables","assign","createVariable","includeRange","syntaxErrorIncludeOutsideGlobal","global","data","_isLoopBreakTarget","_isControlFlowLive","isLive","whileTest","isTrue","doWhileTest","forTest","ifTest","trueValue","ifTrue","falseValue","ifFalse","isFalse","_log","_data","_controlFlow","_versions","_generatedExtensions","_returnType","first","insertChildBefore","extension","isExported","unusedSymbols","_resolveChildren","_maybeMarkAsUnused","semanticErrorBadVariableType","_resolveAsExpression","semanticErrorArrayAssignment","semanticErrorUninitializedConstant","_resolveBlockOrStatement","doWhileBody","expressionValue","forSetup","forUpdate","forBody","symbol1","semanticErrorMissingReturn","returnValue","symbol2","type1","whileBody","_resolveCall","_resolveDot","semanticErrorBadHookTypes","semanticErrorArrayHook","symbol3","isCallTarget","semanticErrorMustCallFunction","_resolveUnary","_resolveBinary","pushBlock","visitStatement","popBlock","_checkStorage","valueType","isIntOrFloat","semanticErrorBadUnaryOperator","isSame","canUseEqualityOperators","semanticErrorOutOfBoundsIndex","semanticErrorBadIndex","semanticErrorBadBinaryOperator","hasError","_resolveFunctionOverloads","_resolveConstructor","semanticErrorBadCall","isAssignTarget","_validateSwizzle","semanticErrorBadMember","overloaded","overloads","overload","overloadsBeforeTypeFilter","to","fromSize","toSize","semanticErrorBadOverloadMatch","overload1","semanticErrorArgumentCountFunction","hasMatrixArgument","providedCount","deltaCount","semanticErrorBadConstructorValue","semanticErrorExtraConstructorValue","isMatrixMatrixConstructor","semanticErrorBadMatrixConstructor","semanticErrorBadConstructorCount","variableCount","argumentCount","semanticErrorArgumentCountConstructor","semanticErrorBadSwizzle","semanticErrorBadSwizzleAssignment","semanticErrorUnexpectedType","n","label","isUniform","semanticErrorBadStorage","semanticErrorBadConversion","CompilerOptions","compactSyntaxTree","removeWhitespace","runPreprocessor","renameSymbols","trimSymbols","globals","_nextSymbolID","TypeCheckResult","rawTypeCheck","sources","options","source1","source2","createGlobal","source3","resolveGlobal","exponential","toExponential","e","exponent","toFixed","Tooltip","code","documentation","swizzleName","_tooltipForSymbol","_leadingCommentsToMarkdown","_visit","touches","query","_touches","_visitSymbol","_visitVariable","_visitFunction","_visitStruct","_collectSymbol","ranges","run","sort","overlaps","check","_appendRange","Completion","detail","_map","completions","_addTextualCompletion","completion","isGlobal","_addSymbolCompletion","arg","counters","counter","Signature","signatures","activeArgument","activeSignature","firstArgument","map","_variableTooltipText","filteredOverloads","limit","nextFilteredOverloads","nextFilteredOverloads1","overloadIndex","fromArguments","Math","min","fields","join","arg1","constantValueToString","floatToString","previousSibling","isNative","variable1","text1","text2","markdown","DiagnosticKind","Diagnostic","noteRange","noteText","diagnostics","warningCount","errorCount","_prevErrorRange","WARNING","last","warning","error","expected","note","stringify","field","constructor","plural","operator","LineColumn","column","_lineOffsets","_computeLineOffsets","step","sourcesFromInput","input","isArray","item","wrapFileAccess","filePath","relativeTo","main","_this","root","GLSLX","compileIDE","rangeToJSON","args","state","handleTooltipQuery","message","ignoreDiagnostics","tooltip","lineColumnToIndex","diagnostic","generateTooltip","handleDefinitionQuery","definition","include","handleSymbolsQuery","handleRenameQuery","renameQuery","handleCompletionQuery","completionQuery","handleSignatureQuery","signatureQuery","signature","updateState","toLowerCase"],"mappings":"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","file":"js/chunk-4949eea6.97e1cc03.js","sourcesContent":["module.exports = \"import {\\n// Converts a quantity specified in degrees into radians. The return value is `  * degrees / 180`\\nfloat radians(float degrees);\\n\\n// Converts a quantity specified in degrees into radians. The return value is `  * degrees / 180`\\nvec2 radians(vec2 degrees);\\n\\n// Converts a quantity specified in degrees into radians. The return value is `  * degrees / 180`\\nvec3 radians(vec3 degrees);\\n\\n// Converts a quantity specified in degrees into radians. The return value is `  * degrees / 180`\\nvec4 radians(vec4 degrees);\\n\\n// Converts a quantity specified in radians into degrees. The return value is `180 * radians / `\\nfloat degrees(float radians);\\n\\n// Converts a quantity specified in radians into degrees. The return value is `180 * radians / `\\nvec2 degrees(vec2 radians);\\n\\n// Converts a quantity specified in radians into degrees. The return value is `180 * radians / `\\nvec3 degrees(vec3 radians);\\n\\n// Converts a quantity specified in radians into degrees. The return value is `180 * radians / `\\nvec4 degrees(vec4 radians);\\n\\n// `sin` returns the trigonometric sine of `angle`.\\nfloat sin(float angle);\\n\\n// `sin` returns the trigonometric sine of `angle`.\\nvec2 sin(vec2 angle);\\n\\n// `sin` returns the trigonometric sine of `angle`.\\nvec3 sin(vec3 angle);\\n\\n// `sin` returns the trigonometric sine of `angle`.\\nvec4 sin(vec4 angle);\\n\\n// `cos` returns the trigonometric cosine of `angle`.\\nfloat cos(float angle);\\n\\n// `cos` returns the trigonometric cosine of `angle`.\\nvec2 cos(vec2 angle);\\n\\n// `cos` returns the trigonometric cosine of `angle`.\\nvec3 cos(vec3 angle);\\n\\n// `cos` returns the trigonometric cosine of `angle`.\\nvec4 cos(vec4 angle);\\n\\n// `tan` returns the trigonometric tangent of `angle`.\\nfloat tan(float angle);\\n\\n// `tan` returns the trigonometric tangent of `angle`.\\nvec2 tan(vec2 angle);\\n\\n// `tan` returns the trigonometric tangent of `angle`.\\nvec3 tan(vec3 angle);\\n\\n// `tan` returns the trigonometric tangent of `angle`.\\nvec4 tan(vec4 angle);\\n\\n// Returns the arcsine of a parameter. The range of values is -/2 to /2.\\nfloat asin(float x);\\n\\n// Returns the arcsine of a parameter. The range of values is -/2 to /2.\\nvec2 asin(vec2 x);\\n\\n// Returns the arcsine of a parameter. The range of values is -/2 to /2.\\nvec3 asin(vec3 x);\\n\\n// Returns the arcsine of a parameter. The range of values is -/2 to /2.\\nvec4 asin(vec4 x);\\n\\n// Returns the arccosine of a parameter. The range of values is 0 to .\\nfloat acos(float x);\\n\\n// Returns the arccosine of a parameter. The range of values is 0 to .\\nvec2 acos(vec2 x);\\n\\n// Returns the arccosine of a parameter. The range of values is 0 to .\\nvec3 acos(vec3 x);\\n\\n// Returns the arccosine of a parameter. The range of values is 0 to .\\nvec4 acos(vec4 x);\\n\\n// Returns the angle whose trigonometric arctangent is `y/x`.\\n// The signs of `y` and `x` are used to determine the quadrant that the angle lies in. \\n// The value returned by atan in this case is in the range `[-, ]`. The result is undefined if `x = 0`\\nfloat atan(float y, float x);\\n\\n// Returns the angle whose trigonometric arctangent is `y/x`.\\n// The signs of `y` and `x` are used to determine the quadrant that the angle lies in. \\n// The value returned by atan in this case is in the range `[-, ]`. The result is undefined if `x = 0`\\nvec2 atan(vec2 y, vec2 x);\\n\\n// Returns the angle whose trigonometric arctangent is `y/x`.\\n// The signs of `y` and `x` are used to determine the quadrant that the angle lies in. \\n// The value returned by atan in this case is in the range `[-, ]`. The result is undefined if `x = 0`\\nvec3 atan(vec3 y, vec3 x);\\n\\n// Returns the angle whose trigonometric arctangent is `y/x`.\\n// The signs of `y` and `x` are used to determine the quadrant that the angle lies in. \\n// The value returned by atan in this case is in the range `[-, ]`. The result is undefined if `x = 0`\\nvec4 atan(vec4 y, vec4 x);\\n\\n// Returns the angle whose tangent is `y_over_x`. The range of values is -/2 to /2.\\nfloat atan(float y_over_x);\\n\\n// Returns the angle whose tangent is `y_over_x`. The range of values is -/2 to /2.\\nvec2 atan(vec2 y_over_x);\\n\\n// Returns the angle whose tangent is `y_over_x`. The range of values is -/2 to /2.\\nvec3 atan(vec3 y_over_x);\\n\\n// Returns the angle whose tangent is `y_over_x`. The range of values is -/2 to /2.\\nvec4 atan(vec4 y_over_x);\\n\\n// Returns the hyperbolic sine of a parameter. The hyperbolic sine of x is computed as `(exp(x) - exp(-x)) / 2`\\nfloat sinh(float x);\\n\\n// Returns the hyperbolic sine of a parameter. The hyperbolic sine of x is computed as `(exp(x) - exp(-x)) / 2`\\nvec2 sinh(vec2 x);\\n\\n// Returns the hyperbolic sine of a parameter. The hyperbolic sine of x is computed as `(exp(x) - exp(-x)) / 2`\\nvec3 sinh(vec3 x);\\n\\n// Returns the hyperbolic sine of a parameter. The hyperbolic sine of x is computed as `(exp(x) - exp(-x)) / 2`\\nvec4 sinh(vec4 x);\\n\\n// Returns the hyperbolic cosine of a parameter. The hyperbolic cosine of x is computed as `(exp(x) + exp(-x)) / 2`\\nfloat cosh(float x);\\n\\n// Returns the hyperbolic cosine of a parameter. The hyperbolic cosine of x is computed as `(exp(x) + exp(-x)) / 2`\\nvec2 cosh(vec2 x);\\n\\n// Returns the hyperbolic cosine of a parameter. The hyperbolic cosine of x is computed as `(exp(x) + exp(-x)) / 2`\\nvec3 cosh(vec3 x);\\n\\n// Returns the hyperbolic cosine of a parameter. The hyperbolic cosine of x is computed as `(exp(x) + exp(-x)) / 2`\\nvec4 cosh(vec4 x);\\n\\n// Returns the hyperbolic tangent of a parameter. The hyperbolic tangent of x is computed as `sinh(x) / cosh(x)`\\nfloat tanh(float x);\\n\\n// Returns the hyperbolic tangent of a parameter. The hyperbolic tangent of x is computed as `sinh(x) / cosh(x)`\\nvec2 tanh(vec2 x);\\n\\n// Returns the hyperbolic tangent of a parameter. The hyperbolic tangent of x is computed as `sinh(x) / cosh(x)`\\nvec3 tanh(vec3 x);\\n\\n// Returns the hyperbolic tangent of a parameter. The hyperbolic tangent of x is computed as `sinh(x) / cosh(x)`\\nvec4 tanh(vec4 x);\\n\\n// Returns the hyperbolic arcsine of a parameter. The inverse of `sinh`\\nfloat asinh(float x);\\n\\n// Returns the hyperbolic arcsine of a parameter. The inverse of `sinh`\\nvec2 asinh(vec2 x);\\n\\n// Returns the hyperbolic arcsine of a parameter. The inverse of `sinh`\\nvec3 asinh(vec3 x);\\n\\n// Returns the hyperbolic arcsine of a parameter. The inverse of `sinh`\\nvec4 asinh(vec4 x);\\n\\n// Returns the arc hyperbolic cosine of `x`. THe non-negative inverse of `cosh`. The result is undefined if `x < 1`\\nfloat acosh(float x);\\n\\n// Returns the arc hyperbolic cosine of `x`. THe non-negative inverse of `cosh`. The result is undefined if `x < 1`\\nvec2 acosh(vec2 x);\\n\\n// Returns the arc hyperbolic cosine of `x`. THe non-negative inverse of `cosh`. The result is undefined if `x < 1`\\nvec3 acosh(vec3 x);\\n\\n// Returns the arc hyperbolic cosine of `x`. THe non-negative inverse of `cosh`. The result is undefined if `x < 1`\\nvec4 acosh(vec4 x);\\n\\n// Returns the hyperbolic arctangent of `x`. The inverse of `tanh`. The result is undefined if `abs(x) >= 1`\\nfloat atanh(float x);\\n\\n// Returns the hyperbolic arctangent of `x`. The inverse of `tanh`. The result is undefined if `abs(x) >= 1`\\nvec2 atanh(vec2 x);\\n\\n// Returns the hyperbolic arctangent of `x`. The inverse of `tanh`. The result is undefined if `abs(x) >= 1`\\nvec3 atanh(vec3 x);\\n\\n// Returns the hyperbolic arctangent of `x`. The inverse of `tanh`. The result is undefined if `abs(x) >= 1`\\nvec4 atanh(vec4 x);\\n\\n// Returns the value of `x` raised to the `y` power. The result is undefined if `x < 0` or if `x == 0` and `y <= 0`\\nfloat pow(float x, float y);\\n\\n// Returns the value of `x` raised to the `y` power. The result is undefined if `x < 0` or if `x == 0` and `y <= 0`\\nvec2 pow(vec2 x, vec2 y);\\n\\n// Returns the value of `x` raised to the `y` power. The result is undefined if `x < 0` or if `x == 0` and `y <= 0`\\nvec3 pow(vec3 x, vec3 y);\\n\\n// Returns the value of `x` raised to the `y` power. The result is undefined if `x < 0` or if `x == 0` and `y <= 0`\\nvec4 pow(vec4 x, vec4 y);\\n\\n// Returns the value of `e` raised to the power of `x`\\nfloat exp(float x);\\n\\n// Returns the value of `e` raised to the power of `x`\\nvec2 exp(vec2 x);\\n\\n// Returns the value of `e` raised to the power of `x`\\nvec3 exp(vec3 x);\\n\\n// Returns the value of `e` raised to the power of `x`\\nvec4 exp(vec4 x);\\n\\n// Returns the natural logarithm (base `e`) of `x`. I.e. the value `y` which satisfies `x = e^y. The result is undefined if `x <= 0`.\\nfloat log(float x);\\n\\n// Returns the natural logarithm (base `e`) of `x`. I.e. the value `y` which satisfies `x = e^y. The result is undefined if `x <= 0`.\\nvec2 log(vec2 x);\\n\\n// Returns the natural logarithm (base `e`) of `x`. I.e. the value `y` which satisfies `x = e^y. The result is undefined if `x <= 0`.\\nvec3 log(vec3 x);\\n\\n// Returns the natural logarithm (base `e`) of `x`. I.e. the value `y` which satisfies `x = e^y. The result is undefined if `x <= 0`.\\nvec4 log(vec4 x);\\n\\n// Returns 2 raised to the power of `x`. I.e. `2^x`\\nfloat exp2(float x);\\n\\n// Returns 2 raised to the power of `x`. I.e. `2^x`\\nvec2 exp2(vec2 x);\\n\\n// Returns 2 raised to the power of `x`. I.e. `2^x`\\nvec3 exp2(vec3 x);\\n\\n// Returns 2 raised to the power of `x`. I.e. `2^x`\\nvec4 exp2(vec4 x);\\n\\n// Returns the base 2 logarithm of `x`. I.e. the value `y` which satisfies `x = 2^y. The result is undefined if `x <= 0`.\\nfloat log2(float x);\\n\\n// Returns the base 2 logarithm of `x`. I.e. the value `y` which satisfies `x = 2^y. The result is undefined if `x <= 0`.\\nvec2 log2(vec2 x);\\n\\n// Returns the base 2 logarithm of `x`. I.e. the value `y` which satisfies `x = 2^y. The result is undefined if `x <= 0`.\\nvec3 log2(vec3 x);\\n\\n// Returns the base 2 logarithm of `x`. I.e. the value `y` which satisfies `x = 2^y. The result is undefined if `x <= 0`.\\nvec4 log2(vec4 x);\\n\\n// `sqrt` returns the square root of $x$, i.e.\\n// the value $\\\\sqrt { x }$. The result is undefined if $x < 0$.\\nfloat sqrt(float x);\\n\\n// `sqrt` returns the square root of $x$, i.e.\\n// the value $\\\\sqrt { x }$. The result is undefined if $x < 0$.\\nvec2 sqrt(vec2 x);\\n\\n// `sqrt` returns the square root of $x$, i.e.\\n// the value $\\\\sqrt { x }$. The result is undefined if $x < 0$.\\nvec3 sqrt(vec3 x);\\n\\n// `sqrt` returns the square root of $x$, i.e.\\n// the value $\\\\sqrt { x }$. The result is undefined if $x < 0$.\\nvec4 sqrt(vec4 x);\\n\\n// Returns the inverse square root of `x`. I.e. the value 1/sqrt(x). The result is undefined if `x <= 0`.\\nfloat inversesqrt(float x);\\n\\n// Returns the inverse square root of `x`. I.e. the value 1/sqrt(x). The result is undefined if `x <= 0`.\\nvec2 inversesqrt(vec2 x);\\n\\n// Returns the inverse square root of `x`. I.e. the value 1/sqrt(x). The result is undefined if `x <= 0`.\\nvec3 inversesqrt(vec3 x);\\n\\n// Returns the inverse square root of `x`. I.e. the value 1/sqrt(x). The result is undefined if `x <= 0`.\\nvec4 inversesqrt(vec4 x);\\n\\n// `abs` returns `x` if `x` >= 0, otherwise\\n// returns -`x`.\\nfloat abs(float x);\\n\\n// `abs` returns `x` if `x` >= 0, otherwise\\n// returns -`x`.\\nvec2 abs(vec2 x);\\n\\n// `abs` returns `x` if `x` >= 0, otherwise\\n// returns -`x`.\\nvec3 abs(vec3 x);\\n\\n// `abs` returns `x` if `x` >= 0, otherwise\\n// returns -`x`.\\nvec4 abs(vec4 x);\\n\\n// `abs` returns `x` if `x` >= 0, otherwise\\n// returns -`x`.\\nint abs(int x);\\n\\n// `abs` returns `x` if `x` >= 0, otherwise\\n// returns -`x`.\\nivec2 abs(ivec2 x);\\n\\n// `abs` returns `x` if `x` >= 0, otherwise\\n// returns -`x`.\\nivec3 abs(ivec3 x);\\n\\n// `abs` returns `x` if `x` >= 0, otherwise\\n// returns -`x`.\\nivec4 abs(ivec4 x);\\n\\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\\nfloat sign(float x);\\n\\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\\nvec2 sign(vec2 x);\\n\\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\\nvec3 sign(vec3 x);\\n\\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\\nvec4 sign(vec4 x);\\n\\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\\nint sign(int x);\\n\\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\\nivec2 sign(ivec2 x);\\n\\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\\nivec3 sign(ivec3 x);\\n\\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\\nivec4 sign(ivec4 x);\\n\\n// `floor` returns a value equal to the nearest integer that is less than or equal to `x`.\\nfloat floor(float x);\\n\\n// `floor` returns a value equal to the nearest integer that is less than or equal to `x`.\\nvec2 floor(vec2 x);\\n\\n// `floor` returns a value equal to the nearest integer that is less than or equal to `x`.\\nvec3 floor(vec3 x);\\n\\n// `floor` returns a value equal to the nearest integer that is less than or equal to `x`.\\nvec4 floor(vec4 x);\\n\\n// `trunc` returns a value equal to the nearest integer to `x`\\n// whose absolute value is not larger than the absolute value of `x`.\\nfloat trunc(float x);\\n\\n// `trunc` returns a value equal to the nearest integer to `x`\\n// whose absolute value is not larger than the absolute value of `x`.\\nvec2 trunc(vec2 x);\\n\\n// `trunc` returns a value equal to the nearest integer to `x`\\n// whose absolute value is not larger than the absolute value of `x`.\\nvec3 trunc(vec3 x);\\n\\n// `trunc` returns a value equal to the nearest integer to `x`\\n// whose absolute value is not larger than the absolute value of `x`.\\nvec4 trunc(vec4 x);\\n\\n// `round` returns a value equal to the nearest integer to `x`.\\n// The fraction 0.5 will round in a direction chosen by the implementation, usually in the direction that is\\n// fastest. This includes the possibility that `round`(`x`) returns the\\n// same value as `roundEven`(`x`)\\n// for all values of `x`.\\nfloat round(float x);\\n\\n// `round` returns a value equal to the nearest integer to `x`.\\n// The fraction 0.5 will round in a direction chosen by the implementation, usually in the direction that is\\n// fastest. This includes the possibility that `round`(`x`) returns the\\n// same value as `roundEven`(`x`)\\n// for all values of `x`.\\nvec2 round(vec2 x);\\n\\n// `round` returns a value equal to the nearest integer to `x`.\\n// The fraction 0.5 will round in a direction chosen by the implementation, usually in the direction that is\\n// fastest. This includes the possibility that `round`(`x`) returns the\\n// same value as `roundEven`(`x`)\\n// for all values of `x`.\\nvec3 round(vec3 x);\\n\\n// `round` returns a value equal to the nearest integer to `x`.\\n// The fraction 0.5 will round in a direction chosen by the implementation, usually in the direction that is\\n// fastest. This includes the possibility that `round`(`x`) returns the\\n// same value as `roundEven`(`x`)\\n// for all values of `x`.\\nvec4 round(vec4 x);\\n\\n// `roundEven` returns a value equal to the nearest integer to `x`.\\n// The fractional part of 0.5 will round toward the nearest even integer.\\n// For example, both 3.5 and 4.5 will round to 4.0.\\nfloat roundEven(float x);\\n\\n// `roundEven` returns a value equal to the nearest integer to `x`.\\n// The fractional part of 0.5 will round toward the nearest even integer.\\n// For example, both 3.5 and 4.5 will round to 4.0.\\nvec2 roundEven(vec2 x);\\n\\n// `roundEven` returns a value equal to the nearest integer to `x`.\\n// The fractional part of 0.5 will round toward the nearest even integer.\\n// For example, both 3.5 and 4.5 will round to 4.0.\\nvec3 roundEven(vec3 x);\\n\\n// `roundEven` returns a value equal to the nearest integer to `x`.\\n// The fractional part of 0.5 will round toward the nearest even integer.\\n// For example, both 3.5 and 4.5 will round to 4.0.\\nvec4 roundEven(vec4 x);\\n\\n// `ceil` returns a value equal to the nearest integer that is\\n// greater than or equal to `x`.\\nfloat ceil(float x);\\n\\n// `ceil` returns a value equal to the nearest integer that is\\n// greater than or equal to `x`.\\nvec2 ceil(vec2 x);\\n\\n// `ceil` returns a value equal to the nearest integer that is\\n// greater than or equal to `x`.\\nvec3 ceil(vec3 x);\\n\\n// `ceil` returns a value equal to the nearest integer that is\\n// greater than or equal to `x`.\\nvec4 ceil(vec4 x);\\n\\n// `fract` returns the fractional part of `x`. This\\n// is calculated as `x` - `floor`(`x`).\\nfloat fract(float x);\\n\\n// `fract` returns the fractional part of `x`. This\\n// is calculated as `x` - `floor`(`x`).\\nvec2 fract(vec2 x);\\n\\n// `fract` returns the fractional part of `x`. This\\n// is calculated as `x` - `floor`(`x`).\\nvec3 fract(vec3 x);\\n\\n// `fract` returns the fractional part of `x`. This\\n// is calculated as `x` - `floor`(`x`).\\nvec4 fract(vec4 x);\\n\\n// `mod` returns the value of `x` modulo\\n// `y`. This is computed as `x` - `y` *\\n// `floor`(`x`/`y`).\\nfloat mod(float x, float y);\\n\\n// `mod` returns the value of `x` modulo\\n// `y`. This is computed as `x` - `y` *\\n// `floor`(`x`/`y`).\\nvec2 mod(vec2 x, float y);\\n\\n// `mod` returns the value of `x` modulo\\n// `y`. This is computed as `x` - `y` *\\n// `floor`(`x`/`y`).\\nvec3 mod(vec3 x, float y);\\n\\n// `mod` returns the value of `x` modulo\\n// `y`. This is computed as `x` - `y` *\\n// `floor`(`x`/`y`).\\nvec4 mod(vec4 x, float y);\\n\\n// `mod` returns the value of `x` modulo\\n// `y`. This is computed as `x` - `y` *\\n// `floor`(`x`/`y`).\\nvec2 mod(vec2 x, vec2 y);\\n\\n// `mod` returns the value of `x` modulo\\n// `y`. This is computed as `x` - `y` *\\n// `floor`(`x`/`y`).\\nvec3 mod(vec3 x, vec3 y);\\n\\n// `mod` returns the value of `x` modulo\\n// `y`. This is computed as `x` - `y` *\\n// `floor`(`x`/`y`).\\nvec4 mod(vec4 x, vec4 y);\\n\\n// `modf` separates a floating point value `x`\\n// into its integer and fractional parts. The fractional part of the number is returned\\n// from the function and the integer part (as a floating point quantity) is returned\\n// in the output parameter `i`.\\nfloat modf(float x, out float i);\\n\\n// `modf` separates a floating point value `x`\\n// into its integer and fractional parts. The fractional part of the number is returned\\n// from the function and the integer part (as a floating point quantity) is returned\\n// in the output parameter `i`.\\nvec2 modf(vec2 x, out vec2 i);\\n\\n// `modf` separates a floating point value `x`\\n// into its integer and fractional parts. The fractional part of the number is returned\\n// from the function and the integer part (as a floating point quantity) is returned\\n// in the output parameter `i`.\\nvec3 modf(vec3 x, out vec3 i);\\n\\n// `modf` separates a floating point value `x`\\n// into its integer and fractional parts. The fractional part of the number is returned\\n// from the function and the integer part (as a floating point quantity) is returned\\n// in the output parameter `i`.\\nvec4 modf(vec4 x, out vec4 i);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nfloat min(float x, float y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nvec2 min(vec2 x, vec2 y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nvec3 min(vec3 x, vec3 y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nvec4 min(vec4 x, vec4 y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nvec2 min(vec2 x, float y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nvec3 min(vec3 x, float y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nvec4 min(vec4 x, float y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nint min(int x, int y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nivec2 min(ivec2 x, ivec2 y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nivec3 min(ivec3 x, ivec3 y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nivec4 min(ivec4 x, ivec4 y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nivec2 min(ivec2 x, int y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nivec3 min(ivec3 x, int y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nivec4 min(ivec4 x, int y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nuint min(uint x, uint y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nuvec2 min(uvec2 x, uvec2 y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nuvec3 min(uvec3 x, uvec3 y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nuvec4 min(uvec4 x, uvec4 y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nuvec2 min(uvec2 x, uint y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nuvec3 min(uvec3 x, uint y);\\n\\n// `min` returns the minimum of the two parameters. It\\n// returns `y` if `y` is less than\\n// `x`, otherwise it returns `x`.\\nuvec4 min(uvec4 x, uint y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nfloat max(float x, float y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nvec2 max(vec2 x, vec2 y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nvec3 max(vec3 x, vec3 y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nvec4 max(vec4 x, vec4 y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nvec2 max(vec2 x, float y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nvec3 max(vec3 x, float y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nvec4 max(vec4 x, float y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nint max(int x, int y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nivec2 max(ivec2 x, ivec2 y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nivec3 max(ivec3 x, ivec3 y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nivec4 max(ivec4 x, ivec4 y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nivec2 max(ivec2 x, int y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nivec3 max(ivec3 x, int y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nivec4 max(ivec4 x, int y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nuint max(uint x, uint y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nuvec2 max(uvec2 x, uvec2 y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nuvec3 max(uvec3 x, uvec3 y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nuvec4 max(uvec4 x, uvec4 y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nuvec2 max(uvec2 x, uint y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nuvec3 max(uvec3 x, uint y);\\n\\n// `max` returns the maximum of the two parameters. It\\n// returns `y` if `y` is greater than\\n// `x`, otherwise it returns `x`.\\nuvec4 max(uvec4 x, uint y);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nfloat clamp(float x, float minVal, float maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nvec2 clamp(vec2 x, vec2 minVal, vec2 maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nvec3 clamp(vec3 x, vec3 minVal, vec3 maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nvec4 clamp(vec4 x, vec4 minVal, vec4 maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nvec2 clamp(vec2 x, float minVal, float maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nvec3 clamp(vec3 x, float minVal, float maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nvec4 clamp(vec4 x, float minVal, float maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nint clamp(int x, int minVal, int maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nivec2 clamp(ivec2 x, ivec2 minVal, ivec2 maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nivec3 clamp(ivec3 x, ivec3 minVal, ivec3 maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nivec4 clamp(ivec4 x, ivec4 minVal, ivec4 maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nivec2 clamp(ivec2 x, int minVal, int maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nivec3 clamp(ivec3 x, int minVal, int maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nivec4 clamp(ivec4 x, int minVal, int maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nuint clamp(uint x, uint minVal, uint maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nuvec2 clamp(uvec2 x, uvec2 minVal, uvec2 maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nuvec3 clamp(uvec3 x, uvec3 minVal, uvec3 maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nuvec4 clamp(uvec4 x, uvec4 minVal, uvec4 maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nuvec2 clamp(uvec2 x, uint minVal, uint maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nuvec3 clamp(uvec3 x, uint minVal, uint maxVal);\\n\\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\\nuvec4 clamp(uvec4 x, uint minVal, uint maxVal);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nfloat mix(float x, float y, float a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec2 mix(vec2 x, vec2 y, vec2 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec3 mix(vec3 x, vec3 y, vec3 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec4 mix(vec4 x, vec4 y, vec4 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec2 mix(vec2 x, vec2 y, float a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec3 mix(vec3 x, vec3 y, float a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec4 mix(vec4 x, vec4 y, float a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nfloat mix(float x, float y, bool a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec2 mix(vec2 x, vec2 y, bool a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec3 mix(vec3 x, vec3 y, bool a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec4 mix(vec4 x, vec4 y, bool a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nfloat mix(float x, float y, bvec2 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec2 mix(vec2 x, vec2 y, bvec2 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec3 mix(vec3 x, vec3 y, bvec2 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec4 mix(vec4 x, vec4 y, bvec2 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nfloat mix(float x, float y, bvec3 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec2 mix(vec2 x, vec2 y, bvec3 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec3 mix(vec3 x, vec3 y, bvec3 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec4 mix(vec4 x, vec4 y, bvec3 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nfloat mix(float x, float y, bvec4 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec2 mix(vec2 x, vec2 y, bvec4 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec3 mix(vec3 x, vec3 y, bvec4 a);\\n\\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\\nvec4 mix(vec4 x, vec4 y, bvec4 a);\\n\\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\\nfloat step(float edge, float x);\\n\\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\\nvec2 step(vec2 edge, vec2 x);\\n\\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\\nvec3 step(vec3 edge, vec3 x);\\n\\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\\nvec4 step(vec4 edge, vec4 x);\\n\\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\\nvec2 step(float edge, vec2 x);\\n\\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\\nvec3 step(float edge, vec3 x);\\n\\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\\nvec4 step(float edge, vec4 x);\\n\\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\\n// `smoothstep` is equivalent to: \\n// \\n// ```\\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n// return t * t * (3.0 - 2.0 * t);\\n// ```\\nfloat smoothstep(float edge0, float edge1, float x);\\n\\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\\n// `smoothstep` is equivalent to: \\n// \\n// ```\\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n// return t * t * (3.0 - 2.0 * t);\\n// ```\\nvec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x);\\n\\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\\n// `smoothstep` is equivalent to: \\n// \\n// ```\\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n// return t * t * (3.0 - 2.0 * t);\\n// ```\\nvec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x);\\n\\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\\n// `smoothstep` is equivalent to: \\n// \\n// ```\\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n// return t * t * (3.0 - 2.0 * t);\\n// ```\\nvec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x);\\n\\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\\n// `smoothstep` is equivalent to: \\n// \\n// ```\\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n// return t * t * (3.0 - 2.0 * t);\\n// ```\\nvec2 smoothstep(float edge0, float edge1, vec2 x);\\n\\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\\n// `smoothstep` is equivalent to: \\n// \\n// ```\\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n// return t * t * (3.0 - 2.0 * t);\\n// ```\\nvec3 smoothstep(float edge0, float edge1, vec3 x);\\n\\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\\n// `smoothstep` is equivalent to: \\n// \\n// ```\\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n// return t * t * (3.0 - 2.0 * t);\\n// ```\\nvec4 smoothstep(float edge0, float edge1, vec4 x);\\n\\n// For each element `i` of the result, `isnan` returns `true` if `x[i]` is positive or negative floating point `NaN`, and `false` otherwise.\\n// NaNs may not be supported by the implementation, in which case `isnan` returns `false`.\\nbool isnan(float x);\\n\\n// For each element `i` of the result, `isnan` returns `true` if `x[i]` is positive or negative floating point `NaN`, and `false` otherwise.\\n// NaNs may not be supported by the implementation, in which case `isnan` returns `false`.\\nbvec2 isnan(vec2 x);\\n\\n// For each element `i` of the result, `isnan` returns `true` if `x[i]` is positive or negative floating point `NaN`, and `false` otherwise.\\n// NaNs may not be supported by the implementation, in which case `isnan` returns `false`.\\nbvec3 isnan(vec3 x);\\n\\n// For each element `i` of the result, `isnan` returns `true` if `x[i]` is positive or negative floating point `NaN`, and `false` otherwise.\\n// NaNs may not be supported by the implementation, in which case `isnan` returns `false`.\\nbvec4 isnan(vec4 x);\\n\\n// For each element `i` of the result, `isinf` returns `true` if `x[i]` is positive or negative floating point `Infinity`, and `false` otherwise.\\nbool isinf(float x);\\n\\n// For each element `i` of the result, `isinf` returns `true` if `x[i]` is positive or negative floating point `Infinity`, and `false` otherwise.\\nbvec2 isinf(vec2 x);\\n\\n// For each element `i` of the result, `isinf` returns `true` if `x[i]` is positive or negative floating point `Infinity`, and `false` otherwise.\\nbvec3 isinf(vec3 x);\\n\\n// For each element `i` of the result, `isinf` returns `true` if `x[i]` is positive or negative floating point `Infinity`, and `false` otherwise.\\nbvec4 isinf(vec4 x);\\n\\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\\n// converted to highp floating point and the encoding of that value is returned.\\nint floatBitsToInt(float x);\\n\\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\\n// converted to highp floating point and the encoding of that value is returned.\\nivec2 floatBitsToInt(vec2 x);\\n\\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\\n// converted to highp floating point and the encoding of that value is returned.\\nivec3 floatBitsToInt(vec3 x);\\n\\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\\n// converted to highp floating point and the encoding of that value is returned.\\nivec4 floatBitsToInt(vec4 x);\\n\\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\\n// converted to highp floating point and the encoding of that value is returned.\\nuint floatBitsToUint(float x);\\n\\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\\n// converted to highp floating point and the encoding of that value is returned.\\nuvec2 floatBitsToUint(vec2 x);\\n\\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\\n// converted to highp floating point and the encoding of that value is returned.\\nuvec3 floatBitsToUint(vec3 x);\\n\\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\\n// converted to highp floating point and the encoding of that value is returned.\\nuvec4 floatBitsToUint(vec4 x);\\n\\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\\n// passed in parameter `x` as a highp floating-point value. If the encoding of\\n// a NaN is passed in `x`, it will not signal and the resulting value will\\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\\n// the resulting floating-point value is the corresponding (positive or negative) floating\\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\\nfloat intBitsToFloat(float x);\\n\\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\\n// passed in parameter `x` as a highp floating-point value. If the encoding of\\n// a NaN is passed in `x`, it will not signal and the resulting value will\\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\\n// the resulting floating-point value is the corresponding (positive or negative) floating\\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\\nvec2 intBitsToFloat(vec2 x);\\n\\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\\n// passed in parameter `x` as a highp floating-point value. If the encoding of\\n// a NaN is passed in `x`, it will not signal and the resulting value will\\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\\n// the resulting floating-point value is the corresponding (positive or negative) floating\\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\\nvec3 intBitsToFloat(vec3 x);\\n\\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\\n// passed in parameter `x` as a highp floating-point value. If the encoding of\\n// a NaN is passed in `x`, it will not signal and the resulting value will\\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\\n// the resulting floating-point value is the corresponding (positive or negative) floating\\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\\nvec4 intBitsToFloat(vec4 x);\\n\\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\\n// passed in parameter `x` as a highp floating-point value. If the encoding of\\n// a NaN is passed in `x`, it will not signal and the resulting value will\\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\\n// the resulting floating-point value is the corresponding (positive or negative) floating\\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\\nfloat uintBitsToFloat(float x);\\n\\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\\n// passed in parameter `x` as a highp floating-point value. If the encoding of\\n// a NaN is passed in `x`, it will not signal and the resulting value will\\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\\n// the resulting floating-point value is the corresponding (positive or negative) floating\\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\\nvec2 uintBitsToFloat(vec2 x);\\n\\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\\n// passed in parameter `x` as a highp floating-point value. If the encoding of\\n// a NaN is passed in `x`, it will not signal and the resulting value will\\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\\n// the resulting floating-point value is the corresponding (positive or negative) floating\\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\\nvec3 uintBitsToFloat(vec3 x);\\n\\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\\n// passed in parameter `x` as a highp floating-point value. If the encoding of\\n// a NaN is passed in `x`, it will not signal and the resulting value will\\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\\n// the resulting floating-point value is the corresponding (positive or negative) floating\\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\\nvec4 uintBitsToFloat(vec4 x);\\n\\n// Returns the length of a vector. I.e. the square root of the sum of the squares of all components.\\nfloat length(float x);\\n\\n// Returns the length of a vector. I.e. the square root of the sum of the squares of all components.\\nfloat length(vec2 x);\\n\\n// Returns the length of a vector. I.e. the square root of the sum of the squares of all components.\\nfloat length(vec3 x);\\n\\n// Returns the length of a vector. I.e. the square root of the sum of the squares of all components.\\nfloat length(vec4 x);\\n\\n// Returns the distance between two vectors. I.e. `length(p0 - p1)`\\nfloat distance(float p0, float p1);\\n\\n// Returns the distance between two vectors. I.e. `length(p0 - p1)`\\nfloat distance(vec2 p0, vec2 p1);\\n\\n// Returns the distance between two vectors. I.e. `length(p0 - p1)`\\nfloat distance(vec3 p0, vec3 p1);\\n\\n// Returns the distance between two vectors. I.e. `length(p0 - p1)`\\nfloat distance(vec4 p0, vec4 p1);\\n\\n// Returns the dot product of two vectors. I.e. `x[0] * y[0] + x[1] * y[1] + ...`\\nfloat dot(float x, float y);\\n\\n// Returns the dot product of two vectors. I.e. `x[0] * y[0] + x[1] * y[1] + ...`\\nfloat dot(vec2 x, vec2 y);\\n\\n// Returns the dot product of two vectors. I.e. `x[0] * y[0] + x[1] * y[1] + ...`\\nfloat dot(vec3 x, vec3 y);\\n\\n// Returns the dot product of two vectors. I.e. `x[0] * y[0] + x[1] * y[1] + ...`\\nfloat dot(vec4 x, vec4 y);\\n\\n// Returns the cross product of two vectors. I.e. `(x[1] * y[2] - x[2] * y[1], x[2] * y[0] - x[0] * y[2], x[0] * y[1] - x[1] * y[0])`\\nvec3 cross(vec3 x, vec3 y);\\n\\n// `normalize` returns a vector with the same direction as its parameter, `v`, but with length 1.\\nfloat normalize(float v);\\n\\n// `normalize` returns a vector with the same direction as its parameter, `v`, but with length 1.\\nvec2 normalize(vec2 v);\\n\\n// `normalize` returns a vector with the same direction as its parameter, `v`, but with length 1.\\nvec3 normalize(vec3 v);\\n\\n// `normalize` returns a vector with the same direction as its parameter, `v`, but with length 1.\\nvec4 normalize(vec4 v);\\n\\n// `faceforward` orients a vector to point away from a surface as defined by its normal.\\n// If `dot(Nref, I) < 0`, then `faceforward` returns `N`, otherwise it returns `-N`\\nfloat faceforward(float N, float I, float Nref);\\n\\n// `faceforward` orients a vector to point away from a surface as defined by its normal.\\n// If `dot(Nref, I) < 0`, then `faceforward` returns `N`, otherwise it returns `-N`\\nvec2 faceforward(vec2 N, vec2 I, vec2 Nref);\\n\\n// `faceforward` orients a vector to point away from a surface as defined by its normal.\\n// If `dot(Nref, I) < 0`, then `faceforward` returns `N`, otherwise it returns `-N`\\nvec3 faceforward(vec3 N, vec3 I, vec3 Nref);\\n\\n// `faceforward` orients a vector to point away from a surface as defined by its normal.\\n// If `dot(Nref, I) < 0`, then `faceforward` returns `N`, otherwise it returns `-N`\\nvec4 faceforward(vec4 N, vec4 I, vec4 Nref);\\n\\n// For a given incident vector `I` and surface normal `N` `reflect` returns\\n// the reflection direction calculated as ``I` - 2.0 * dot(`N`, `I`) * `N``.\\n// `N` should be normalized in order to achieve the desired result.\\nfloat reflect(float I, float N);\\n\\n// For a given incident vector `I` and surface normal `N` `reflect` returns\\n// the reflection direction calculated as ``I` - 2.0 * dot(`N`, `I`) * `N``.\\n// `N` should be normalized in order to achieve the desired result.\\nvec2 reflect(vec2 I, vec2 N);\\n\\n// For a given incident vector `I` and surface normal `N` `reflect` returns\\n// the reflection direction calculated as ``I` - 2.0 * dot(`N`, `I`) * `N``.\\n// `N` should be normalized in order to achieve the desired result.\\nvec3 reflect(vec3 I, vec3 N);\\n\\n// For a given incident vector `I` and surface normal `N` `reflect` returns\\n// the reflection direction calculated as ``I` - 2.0 * dot(`N`, `I`) * `N``.\\n// `N` should be normalized in order to achieve the desired result.\\nvec4 reflect(vec4 I, vec4 N);\\n\\n// For a given incident vector `I`, surface normal `N` and ratio of\\n// indices of refraction, `eta`, `refract` returns the refraction vector,\\n// `R`.\\n// `R` is calculated as:\\n// \\n// ```glsl\\n//    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\\n// if (k < 0.0)\\n// R = genType(0.0);       // or genDType(0.0)\\n// else\\n// R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\\n// ```\\n//\\n// The input parameters `I` and `N` should be normalized in order to achieve the desired result.\\nfloat refract(float I, float N, float eta);\\n\\n// For a given incident vector `I`, surface normal `N` and ratio of\\n// indices of refraction, `eta`, `refract` returns the refraction vector,\\n// `R`.\\n// `R` is calculated as:\\n// \\n// ```glsl\\n//    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\\n// if (k < 0.0)\\n// R = genType(0.0);       // or genDType(0.0)\\n// else\\n// R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\\n// ```\\n//\\n// The input parameters `I` and `N` should be normalized in order to achieve the desired result.\\nvec2 refract(vec2 I, vec2 N, float eta);\\n\\n// For a given incident vector `I`, surface normal `N` and ratio of\\n// indices of refraction, `eta`, `refract` returns the refraction vector,\\n// `R`.\\n// `R` is calculated as:\\n// \\n// ```glsl\\n//    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\\n// if (k < 0.0)\\n// R = genType(0.0);       // or genDType(0.0)\\n// else\\n// R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\\n// ```\\n//\\n// The input parameters `I` and `N` should be normalized in order to achieve the desired result.\\nvec3 refract(vec3 I, vec3 N, float eta);\\n\\n// For a given incident vector `I`, surface normal `N` and ratio of\\n// indices of refraction, `eta`, `refract` returns the refraction vector,\\n// `R`.\\n// `R` is calculated as:\\n// \\n// ```glsl\\n//    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\\n// if (k < 0.0)\\n// R = genType(0.0);       // or genDType(0.0)\\n// else\\n// R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\\n// ```\\n//\\n// The input parameters `I` and `N` should be normalized in order to achieve the desired result.\\nvec4 refract(vec4 I, vec4 N, float eta);\\n\\n// `outerProduct` treats the first parameter `c` as a column\\n// vector (matrix with one column) and the second parameter `r` as a row vector\\n// (matrix with one row) and does a linear algebraic matrix multiply `c` * `r`,\\n// yielding a matrix whose number of rows is the number of components in `c` and\\n// whose number of columns is the number of components in `r`.\\nmat2 outerProduct(vec2 c, vec2 r);\\n\\n// `outerProduct` treats the first parameter `c` as a column\\n// vector (matrix with one column) and the second parameter `r` as a row vector\\n// (matrix with one row) and does a linear algebraic matrix multiply `c` * `r`,\\n// yielding a matrix whose number of rows is the number of components in `c` and\\n// whose number of columns is the number of components in `r`.\\nmat3 outerProduct(vec3 c, vec3 r);\\n\\n// `outerProduct` treats the first parameter `c` as a column\\n// vector (matrix with one column) and the second parameter `r` as a row vector\\n// (matrix with one row) and does a linear algebraic matrix multiply `c` * `r`,\\n// yielding a matrix whose number of rows is the number of components in `c` and\\n// whose number of columns is the number of components in `r`.\\nmat4 outerProduct(vec4 c, vec4 r);\\n\\n\\n// `transpose` returns the transpose of the matrix `m`.\\nmat2 transpose(mat2 m);\\n\\n// `transpose` returns the transpose of the matrix `m`.\\nmat3 transpose(mat3 m);\\n\\n// `transpose` returns the transpose of the matrix `m`.\\nmat4 transpose(mat4 m);\\n\\n// `determinant` returns the determinant of the matrix `m`.\\nfloat determinant(mat2 m);\\n\\n// `determinant` returns the determinant of the matrix `m`.\\nfloat determinant(mat3 m);\\n\\n// `determinant` returns the determinant of the matrix `m`.\\nfloat determinant(mat4 m);\\n\\n// `inverse` returns the inverse of the matrix `m`. The values in the\\n// returned matrix are undefined if `m` is singular or poorly-conditioned (nearly singular).\\nmat2 inverse(mat2 m);\\n\\n// `inverse` returns the inverse of the matrix `m`. The values in the\\n// returned matrix are undefined if `m` is singular or poorly-conditioned (nearly singular).\\nmat3 inverse(mat3 m);\\n\\n// `inverse` returns the inverse of the matrix `m`. The values in the\\n// returned matrix are undefined if `m` is singular or poorly-conditioned (nearly singular).\\nmat4 inverse(mat4 m);\\n\\n// `lessThan` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] < `y`[_i_].\\nbvec2 lessThan(vec2 x, vec2 y);\\n\\n// `lessThan` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] < `y`[_i_].\\nbvec3 lessThan(vec3 x, vec3 y);\\n\\n// `lessThan` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] < `y`[_i_].\\nbvec4 lessThan(vec4 x, vec4 y);\\n\\n// `lessThanEqual` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] =< `y`[_i_].\\nbvec2 lessThanEqual(vec2 x, vec2 y);\\n\\n// `lessThanEqual` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] =< `y`[_i_].\\nbvec3 lessThanEqual(vec3 x, vec3 y);\\n\\n// `lessThanEqual` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] =< `y`[_i_].\\nbvec4 lessThanEqual(vec4 x, vec4 y);\\n\\n// `greaterThan` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] > `y`[_i_].\\nbvec2 greaterThan(vec2 x, vec2 y);\\n\\n// `greaterThan` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] > `y`[_i_].\\nbvec3 greaterThan(vec3 x, vec3 y);\\n\\n// `greaterThan` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] > `y`[_i_].\\nbvec4 greaterThan(vec4 x, vec4 y);\\n\\n// `greaterThanEqual` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] >= `y`[_i_].\\nbvec2 greaterThanEqual(vec2 x, vec2 y);\\n\\n// `greaterThanEqual` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] >= `y`[_i_].\\nbvec3 greaterThanEqual(vec3 x, vec3 y);\\n\\n// `greaterThanEqual` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] >= `y`[_i_].\\nbvec4 greaterThanEqual(vec4 x, vec4 y);\\n\\n// `equal` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] == `y`[_i_].\\nbvec2 equal(vec2 x, vec2 y);\\n\\n// `equal` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] == `y`[_i_].\\nbvec3 equal(vec3 x, vec3 y);\\n\\n// `equal` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] == `y`[_i_].\\nbvec4 equal(vec4 x, vec4 y);\\n\\n// `notEqual` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] != `y`[_i_].\\nbvec2 notEqual(vec2 x, vec2 y);\\n\\n// `notEqual` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] != `y`[_i_].\\nbvec3 notEqual(vec3 x, vec3 y);\\n\\n// `notEqual` returns a boolean vector in which each element _i_ is computed\\n// as `x`[_i_] != `y`[_i_].\\nbvec4 notEqual(vec4 x, vec4 y);\\n\\n// `any` returns true if any element of `x` is true and false otherwise.\\n// It is functionally equivalent to:\\n// \\n// ```glsl\\n//    bool any(bvec x)       // bvec can be bvec2, bvec3 or bvec4\\n// {\\n// bool result = false;\\n// int i;\\n// for (i = 0; i < x.length(); ++i)\\n// {\\n// result |= x[i];\\n// }\\n// return result;\\n// }\\n// ```\\n//\\nbool any(bvec2 x);\\n\\n// `any` returns true if any element of `x` is true and false otherwise.\\n// It is functionally equivalent to:\\n// \\n// ```glsl\\n//    bool any(bvec x)       // bvec can be bvec2, bvec3 or bvec4\\n// {\\n// bool result = false;\\n// int i;\\n// for (i = 0; i < x.length(); ++i)\\n// {\\n// result |= x[i];\\n// }\\n// return result;\\n// }\\n// ```\\n//\\nbool any(bvec3 x);\\n\\n// `any` returns true if any element of `x` is true and false otherwise.\\n// It is functionally equivalent to:\\n// \\n// ```glsl\\n//    bool any(bvec x)       // bvec can be bvec2, bvec3 or bvec4\\n// {\\n// bool result = false;\\n// int i;\\n// for (i = 0; i < x.length(); ++i)\\n// {\\n// result |= x[i];\\n// }\\n// return result;\\n// }\\n// ```\\n//\\nbool any(bvec4 x);\\n\\n// `all` returns true if all elements of `x` are true and false otherwise.\\n// It is functionally equivalent to:\\n// \\n// ```glsl\\n//    bool all(bvec x)       // bvec can be bvec2, bvec3 or bvec4\\n// {\\n// bool result = true;\\n// int i;\\n// for (i = 0; i < x.length(); ++i)\\n// {\\n// result &amp;= x[i];\\n// }\\n// return result;\\n// }\\n// ```\\n//\\nbool all(bvec2 x);\\n\\n// `all` returns true if all elements of `x` are true and false otherwise.\\n// It is functionally equivalent to:\\n// \\n// ```glsl\\n//    bool all(bvec x)       // bvec can be bvec2, bvec3 or bvec4\\n// {\\n// bool result = true;\\n// int i;\\n// for (i = 0; i < x.length(); ++i)\\n// {\\n// result &amp;= x[i];\\n// }\\n// return result;\\n// }\\n// ```\\n//\\nbool all(bvec3 x);\\n\\n// `all` returns true if all elements of `x` are true and false otherwise.\\n// It is functionally equivalent to:\\n// \\n// ```glsl\\n//    bool all(bvec x)       // bvec can be bvec2, bvec3 or bvec4\\n// {\\n// bool result = true;\\n// int i;\\n// for (i = 0; i < x.length(); ++i)\\n// {\\n// result &amp;= x[i];\\n// }\\n// return result;\\n// }\\n// ```\\n//\\nbool all(bvec4 x);\\n\\n// `not` logically inverts the boolean vector `x`. It returns\\n// a new boolean vector for which each element _i_ is computed as `!`x`[`i`]`.\\nbvec2 not(bvec2 x);\\n\\n// `not` logically inverts the boolean vector `x`. It returns\\n// a new boolean vector for which each element _i_ is computed as `!`x`[`i`]`.\\nbvec3 not(bvec3 x);\\n\\n// `not` logically inverts the boolean vector `x`. It returns\\n// a new boolean vector for which each element _i_ is computed as `!`x`[`i`]`.\\nbvec4 not(bvec4 x);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec2 textureSize(sampler2D sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec2 textureSize(isampler2D sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec2 textureSize(usampler2D sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec3 textureSize(sampler3D sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec3 textureSize(isampler3D sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec3 textureSize(usampler3D sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec2 textureSize(samplerCube sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec2 textureSize(isamplerCube sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec2 textureSize(usamplerCube sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec2 textureSize(sampler2DShadow sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec2 textureSize(samplerCubeShadow sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec3 textureSize(sampler2DArray sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec3 textureSize(isampler2DArray sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec3 textureSize(usampler2DArray sampler, int lod);\\n\\n// `textureSize` returns the dimensions of level `lod` (if present)\\n// of the texture bound to `sampler`. The components in the return value are filled in,\\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\\nivec3 textureSize(sampler2DArrayShadow sampler, int lod);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nvec4 texture(sampler2D sampler, vec2 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nivec4 texture(isampler2D sampler, vec2 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nuvec4 texture(usampler2D sampler, vec2 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nvec4 texture(sampler2D sampler, vec2 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nivec4 texture(isampler2D sampler, vec2 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nuvec4 texture(usampler2D sampler, vec2 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nvec4 texture(sampler3D sampler, vec3 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nivec4 texture(isampler3D sampler, vec3 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nuvec4 texture(usampler3D sampler, vec3 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nvec4 texture(sampler3D sampler, vec3 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nivec4 texture(isampler3D sampler, vec3 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nuvec4 texture(usampler3D sampler, vec3 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nvec4 texture(samplerCube sampler, vec3 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nivec4 texture(isamplerCube sampler, vec3 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nuvec4 texture(usamplerCube sampler, vec3 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nvec4 texture(samplerCube sampler, vec3 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nivec4 texture(isamplerCube sampler, vec3 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nuvec4 texture(usamplerCube sampler, vec3 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\\n// When compare is not present, the last component of `P` is used as Dsub and the array\\n// layer is specified in the second to last component of `P`.\\nfloat texture(sampler2DShadow sampler, vec3 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\\n// When compare is not present, the last component of `P` is used as Dsub and the array\\n// layer is specified in the second to last component of `P`.\\nfloat texture(sampler2DShadow sampler, vec3 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\\n// When compare is not present, the last component of `P` is used as Dsub and the array\\n// layer is specified in the second to last component of `P`.\\nfloat texture(samplerCubeShadow sampler, vec4 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\\n// When compare is not present, the last component of `P` is used as Dsub and the array\\n// layer is specified in the second to last component of `P`.\\nfloat texture(samplerCubeShadow sampler, vec4 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nvec4 texture(sampler2DArray sampler, vec3 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nivec4 texture(isampler2DArray sampler, vec3 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nuvec4 texture(usampler2DArray sampler, vec3 P, float bias);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nvec4 texture(sampler2DArray sampler, vec3 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nivec4 texture(isampler2DArray sampler, vec3 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// The array layer comes from the last component of `P`\\nuvec4 texture(usampler2DArray sampler, vec3 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\\n// When compare is not present, the last component of `P` is used as Dsub and the array\\n// layer is specified in the second to last component of `P`.\\nfloat texture(sampler2DArrayShadow sampler, vec4 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\\n// When compare is not present, the last component of `P` is used as Dsub and the array\\n// layer is specified in the second to last component of `P`.\\nfloat texture(isampler2DArrayShadow sampler, vec4 P);\\n\\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\\n// is used to choose mipmap(s) from which to sample.\\n// \\n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\\n// When compare is not present, the last component of `P` is used as Dsub and the array\\n// layer is specified in the second to last component of `P`.\\nfloat texture(usampler2DArrayShadow sampler, vec4 P);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nvec4 textureProj(sampler2D sampler, vec3 P, float bias);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nivec4 textureProj(isampler2D sampler, vec3 P, float bias);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nuvec4 textureProj(usampler2D sampler, vec3 P, float bias);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nvec4 textureProj(sampler2D sampler, vec3 P);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nivec4 textureProj(isampler2D sampler, vec3 P);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nuvec4 textureProj(usampler2D sampler, vec3 P);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nvec4 textureProj(sampler2D sampler, vec4 P, float bias);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nivec4 textureProj(isampler2D sampler, vec4 P, float bias);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nuvec4 textureProj(usampler2D sampler, vec4 P, float bias);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nvec4 textureProj(sampler2D sampler, vec4 P);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nivec4 textureProj(isampler2D sampler, vec4 P);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nuvec4 textureProj(usampler2D sampler, vec4 P);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nvec4 textureProj(sampler3D sampler, vec4 P, float bias);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nivec4 textureProj(isampler3D sampler, vec4 P, float bias);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nuvec4 textureProj(usampler3D sampler, vec4 P, float bias);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nvec4 textureProj(sampler3D sampler, vec4 P);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nivec4 textureProj(isampler3D sampler, vec4 P);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nuvec4 textureProj(usampler3D sampler, vec4 P);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// The resulting 3rd component of `P` in the shadow forms is used as Dref\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nfloat textureProj(sampler2DShadow sampler, vec4 P, float bias);\\n\\n// `textureProj` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// The resulting 3rd component of `P` in the shadow forms is used as Dref\\n// After these values are computed, the texture lookup proceeds as in `texture`.\\nfloat textureProj(sampler2DShadow sampler, vec4 P);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nvec4 textureLod(sampler2D sampler, vec2 P, float lod);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nivec4 textureLod(isampler2D sampler, vec2 P, float lod);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nuvec4 textureLod(usampler2D sampler, vec2 P, float lod);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nvec4 textureLod(sampler3D sampler, vec3 P, float lod);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nivec4 textureLod(isampler3D sampler, vec3 P, float lod);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nuvec4 textureLod(usampler3D sampler, vec3 P, float lod);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nvec4 textureLod(samplerCube sampler, vec3 P, float lod);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nivec4 textureLod(isamplerCube sampler, vec3 P, float lod);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nuvec4 textureLod(usamplerCube sampler, vec3 P, float lod);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nfloat textureLod(sampler2DShadow sampler, vec3 P, float lod);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nvec4 textureLod(sampler2DArray sampler, vec3 P, float lod);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nivec4 textureLod(isampler2DArray sampler, vec3 P, float lod);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\\nuvec4 textureLod(usampler2DArray sampler, vec3 P, float lod);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nvec4 textureOffset(sampler2D sampler, vec2 P, ivec2 offset, float bias);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nivec4 textureOffset(isampler2D sampler, vec2 P, ivec2 offset, float bias);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nuvec4 textureOffset(usampler2D sampler, vec2 P, ivec2 offset, float bias);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nvec4 textureOffset(sampler2D sampler, vec2 P, ivec2 offset);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nivec4 textureOffset(isampler2D sampler, vec2 P, ivec2 offset);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nuvec4 textureOffset(usampler2D sampler, vec2 P, ivec2 offset);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nvec4 textureOffset(sampler3D sampler, vec3 P, ivec3 offset, float bias);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nivec4 textureOffset(isampler3D sampler, vec3 P, ivec3 offset, float bias);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nuvec4 textureOffset(usampler3D sampler, vec3 P, ivec3 offset, float bias);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nvec4 textureOffset(sampler3D sampler, vec3 P, ivec3 offset);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nivec4 textureOffset(isampler3D sampler, vec3 P, ivec3 offset);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nuvec4 textureOffset(usampler3D sampler, vec3 P, ivec3 offset);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nfloat textureOffset(sampler2DShadow sampler, vec3 P, ivec2 offset, float bias);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nfloat textureOffset(sampler2DShadow sampler, vec3 P, ivec2 offset);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nvec4 textureOffset(sampler2DArray sampler, vec3 P, ivec2 offset, float bias);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nivec4 textureOffset(isampler2DArray sampler, vec3 P, ivec2 offset, float bias);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nuvec4 textureOffset(usampler2DArray sampler, vec3 P, ivec2 offset, float bias);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nvec4 textureOffset(sampler2DArray sampler, vec3 P, ivec2 offset);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nivec4 textureOffset(isampler2DArray sampler, vec3 P, ivec2 offset);\\n\\n// `textureOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\\n// The offset value must be a constant expression. A limited range of offset values are supported;\\n// the minimum and maximum offset values are implementation-dependent and may be determined\\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\\n// respectively.\\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\\n// that offsets are not supported for cube maps.\\nuvec4 textureOffset(usampler2DArray sampler, vec3 P, ivec2 offset);\\n\\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched.\\nvec4 texelFetch(sampler2D sampler, ivec2 P, int lod);\\n\\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched.\\nivec4 texelFetch(isampler2D sampler, ivec2 P, int lod);\\n\\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched.\\nuvec4 texelFetch(usampler2D sampler, ivec2 P, int lod);\\n\\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched.\\nvec4 texelFetch(sampler3D sampler, ivec3 P, int lod);\\n\\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched.\\nivec4 texelFetch(isampler3D sampler, ivec3 P, int lod);\\n\\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched.\\nuvec4 texelFetch(usampler3D sampler, ivec3 P, int lod);\\n\\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched.\\nvec4 texelFetch(sampler2DArray sampler, ivec3 P, int lod);\\n\\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched.\\nivec4 texelFetch(isampler2DArray sampler, ivec3 P, int lod);\\n\\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched.\\nuvec4 texelFetch(usampler2DArray sampler, ivec3 P, int lod);\\n\\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\\n// returned when reading from a multi-sample texure.\\nvec4 texelFetchOffset(sampler2D sampler, ivec2 P, int lod, ivec2 offset);\\n\\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\\n// returned when reading from a multi-sample texure.\\nivec4 texelFetchOffset(isampler2D sampler, ivec2 P, int lod, ivec2 offset);\\n\\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\\n// returned when reading from a multi-sample texure.\\nuvec4 texelFetchOffset(usampler2D sampler, ivec2 P, int lod, ivec2 offset);\\n\\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\\n// returned when reading from a multi-sample texure.\\nvec4 texelFetchOffset(sampler3D sampler, ivec3 P, int lod, ivec3 offset);\\n\\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\\n// returned when reading from a multi-sample texure.\\nivec4 texelFetchOffset(isampler3D sampler, ivec3 P, int lod, ivec3 offset);\\n\\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\\n// returned when reading from a multi-sample texure.\\nuvec4 texelFetchOffset(usampler3D sampler, ivec3 P, int lod, ivec3 offset);\\n\\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\\n// returned when reading from a multi-sample texure.\\nvec4 texelFetchOffset(sampler2DArray sampler, ivec3 P, int lod, ivec2 offset);\\n\\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\\n// returned when reading from a multi-sample texure.\\nivec4 texelFetchOffset(isampler2DArray sampler, ivec3 P, int lod, ivec2 offset);\\n\\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\\n// returned when reading from a multi-sample texure.\\nuvec4 texelFetchOffset(usampler2DArray sampler, ivec3 P, int lod, ivec2 offset);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nvec4 textureProjOffset(sampler2D sampler, vec3 P, ivec2 offset, float bias);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nivec4 textureProjOffset(isampler2D sampler, vec3 P, ivec2 offset, float bias);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nuvec4 textureProjOffset(usampler2D sampler, vec3 P, ivec2 offset, float bias);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nvec4 textureProjOffset(sampler2D sampler, vec3 P, ivec2 offset);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nivec4 textureProjOffset(isampler2D sampler, vec3 P, ivec2 offset);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nuvec4 textureProjOffset(usampler2D sampler, vec3 P, ivec2 offset);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nvec4 textureProjOffset(sampler2D sampler, vec4 P, ivec2 offset, float bias);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nivec4 textureProjOffset(isampler2D sampler, vec4 P, ivec2 offset, float bias);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nuvec4 textureProjOffset(usampler2D sampler, vec4 P, ivec2 offset, float bias);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nvec4 textureProjOffset(sampler2D sampler, vec4 P, ivec2 offset);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nivec4 textureProjOffset(isampler2D sampler, vec4 P, ivec2 offset);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nuvec4 textureProjOffset(usampler2D sampler, vec4 P, ivec2 offset);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nvec4 textureProjOffset(sampler3D sampler, vec4 P, ivec3 offset, float bias);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nivec4 textureProjOffset(isampler3D sampler, vec4 P, ivec3 offset, float bias);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nuvec4 textureProjOffset(usampler3D sampler, vec4 P, ivec3 offset, float bias);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nvec4 textureProjOffset(sampler3D sampler, vec4 P, ivec3 offset);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nivec4 textureProjOffset(isampler3D sampler, vec4 P, ivec3 offset);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nuvec4 textureProjOffset(usampler3D sampler, vec4 P, ivec3 offset);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// The resulting 3rd component of `P` in the shadow forms is used as Dref\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nfloat textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, float bias);\\n\\n// `textureProjOffset` performs a texture lookup with projection.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// The resulting 3rd component of `P` in the shadow forms is used as Dref\\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\\n// with the `offset` used to offset the computed texture coordinates.\\nfloat textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset);\\n\\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\\n// Behavior is the same as in `textureLod` except that before\\n// sampling, `offset` is added to `P`.\\nvec4 textureLodOffset(sampler2D sampler, vec2 P, float lod, ivec2 offset);\\n\\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\\n// Behavior is the same as in `textureLod` except that before\\n// sampling, `offset` is added to `P`.\\nivec4 textureLodOffset(isampler2D sampler, vec2 P, float lod, ivec2 offset);\\n\\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\\n// Behavior is the same as in `textureLod` except that before\\n// sampling, `offset` is added to `P`.\\nuvec4 textureLodOffset(usampler2D sampler, vec2 P, float lod, ivec2 offset);\\n\\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\\n// Behavior is the same as in `textureLod` except that before\\n// sampling, `offset` is added to `P`.\\nvec4 textureLodOffset(sampler3D sampler, vec3 P, float lod, ivec3 offset);\\n\\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\\n// Behavior is the same as in `textureLod` except that before\\n// sampling, `offset` is added to `P`.\\nivec4 textureLodOffset(isampler3D sampler, vec3 P, float lod, ivec3 offset);\\n\\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\\n// Behavior is the same as in `textureLod` except that before\\n// sampling, `offset` is added to `P`.\\nuvec4 textureLodOffset(usampler3D sampler, vec3 P, float lod, ivec3 offset);\\n\\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\\n// Behavior is the same as in `textureLod` except that before\\n// sampling, `offset` is added to `P`.\\nfloat textureLodOffset(sampler2DShadow sampler, vec3 P, float lod, ivec2 offset);\\n\\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\\n// Behavior is the same as in `textureLod` except that before\\n// sampling, `offset` is added to `P`.\\nvec4 textureLodOffset(sampler2DArray sampler, vec3 P, float lod, ivec2 offset);\\n\\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\\n// Behavior is the same as in `textureLod` except that before\\n// sampling, `offset` is added to `P`.\\nivec4 textureLodOffset(isampler2DArray sampler, vec3 P, float lod, ivec2 offset);\\n\\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\\n// Behavior is the same as in `textureLod` except that before\\n// sampling, `offset` is added to `P`.\\nuvec4 textureLodOffset(usampler2DArray sampler, vec3 P, float lod, ivec2 offset);\\n\\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\\nvec4 textureProjLod(sampler2D sampler, vec3 P, float lod);\\n\\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\\nivec4 textureProjLod(isampler2D sampler, vec3 P, float lod);\\n\\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\\nuvec4 textureProjLod(usampler2D sampler, vec3 P, float lod);\\n\\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\\nvec4 textureProjLod(sampler2D sampler, vec4 P, float lod);\\n\\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\\nivec4 textureProjLod(isampler2D sampler, vec4 P, float lod);\\n\\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\\nuvec4 textureProjLod(usampler2D sampler, vec4 P, float lod);\\n\\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\\nvec4 textureProjLod(sampler3D sampler, vec4 P, float lod);\\n\\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\\nivec4 textureProjLod(isampler3D sampler, vec4 P, float lod);\\n\\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\\nuvec4 textureProjLod(usampler3D sampler, vec4 P, float lod);\\n\\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// The resulting 3rd component of `P` in the shadow forms is used as Dref\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\\nfloat textureProjLod(sampler2DShadow sampler, vec4 P, float lod);\\n\\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \\n// level-of-detail with an offset applied to the texture coordinates before sampling.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \\n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\\nvec4 textureProjLodOffset(sampler2D sampler, vec3 P, float lod, ivec2 offset);\\n\\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \\n// level-of-detail with an offset applied to the texture coordinates before sampling.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \\n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\\nivec4 textureProjLodOffset(isampler2D sampler, vec3 P, float lod, ivec2 offset);\\n\\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \\n// level-of-detail with an offset applied to the texture coordinates before sampling.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \\n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\\nuvec4 textureProjLodOffset(usampler2D sampler, vec3 P, float lod, ivec2 offset);\\n\\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \\n// level-of-detail with an offset applied to the texture coordinates before sampling.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \\n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\\nvec4 textureProjLodOffset(sampler2D sampler, vec4 P, float lod, ivec2 offset);\\n\\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \\n// level-of-detail with an offset applied to the texture coordinates before sampling.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \\n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\\nivec4 textureProjLodOffset(isampler2D sampler, vec4 P, float lod, ivec2 offset);\\n\\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \\n// level-of-detail with an offset applied to the texture coordinates before sampling.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \\n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\\nuvec4 textureProjLodOffset(usampler2D sampler, vec4 P, float lod, ivec2 offset);\\n\\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \\n// level-of-detail with an offset applied to the texture coordinates before sampling.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \\n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\\nvec4 textureProjLodOffset(sampler3D sampler, vec4 P, float lod, ivec3 offset);\\n\\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \\n// level-of-detail with an offset applied to the texture coordinates before sampling.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \\n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\\nivec4 textureProjLodOffset(isampler3D sampler, vec4 P, float lod, ivec3 offset);\\n\\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \\n// level-of-detail with an offset applied to the texture coordinates before sampling.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \\n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\\nuvec4 textureProjLodOffset(usampler3D sampler, vec4 P, float lod, ivec3 offset);\\n\\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \\n// level-of-detail with an offset applied to the texture coordinates before sampling.\\n// The texture coordinates consumed from `P`, not including the last component of `P`,\\n// are divided by the last component of `P`.\\n// The resulting 3rd component of `P` in the shadow forms is used as Dref\\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \\n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\\nfloat textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, ivec2 offset);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nvec4 textureGrad(sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nivec4 textureGrad(isampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nuvec4 textureGrad(usampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nvec4 textureGrad(sampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nivec4 textureGrad(isampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nuvec4 textureGrad(usampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nvec4 textureGrad(samplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nivec4 textureGrad(isamplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nuvec4 textureGrad(usamplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nfloat textureGrad(sampler2DShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nfloat textureGrad(samplerCubeShadow sampler, vec4 P, vec3 dPdx, vec3 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nvec4 textureGrad(sampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nivec4 textureGrad(isampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nuvec4 textureGrad(usampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nfloat textureGrad(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nfloat textureGrad(isampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy);\\n\\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\\nfloat textureGrad(usampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy);\\n\\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\\n// `textureGrad` and `offset` as\\n// `textureOffset`.\\nvec4 textureGradOffset(sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\\n// `textureGrad` and `offset` as\\n// `textureOffset`.\\nivec4 textureGradOffset(isampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\\n// `textureGrad` and `offset` as\\n// `textureOffset`.\\nuvec4 textureGradOffset(usampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\\n// `textureGrad` and `offset` as\\n// `textureOffset`.\\nvec4 textureGradOffset(sampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy, ivec3 offset);\\n\\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\\n// `textureGrad` and `offset` as\\n// `textureOffset`.\\nivec4 textureGradOffset(isampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy, ivec3 offset);\\n\\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\\n// `textureGrad` and `offset` as\\n// `textureOffset`.\\nuvec4 textureGradOffset(usampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy, ivec3 offset);\\n\\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\\n// `textureGrad` and `offset` as\\n// `textureOffset`.\\nfloat textureGradOffset(sampler2DShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\\n// `textureGrad` and `offset` as\\n// `textureOffset`.\\nvec4 textureGradOffset(sampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\\n// `textureGrad` and `offset` as\\n// `textureOffset`.\\nivec4 textureGradOffset(isampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\\n// `textureGrad` and `offset` as\\n// `textureOffset`.\\nuvec4 textureGradOffset(usampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\\n// `textureGrad` and `offset` as\\n// `textureOffset`.\\nfloat textureGradOffset(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// Perform a texture lookup with projection and explicit gradients\\nvec4 textureProjGrad(sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\\n\\n// Perform a texture lookup with projection and explicit gradients\\nivec4 textureProjGrad(isampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\\n\\n// Perform a texture lookup with projection and explicit gradients\\nuvec4 textureProjGrad(usampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\\n\\n// Perform a texture lookup with projection and explicit gradients\\nvec4 textureProjGrad(sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\\n\\n// Perform a texture lookup with projection and explicit gradients\\nivec4 textureProjGrad(isampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\\n\\n// Perform a texture lookup with projection and explicit gradients\\nuvec4 textureProjGrad(usampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\\n\\n// Perform a texture lookup with projection and explicit gradients\\nvec4 textureProjGrad(sampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy);\\n\\n// Perform a texture lookup with projection and explicit gradients\\nivec4 textureProjGrad(isampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy);\\n\\n// Perform a texture lookup with projection and explicit gradients\\nuvec4 textureProjGrad(usampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy);\\n\\n// Perform a texture lookup with projection and explicit gradients\\nfloat textureProjGrad(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy);\\n\\n// Perform a texture lookup with projection, explicit gradients and offset\\nvec4 textureProjGradOffset(sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// Perform a texture lookup with projection, explicit gradients and offset\\nivec4 textureProjGradOffset(isampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// Perform a texture lookup with projection, explicit gradients and offset\\nuvec4 textureProjGradOffset(usampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// Perform a texture lookup with projection, explicit gradients and offset\\nvec4 textureProjGradOffset(sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// Perform a texture lookup with projection, explicit gradients and offset\\nivec4 textureProjGradOffset(isampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// Perform a texture lookup with projection, explicit gradients and offset\\nuvec4 textureProjGradOffset(usampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// Perform a texture lookup with projection, explicit gradients and offset\\nvec4 textureProjGradOffset(sampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy, ivec3 offset);\\n\\n// Perform a texture lookup with projection, explicit gradients and offset\\nivec4 textureProjGradOffset(isampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy, ivec3 offset);\\n\\n// Perform a texture lookup with projection, explicit gradients and offset\\nuvec4 textureProjGradOffset(usampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy, ivec3 offset);\\n\\n// Perform a texture lookup with projection, explicit gradients and offset\\nfloat textureProjGradOffset(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\\n\\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\\n// via non-uniform control flow may be undefined.\\nfloat dFdx(float p);\\n\\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\\n// via non-uniform control flow may be undefined.\\nvec2 dFdx(vec2 p);\\n\\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\\n// via non-uniform control flow may be undefined.\\nvec3 dFdx(vec3 p);\\n\\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\\n// via non-uniform control flow may be undefined.\\nvec4 dFdx(vec4 p);\\n\\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\\n// via non-uniform control flow may be undefined.\\nfloat dFdy(float p);\\n\\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\\n// via non-uniform control flow may be undefined.\\nvec2 dFdy(vec2 p);\\n\\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\\n// via non-uniform control flow may be undefined.\\nvec3 dFdy(vec3 p);\\n\\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\\n// via non-uniform control flow may be undefined.\\nvec4 dFdy(vec4 p);\\n\\n// _Available only in the fragment shader_, `fwidth` returns the sum of\\n// the absolute derivatives in x and y using local differencing for the input argument `p`.\\n// It is equivalent to `abs(dFdx(p)) + abs(dFdy(p))`.\\nfloat fwidth(float p);\\n\\n// _Available only in the fragment shader_, `fwidth` returns the sum of\\n// the absolute derivatives in x and y using local differencing for the input argument `p`.\\n// It is equivalent to `abs(dFdx(p)) + abs(dFdy(p))`.\\nvec2 fwidth(vec2 p);\\n\\n// _Available only in the fragment shader_, `fwidth` returns the sum of\\n// the absolute derivatives in x and y using local differencing for the input argument `p`.\\n// It is equivalent to `abs(dFdx(p)) + abs(dFdy(p))`.\\nvec3 fwidth(vec3 p);\\n\\n// _Available only in the fragment shader_, `fwidth` returns the sum of\\n// the absolute derivatives in x and y using local differencing for the input argument `p`.\\n// It is equivalent to `abs(dFdx(p)) + abs(dFdy(p))`.\\nvec4 fwidth(vec4 p);\\n\\n\\n\\n}\"","export function assert(truth) {\n    if (!truth) {\n        throw Error('Assertion failed');\n    }\n}\nexport function List_set1(self, index, value) {\n    assert(0 <= index && index < self.length);\n    return self[index] = value;\n}\nexport function List_removeLast(self) {\n    assert(!(self.length === 0));\n    self.pop();\n}\nexport function List_get2(self, index) {\n    assert(0 <= index && index < self.length);\n    return self[index];\n}\nexport function List_last(self) {\n    assert(!(self.length === 0));\n    return List_get2(self, self.length - 1);\n}\nexport function List_append2(self, values) {\n    assert(values !== self);\n    for (const value of values) {\n        self.push(value);\n    }\n}\nexport function List_removeIf(self, callback) {\n    let index = 0;\n    // Remove elements in place\n    for (let i = 0, count1 = self.length; i < count1; i = i + 1) {\n        if (!callback(List_get2(self, i))) {\n            if (index < i) {\n                List_set1(self, index, List_get2(self, i));\n            }\n            index = index + 1;\n        }\n    }\n    // Shrink the array to the correct size\n    while (index < self.length) {\n        List_removeLast(self);\n    }\n}\nexport function List_first(self) {\n    assert(!(self.length === 0));\n    return List_get2(self, 0);\n}\nexport function List_takeLast(self) {\n    assert(!(self.length === 0));\n    return self.pop();\n}\nexport function StringMap_set2(self, key, value) {\n    self.set(key, value);\n    return value;\n}\nexport function StringMap_insert(self, key, value) {\n    self.set(key, value);\n    return self;\n}\nexport function StringMap_get3(self, key, defaultValue) {\n    let value = self.get(key);\n    return value !== void (0) ? value : defaultValue; // Compare against undefined so the key is only hashed once for speed\n}\nexport function StringMap_get11(self, key) {\n    assert(self.has(key));\n    return self.get(key);\n}\nexport function IntMap_set3(self, key, value) {\n    self.set(key, value);\n    return value;\n}\nexport function IntMap_get4(self, key, defaultValue) {\n    let value = self.get(key);\n    return value !== void (0) ? value : defaultValue; // Compare against undefined so the key is only hashed once for speed\n}\nexport function string_compare2(self, x) {\n    // @ts-ignore\n    return (x < self | 0) - (x > self | 0);\n}\nexport function string_slice1(self, start) {\n    assert(0 <= start && start <= self.length);\n    return self.slice(start);\n}\nexport function string_slice2(self, start, end) {\n    assert(0 <= start && start <= end && end <= self.length);\n    return self.slice(start, end);\n}\nexport function string_get12(self, index) {\n    assert(0 <= index && index < self.length);\n    return self.charCodeAt(index);\n}\nexport function string_get5(self, index) {\n    assert(0 <= index && index < self.length);\n    return self[index];\n}\nexport let __isInt = (value) => {\n    return value === (value | 0);\n};\nexport let __asString = (value) => {\n    return value === null ? value : value + '';\n};\n","// This is from https://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\nexport let API_NAME = '<api>';\n","import { List_get2, assert } from \"../../native-js\";\nimport { Type } from \"./type\";\nexport var SymbolFlags;\n(function (SymbolFlags) {\n    // Keyword modifiers\n    SymbolFlags[SymbolFlags[\"ATTRIBUTE\"] = 1] = \"ATTRIBUTE\";\n    SymbolFlags[SymbolFlags[\"CONST\"] = 2] = \"CONST\";\n    SymbolFlags[SymbolFlags[\"HIGHP\"] = 4] = \"HIGHP\";\n    SymbolFlags[SymbolFlags[\"IN\"] = 8] = \"IN\";\n    SymbolFlags[SymbolFlags[\"INOUT\"] = 16] = \"INOUT\";\n    SymbolFlags[SymbolFlags[\"LOWP\"] = 32] = \"LOWP\";\n    SymbolFlags[SymbolFlags[\"MEDIUMP\"] = 64] = \"MEDIUMP\";\n    SymbolFlags[SymbolFlags[\"OUT\"] = 128] = \"OUT\";\n    SymbolFlags[SymbolFlags[\"UNIFORM\"] = 256] = \"UNIFORM\";\n    SymbolFlags[SymbolFlags[\"VARYING\"] = 512] = \"VARYING\";\n    // Internal compiler flags\n    SymbolFlags[SymbolFlags[\"EXPORTED\"] = 1024] = \"EXPORTED\";\n    SymbolFlags[SymbolFlags[\"IMPORTED\"] = 2048] = \"IMPORTED\";\n})(SymbolFlags || (SymbolFlags = {}));\nexport class DefineStatement {\n    constructor(name, value) {\n        this.name = name;\n        this.value = value;\n    }\n}\nexport class _Symbol {\n    constructor(id, range, name, scope) {\n        this.id = id;\n        this.range = range;\n        this.name = name;\n        this.scope = scope;\n        this.flags = 0;\n        this.comments = null;\n        this.constantValue = null;\n        this.requiredExtension = null;\n        this._resolvedType = null;\n        this.useCount = 0;\n    }\n    isConst() {\n        return (SymbolFlags.CONST & this.flags) !== 0;\n    }\n    isUniform() {\n        return (SymbolFlags.UNIFORM & this.flags) !== 0;\n    }\n    isExported() {\n        return (SymbolFlags.EXPORTED & this.flags) !== 0;\n    }\n    isStruct() {\n        return this instanceof StructSymbol;\n    }\n    isFunction() {\n        return this instanceof FunctionSymbol;\n    }\n    isVariable() {\n        return this instanceof VariableSymbol;\n    }\n    isNative() {\n        return this.id < 0;\n    }\n    asStruct() {\n        assert(this.isStruct());\n        // @ts-ignore\n        return this;\n    }\n    asFunction() {\n        assert(this.isFunction());\n        // @ts-ignore\n        return this;\n    }\n    asVariable() {\n        assert(this.isVariable());\n        // @ts-ignore\n        return this;\n    }\n    resolvedType() {\n        if (this._resolvedType === null) {\n            this._resolvedType = new Type(this, null, 0);\n        }\n        return this._resolvedType;\n    }\n}\nexport class StructSymbol extends _Symbol {\n    constructor(id, range, name, scope) {\n        super(id, range, name, scope);\n        this.variables = [];\n    }\n}\nexport class FunctionSymbol extends _Symbol {\n    constructor(id, range, name, scope) {\n        super(id, range, name, scope);\n        this._arguments = [];\n        this.returnType = null;\n        this.block = null;\n        this.previousOverload = null;\n        this.sibling = null;\n    }\n    hasSameArgumentTypesAs(_function) {\n        if (this._arguments.length !== _function._arguments.length) {\n            return false;\n        }\n        for (let i = 0, count = this._arguments.length; i < count; i = i + 1) {\n            if (List_get2(this._arguments, i).type.resolvedType !== List_get2(_function._arguments, i).type.resolvedType) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexport class VariableSymbol extends _Symbol {\n    constructor(id, range, name, scope, kind) {\n        super(id, range, name, scope);\n        this.kind = kind;\n        this.type = null;\n        this.node = null;\n        this.arrayCount = null;\n    }\n    value() {\n        let ref;\n        return (ref = this.node) !== null ? ref.variableInitializer() : null;\n    }\n}\nexport function SymbolFlags_toString(self) {\n    let text = '';\n    if ((SymbolFlags.ATTRIBUTE & self) !== 0) {\n        text += 'attribute ';\n    }\n    if ((SymbolFlags.CONST & self) !== 0) {\n        text += 'const ';\n    }\n    if ((SymbolFlags.UNIFORM & self) !== 0) {\n        text += 'uniform ';\n    }\n    if ((SymbolFlags.VARYING & self) !== 0) {\n        text += 'varying ';\n    }\n    if ((SymbolFlags.HIGHP & self) !== 0) {\n        text += 'highp ';\n    }\n    if ((SymbolFlags.LOWP & self) !== 0) {\n        text += 'lowp ';\n    }\n    if ((SymbolFlags.MEDIUMP & self) !== 0) {\n        text += 'mediump ';\n    }\n    if ((SymbolFlags.IN & self) !== 0) {\n        text += 'in ';\n    }\n    if ((SymbolFlags.INOUT & self) !== 0) {\n        text += 'inout ';\n    }\n    if ((SymbolFlags.OUT & self) !== 0) {\n        text += 'out ';\n    }\n    return text;\n}\n","import { assert } from \"../../native-js\";\nimport { Type } from \"./type\";\nexport var NodeKind;\n(function (NodeKind) {\n    // Other\n    NodeKind[NodeKind[\"GLOBAL\"] = 0] = \"GLOBAL\";\n    NodeKind[NodeKind[\"STRUCT_BLOCK\"] = 1] = \"STRUCT_BLOCK\";\n    NodeKind[NodeKind[\"VARIABLE\"] = 2] = \"VARIABLE\";\n    // Statements\n    NodeKind[NodeKind[\"BLOCK\"] = 3] = \"BLOCK\";\n    NodeKind[NodeKind[\"BREAK\"] = 4] = \"BREAK\";\n    NodeKind[NodeKind[\"CONTINUE\"] = 5] = \"CONTINUE\";\n    NodeKind[NodeKind[\"DISCARD\"] = 6] = \"DISCARD\";\n    NodeKind[NodeKind[\"DO_WHILE\"] = 7] = \"DO_WHILE\";\n    NodeKind[NodeKind[\"EXPRESSION\"] = 8] = \"EXPRESSION\";\n    NodeKind[NodeKind[\"EXTENSION\"] = 9] = \"EXTENSION\";\n    NodeKind[NodeKind[\"DEFINE\"] = 10] = \"DEFINE\";\n    NodeKind[NodeKind[\"FOR\"] = 11] = \"FOR\";\n    NodeKind[NodeKind[\"FUNCTION\"] = 12] = \"FUNCTION\";\n    NodeKind[NodeKind[\"IF\"] = 13] = \"IF\";\n    NodeKind[NodeKind[\"MODIFIER_BLOCK\"] = 14] = \"MODIFIER_BLOCK\";\n    NodeKind[NodeKind[\"PRECISION\"] = 15] = \"PRECISION\";\n    NodeKind[NodeKind[\"RETURN\"] = 16] = \"RETURN\";\n    NodeKind[NodeKind[\"STRUCT\"] = 17] = \"STRUCT\";\n    NodeKind[NodeKind[\"VARIABLES\"] = 18] = \"VARIABLES\";\n    NodeKind[NodeKind[\"VERSION\"] = 19] = \"VERSION\";\n    NodeKind[NodeKind[\"WHILE\"] = 20] = \"WHILE\";\n    // Expressions\n    NodeKind[NodeKind[\"CALL\"] = 21] = \"CALL\";\n    NodeKind[NodeKind[\"DOT\"] = 22] = \"DOT\";\n    NodeKind[NodeKind[\"HOOK\"] = 23] = \"HOOK\";\n    NodeKind[NodeKind[\"NAME\"] = 24] = \"NAME\";\n    NodeKind[NodeKind[\"PARSE_ERROR\"] = 25] = \"PARSE_ERROR\";\n    NodeKind[NodeKind[\"SEQUENCE\"] = 26] = \"SEQUENCE\";\n    NodeKind[NodeKind[\"TYPE\"] = 27] = \"TYPE\";\n    NodeKind[NodeKind[\"UNKNOWN_CONSTANT\"] = 28] = \"UNKNOWN_CONSTANT\";\n    // Literals\n    NodeKind[NodeKind[\"BOOL\"] = 29] = \"BOOL\";\n    NodeKind[NodeKind[\"FLOAT\"] = 30] = \"FLOAT\";\n    NodeKind[NodeKind[\"INT\"] = 31] = \"INT\";\n    // Unary prefix\n    NodeKind[NodeKind[\"NEGATIVE\"] = 32] = \"NEGATIVE\";\n    NodeKind[NodeKind[\"NOT\"] = 33] = \"NOT\";\n    NodeKind[NodeKind[\"POSITIVE\"] = 34] = \"POSITIVE\";\n    // Unary prefix assign\n    NodeKind[NodeKind[\"PREFIX_DECREMENT\"] = 35] = \"PREFIX_DECREMENT\";\n    NodeKind[NodeKind[\"PREFIX_INCREMENT\"] = 36] = \"PREFIX_INCREMENT\";\n    // Unary postfix assign\n    NodeKind[NodeKind[\"POSTFIX_DECREMENT\"] = 37] = \"POSTFIX_DECREMENT\";\n    NodeKind[NodeKind[\"POSTFIX_INCREMENT\"] = 38] = \"POSTFIX_INCREMENT\";\n    // Binary\n    NodeKind[NodeKind[\"ADD\"] = 39] = \"ADD\";\n    NodeKind[NodeKind[\"DIVIDE\"] = 40] = \"DIVIDE\";\n    NodeKind[NodeKind[\"EQUAL\"] = 41] = \"EQUAL\";\n    NodeKind[NodeKind[\"GREATER_THAN\"] = 42] = \"GREATER_THAN\";\n    NodeKind[NodeKind[\"GREATER_THAN_OR_EQUAL\"] = 43] = \"GREATER_THAN_OR_EQUAL\";\n    NodeKind[NodeKind[\"INDEX\"] = 44] = \"INDEX\";\n    NodeKind[NodeKind[\"LESS_THAN\"] = 45] = \"LESS_THAN\";\n    NodeKind[NodeKind[\"LESS_THAN_OR_EQUAL\"] = 46] = \"LESS_THAN_OR_EQUAL\";\n    NodeKind[NodeKind[\"LOGICAL_AND\"] = 47] = \"LOGICAL_AND\";\n    NodeKind[NodeKind[\"LOGICAL_OR\"] = 48] = \"LOGICAL_OR\";\n    NodeKind[NodeKind[\"LOGICAL_XOR\"] = 49] = \"LOGICAL_XOR\";\n    NodeKind[NodeKind[\"MULTIPLY\"] = 50] = \"MULTIPLY\";\n    NodeKind[NodeKind[\"NOT_EQUAL\"] = 51] = \"NOT_EQUAL\";\n    NodeKind[NodeKind[\"SUBTRACT\"] = 52] = \"SUBTRACT\";\n    // Binary assignment\n    NodeKind[NodeKind[\"ASSIGN\"] = 53] = \"ASSIGN\";\n    NodeKind[NodeKind[\"ASSIGN_ADD\"] = 54] = \"ASSIGN_ADD\";\n    NodeKind[NodeKind[\"ASSIGN_DIVIDE\"] = 55] = \"ASSIGN_DIVIDE\";\n    NodeKind[NodeKind[\"ASSIGN_MULTIPLY\"] = 56] = \"ASSIGN_MULTIPLY\";\n    NodeKind[NodeKind[\"ASSIGN_SUBTRACT\"] = 57] = \"ASSIGN_SUBTRACT\";\n})(NodeKind || (NodeKind = {}));\nexport class Node {\n    constructor(kind) {\n        this.id = Node._createID();\n        this.kind = kind;\n        this.range = null;\n        this.internalRange = null;\n        this.symbol = null;\n        this.resolvedType = null;\n        this._literal = 0;\n        this._text = null;\n        this._parent = null;\n        this._firstChild = null;\n        this._lastChild = null;\n        this._previousSibling = null;\n        this._nextSibling = null;\n        this.hasControlFlowAtEnd = false;\n    }\n    _copyMembersFrom(node) {\n        this.kind = node.kind;\n        this.range = node.range;\n        this.internalRange = node.internalRange;\n        this.symbol = node.symbol;\n        this.resolvedType = node.resolvedType;\n        this._literal = node._literal;\n        this._text = node._text;\n    }\n    cloneWithoutChildren() {\n        let clone = new Node(this.kind);\n        clone._copyMembersFrom(this);\n        return clone;\n    }\n    clone() {\n        let clone = this.cloneWithoutChildren();\n        for (let child = this._firstChild; child !== null; child = child._nextSibling) {\n            clone.appendChild(child.clone());\n        }\n        return clone;\n    }\n    parent() {\n        return this._parent;\n    }\n    firstChild() {\n        return this._firstChild;\n    }\n    lastChild() {\n        return this._lastChild;\n    }\n    previousSibling() {\n        return this._previousSibling;\n    }\n    nextSibling() {\n        return this._nextSibling;\n    }\n    // This is cheaper than childCount == 0\n    hasChildren() {\n        return this._firstChild !== null;\n    }\n    childCount() {\n        let count = 0;\n        for (let child = this._firstChild; child !== null; child = child._nextSibling) {\n            count = count + 1;\n        }\n        return count;\n    }\n    childAt(index) {\n        assert(0 <= index && index < this.childCount());\n        let child = this._firstChild;\n        while (index !== 0) {\n            child = child._nextSibling;\n            index = index - 1;\n        }\n        return child;\n    }\n    withType(value) {\n        this.resolvedType = value;\n        return this;\n    }\n    withSymbol(value) {\n        this.symbol = value;\n        return this;\n    }\n    withBool(value) {\n        this._literal = value ? 1 : 0;\n        return this;\n    }\n    withInt(value) {\n        this._literal = value;\n        return this;\n    }\n    withFloat(value) {\n        this._literal = value;\n        return this;\n    }\n    withText(value) {\n        this._text = value;\n        return this;\n    }\n    withRange(value) {\n        this.range = value;\n        return this;\n    }\n    withInternalRange(value) {\n        this.internalRange = value;\n        return this;\n    }\n    appendChild(node) {\n        if (node === null) {\n            return this;\n        }\n        assert(node !== this);\n        assert(node._parent === null);\n        assert(node._previousSibling === null);\n        assert(node._nextSibling === null);\n        node._parent = this;\n        if (this.hasChildren()) {\n            node._previousSibling = this._lastChild;\n            this._lastChild._nextSibling = node;\n            this._lastChild = node;\n        }\n        else {\n            this._lastChild = this._firstChild = node;\n        }\n        return this;\n    }\n    remove() {\n        assert(this._parent !== null);\n        if (this._previousSibling !== null) {\n            assert(this._previousSibling._nextSibling === this);\n            this._previousSibling._nextSibling = this._nextSibling;\n        }\n        else {\n            assert(this._parent._firstChild === this);\n            this._parent._firstChild = this._nextSibling;\n        }\n        if (this._nextSibling !== null) {\n            assert(this._nextSibling._previousSibling === this);\n            this._nextSibling._previousSibling = this._previousSibling;\n        }\n        else {\n            assert(this._parent._lastChild === this);\n            this._parent._lastChild = this._previousSibling;\n        }\n        this._parent = null;\n        this._previousSibling = null;\n        this._nextSibling = null;\n        return this;\n    }\n    insertChildBefore(after, before) {\n        if (before === null) {\n            return this;\n        }\n        assert(before !== after);\n        assert(before._parent === null);\n        assert(before._previousSibling === null);\n        assert(before._nextSibling === null);\n        assert(after === null || after._parent === this);\n        if (after === null) {\n            return this.appendChild(before);\n        }\n        before._parent = this;\n        before._previousSibling = after._previousSibling;\n        before._nextSibling = after;\n        if (after._previousSibling !== null) {\n            assert(after === after._previousSibling._nextSibling);\n            after._previousSibling._nextSibling = before;\n        }\n        else {\n            assert(after === this._firstChild);\n            this._firstChild = before;\n        }\n        after._previousSibling = before;\n        return this;\n    }\n    isTrue() {\n        return this.kind === NodeKind.BOOL && this.asBool();\n    }\n    isFalse() {\n        return this.kind === NodeKind.BOOL && !this.asBool();\n    }\n    isCallTarget() {\n        return this.parent() !== null && this.parent().kind === NodeKind.CALL && this.parent().callTarget() === this;\n    }\n    isAssignTarget() {\n        return this.parent() !== null && (NodeKind_isUnaryAssign(this.parent().kind) || NodeKind_isBinaryAssign(this.parent().kind) && this.parent().binaryLeft() === this);\n    }\n    isEmptySequence() {\n        return this.kind === NodeKind.SEQUENCE && !this.hasChildren();\n    }\n    looksTheSameAs(node) {\n        if (this.kind === node.kind) {\n            switch (this.kind) {\n                case NodeKind.BOOL: {\n                    return this.asBool() === node.asBool();\n                }\n                case NodeKind.FLOAT: {\n                    return this.asFloat() === node.asFloat();\n                }\n                case NodeKind.INT: {\n                    return this.asInt() === node.asInt();\n                }\n                case NodeKind.NAME: {\n                    return this.symbol === node.symbol;\n                }\n                case NodeKind.TYPE: {\n                    return this.resolvedType === node.resolvedType;\n                }\n                case NodeKind.DOT: {\n                    return this.dotTarget().looksTheSameAs(node.dotTarget()) && this.symbol === node.symbol && this.asString() === node.asString();\n                }\n                case NodeKind.HOOK: {\n                    return this.hookTest().looksTheSameAs(node.hookTest()) && this.hookTrue().looksTheSameAs(node.hookTrue()) && this.hookFalse().looksTheSameAs(node.hookFalse());\n                }\n                case NodeKind.CALL: {\n                    let left = this.firstChild();\n                    let right = node.firstChild();\n                    while (left !== null && right !== null) {\n                        if (!left.looksTheSameAs(right)) {\n                            return false;\n                        }\n                        left = left.nextSibling();\n                        right = right.nextSibling();\n                    }\n                    return left === null && right === null;\n                }\n                default: {\n                    if (NodeKind_isUnary(this.kind)) {\n                        return this.unaryValue().looksTheSameAs(node.unaryValue());\n                    }\n                    if (NodeKind_isBinary(this.kind)) {\n                        return this.binaryLeft().looksTheSameAs(node.binaryLeft()) && this.binaryRight().looksTheSameAs(node.binaryRight());\n                    }\n                    break;\n                }\n            }\n        }\n        return false;\n    }\n    static createGlobal() {\n        return new Node(NodeKind.GLOBAL);\n    }\n    static createStructBlock() {\n        return new Node(NodeKind.STRUCT_BLOCK);\n    }\n    static createVariable(symbol, value) {\n        return new Node(NodeKind.VARIABLE).withSymbol(symbol).appendChild(value);\n    }\n    static createBlock() {\n        return new Node(NodeKind.BLOCK);\n    }\n    static createBreak() {\n        return new Node(NodeKind.BREAK);\n    }\n    static createContinue() {\n        return new Node(NodeKind.CONTINUE);\n    }\n    static createDiscard() {\n        return new Node(NodeKind.DISCARD);\n    }\n    static createDoWhile(body, test) {\n        assert(NodeKind_isStatement(body.kind));\n        assert(NodeKind_isExpression(test.kind));\n        return new Node(NodeKind.DO_WHILE).appendChild(body).appendChild(test);\n    }\n    static createExpression(value) {\n        assert(NodeKind_isExpression(value.kind));\n        return new Node(NodeKind.EXPRESSION).appendChild(value);\n    }\n    static createExtension(name, behavior) {\n        return new Node(NodeKind.EXTENSION).withText(name).withInt(behavior);\n    }\n    static createDefine() {\n        return new Node(NodeKind.DEFINE);\n    }\n    static createFor(setup, test, update, body) {\n        assert(setup === null || NodeKind_isExpression(setup.kind) || setup.kind === NodeKind.VARIABLES);\n        assert(test === null || NodeKind_isExpression(test.kind));\n        assert(update === null || NodeKind_isExpression(update.kind));\n        assert(NodeKind_isStatement(body.kind));\n        return new Node(NodeKind.FOR).appendChild(setup === null ? Node.createSequence() : setup).appendChild(test === null ? Node.createSequence() : test).appendChild(update === null ? Node.createSequence() : update).appendChild(body);\n    }\n    static createFunction(symbol) {\n        return new Node(NodeKind.FUNCTION).withSymbol(symbol);\n    }\n    static createIf(test, yes, no) {\n        assert(NodeKind_isExpression(test.kind));\n        assert(NodeKind_isStatement(yes.kind));\n        assert(no === null || NodeKind_isStatement(no.kind));\n        return new Node(NodeKind.IF).appendChild(test).appendChild(yes).appendChild(no);\n    }\n    static createModifierBlock() {\n        return new Node(NodeKind.MODIFIER_BLOCK);\n    }\n    static createPrecision(flags, type) {\n        assert(NodeKind_isExpression(type.kind));\n        return new Node(NodeKind.PRECISION).withInt(flags).appendChild(type);\n    }\n    static createReturn(value) {\n        assert(value === null || NodeKind_isExpression(value.kind));\n        return new Node(NodeKind.RETURN).appendChild(value);\n    }\n    static createStruct(symbol, block, variables) {\n        assert(block.kind === NodeKind.STRUCT_BLOCK);\n        assert(variables === null || variables.kind === NodeKind.VARIABLES);\n        return new Node(NodeKind.STRUCT).withSymbol(symbol).appendChild(block).appendChild(variables);\n    }\n    static createVariables(flags, type) {\n        assert(NodeKind_isExpression(type.kind));\n        return new Node(NodeKind.VARIABLES).withInt(flags).appendChild(type);\n    }\n    static createVersion(version) {\n        return new Node(NodeKind.VERSION).withInt(version);\n    }\n    static createWhile(test, body) {\n        assert(NodeKind_isExpression(test.kind));\n        assert(NodeKind_isStatement(body.kind));\n        return new Node(NodeKind.WHILE).appendChild(test).appendChild(body);\n    }\n    static createCall(value) {\n        assert(NodeKind_isExpression(value.kind));\n        return new Node(NodeKind.CALL).appendChild(value);\n    }\n    static createConstructorCall(type) {\n        return Node.createCall(Node.createType(type)).withType(type);\n    }\n    static createDot(value, text) {\n        assert(NodeKind_isExpression(value.kind));\n        assert(text !== null);\n        return new Node(NodeKind.DOT).appendChild(value).withText(text);\n    }\n    static createHook(test, yes, no) {\n        assert(NodeKind_isExpression(test.kind));\n        assert(NodeKind_isExpression(yes.kind));\n        assert(NodeKind_isExpression(no.kind));\n        return new Node(NodeKind.HOOK).appendChild(test).appendChild(yes).appendChild(no);\n    }\n    static createName(symbol) {\n        return new Node(NodeKind.NAME).withSymbol(symbol);\n    }\n    static createParseError() {\n        return new Node(NodeKind.PARSE_ERROR).withType(Type.ERROR);\n    }\n    static createSequence() {\n        return new Node(NodeKind.SEQUENCE);\n    }\n    static createType(type) {\n        return new Node(NodeKind.TYPE).withType(type);\n    }\n    static createUnknownConstant(type) {\n        return new Node(NodeKind.UNKNOWN_CONSTANT).withType(type);\n    }\n    static createBool(value) {\n        return new Node(NodeKind.BOOL).withBool(value).withType(Type.BOOL);\n    }\n    static createInt(value) {\n        return new Node(NodeKind.INT).withInt(value).withType(Type.INT);\n    }\n    static createFloat(value) {\n        return new Node(NodeKind.FLOAT).withFloat(value).withType(Type.FLOAT);\n    }\n    static createUnary(kind, value) {\n        assert(NodeKind_isUnary(kind));\n        return new Node(kind).appendChild(value);\n    }\n    static createBinary(kind, left, right) {\n        assert(NodeKind_isBinary(kind));\n        return new Node(kind).appendChild(left).appendChild(right);\n    }\n    variableInitializer() {\n        assert(this.kind === NodeKind.VARIABLE);\n        assert(this.childCount() <= 1);\n        return this._firstChild;\n    }\n    doWhileBody() {\n        assert(this.kind === NodeKind.DO_WHILE);\n        assert(this.childCount() === 2);\n        assert(NodeKind_isStatement(this._firstChild.kind));\n        return this._firstChild;\n    }\n    doWhileTest() {\n        assert(this.kind === NodeKind.DO_WHILE);\n        assert(this.childCount() === 2);\n        assert(NodeKind_isExpression(this._lastChild.kind));\n        return this._lastChild;\n    }\n    expressionValue() {\n        assert(this.kind === NodeKind.EXPRESSION);\n        assert(this.childCount() === 1);\n        assert(NodeKind_isExpression(this._firstChild.kind));\n        return this._firstChild;\n    }\n    forSetup() {\n        assert(this.kind === NodeKind.FOR);\n        assert(this.childCount() === 4);\n        assert(NodeKind_isExpression(this._firstChild.kind) || this._firstChild.kind === NodeKind.VARIABLES);\n        return this._firstChild.isEmptySequence() ? null : this._firstChild;\n    }\n    forTest() {\n        assert(this.kind === NodeKind.FOR);\n        assert(this.childCount() === 4);\n        assert(NodeKind_isExpression(this._firstChild._nextSibling.kind) || this._firstChild._nextSibling.kind === NodeKind.VARIABLES);\n        return this._firstChild._nextSibling.isEmptySequence() ? null : this._firstChild._nextSibling;\n    }\n    forUpdate() {\n        assert(this.kind === NodeKind.FOR);\n        assert(this.childCount() === 4);\n        assert(NodeKind_isExpression(this._lastChild._previousSibling.kind));\n        return this._lastChild._previousSibling.isEmptySequence() ? null : this._lastChild._previousSibling;\n    }\n    forBody() {\n        assert(this.kind === NodeKind.FOR);\n        assert(this.childCount() === 4);\n        assert(NodeKind_isStatement(this._lastChild.kind));\n        return this._lastChild;\n    }\n    ifTest() {\n        assert(this.kind === NodeKind.IF);\n        assert(this.childCount() === 2 || this.childCount() === 3);\n        assert(NodeKind_isExpression(this._firstChild.kind));\n        return this._firstChild;\n    }\n    ifTrue() {\n        assert(this.kind === NodeKind.IF);\n        assert(this.childCount() === 2 || this.childCount() === 3);\n        assert(NodeKind_isStatement(this._firstChild._nextSibling.kind));\n        return this._firstChild._nextSibling;\n    }\n    ifFalse() {\n        assert(this.kind === NodeKind.IF);\n        assert(this.childCount() === 2 || this.childCount() === 3);\n        assert(this._firstChild._nextSibling._nextSibling === null || NodeKind_isStatement(this._firstChild._nextSibling._nextSibling.kind));\n        return this._firstChild._nextSibling._nextSibling;\n    }\n    returnValue() {\n        assert(this.kind === NodeKind.RETURN);\n        assert(this.childCount() <= 1);\n        assert(this._firstChild === null || NodeKind_isExpression(this._firstChild.kind));\n        return this._firstChild;\n    }\n    variablesType() {\n        assert(this.kind === NodeKind.VARIABLES);\n        assert(this.childCount() >= 1);\n        assert(NodeKind_isExpression(this._firstChild.kind));\n        return this._firstChild;\n    }\n    whileTest() {\n        assert(this.kind === NodeKind.WHILE);\n        assert(this.childCount() === 2);\n        assert(NodeKind_isExpression(this._firstChild.kind));\n        return this._firstChild;\n    }\n    whileBody() {\n        assert(this.kind === NodeKind.WHILE);\n        assert(this.childCount() === 2);\n        assert(NodeKind_isStatement(this._lastChild.kind));\n        return this._lastChild;\n    }\n    callTarget() {\n        assert(this.kind === NodeKind.CALL);\n        assert(this.childCount() >= 1);\n        assert(NodeKind_isExpression(this._firstChild.kind));\n        return this._firstChild;\n    }\n    dotTarget() {\n        assert(this.kind === NodeKind.DOT);\n        assert(this.childCount() === 1);\n        assert(NodeKind_isExpression(this._firstChild.kind));\n        return this._firstChild;\n    }\n    hookTest() {\n        assert(this.kind === NodeKind.HOOK);\n        assert(this.childCount() === 3);\n        assert(NodeKind_isExpression(this._firstChild.kind));\n        return this._firstChild;\n    }\n    hookTrue() {\n        assert(this.kind === NodeKind.HOOK);\n        assert(this.childCount() === 3);\n        assert(NodeKind_isExpression(this._firstChild._nextSibling.kind));\n        return this._firstChild._nextSibling;\n    }\n    hookFalse() {\n        assert(this.kind === NodeKind.HOOK);\n        assert(this.childCount() === 3);\n        assert(NodeKind_isExpression(this._lastChild.kind));\n        return this._lastChild;\n    }\n    asString() {\n        assert(this.kind === NodeKind.DOT);\n        assert(this._text !== null);\n        return this._text;\n    }\n    asBool() {\n        assert(this.kind === NodeKind.BOOL);\n        return !!this._literal;\n    }\n    asFloat() {\n        assert(this.kind === NodeKind.FLOAT);\n        return this._literal;\n    }\n    asInt() {\n        assert(this.kind === NodeKind.INT);\n        return this._literal | 0;\n    }\n    unaryValue() {\n        assert(NodeKind_isUnary(this.kind));\n        assert(this.childCount() === 1);\n        assert(NodeKind_isExpression(this._firstChild.kind));\n        return this._firstChild;\n    }\n    binaryLeft() {\n        assert(NodeKind_isBinary(this.kind));\n        assert(this.childCount() === 2);\n        assert(NodeKind_isExpression(this._firstChild.kind));\n        return this._firstChild;\n    }\n    binaryRight() {\n        assert(NodeKind_isBinary(this.kind));\n        assert(this.childCount() === 2);\n        assert(NodeKind_isExpression(this._lastChild.kind));\n        return this._lastChild;\n    }\n    static _createID() {\n        Node._nextID = Node._nextID + 1;\n        return Node._nextID;\n    }\n}\nNode._nextID = 0;\nexport function NodeKind_isStatement(self) {\n    return self >= NodeKind.BLOCK && self <= NodeKind.WHILE;\n}\nexport function NodeKind_isExpression(self) {\n    return self >= NodeKind.CALL && self <= NodeKind.ASSIGN_SUBTRACT;\n}\nexport function NodeKind_isUnary(self) {\n    return self >= NodeKind.NEGATIVE && self <= NodeKind.POSTFIX_INCREMENT;\n}\nexport function NodeKind_isUnaryPrefix(self) {\n    return self >= NodeKind.NEGATIVE && self <= NodeKind.PREFIX_INCREMENT;\n}\nexport function NodeKind_isUnaryPostfix(self) {\n    return self >= NodeKind.POSTFIX_DECREMENT && self <= NodeKind.POSTFIX_INCREMENT;\n}\nexport function NodeKind_isUnaryAssign(self) {\n    return self >= NodeKind.PREFIX_DECREMENT && self <= NodeKind.POSTFIX_INCREMENT;\n}\nexport function NodeKind_isBinary(self) {\n    return self >= NodeKind.ADD && self <= NodeKind.ASSIGN_SUBTRACT;\n}\nexport function NodeKind_isBinaryAssign(self) {\n    return self >= NodeKind.ASSIGN && self <= NodeKind.ASSIGN_SUBTRACT;\n}\nexport function NodeKind_isLoop(self) {\n    return self === NodeKind.DO_WHILE || self === NodeKind.FOR || self === NodeKind.WHILE;\n}\n","import { IntMap_get4, IntMap_set3, assert } from \"../../native-js\";\nimport { StructSymbol } from \"./symbol\";\nexport class Type {\n    constructor(symbol, isArrayOf, arrayCount) {\n        this.symbol = symbol;\n        this.isArrayOf = isArrayOf;\n        this.arrayCount = arrayCount;\n        this.containsArray = false;\n        this.containsSampler = false;\n        this._arrayTypes = null;\n    }\n    // A count of \"0\" means an array with an unknown size\n    arrayType(count) {\n        assert(count >= 0);\n        if (this._arrayTypes === null) {\n            this._arrayTypes = new Map();\n        }\n        let arrayType = IntMap_get4(this._arrayTypes, count, null);\n        if (arrayType === null) {\n            IntMap_set3(this._arrayTypes, count, arrayType = new Type(null, this, count));\n            arrayType.containsArray = true;\n            arrayType.containsSampler = this.containsSampler;\n        }\n        return arrayType;\n    }\n    toString() {\n        if (this.isArrayOf !== null) {\n            return this.arrayCount !== 0 ? `${this.isArrayOf}[${this.arrayCount}]` : `${this.isArrayOf}[]`;\n        }\n        return this.symbol.name;\n    }\n    // For index expressions where \"0 <= index < indexCount\" (so indexCount == 0 means this type is un-indexable)\n    indexCount() {\n        let value = this;\n        if (value === Type.UVEC2 || value === Type.BVEC2 || value === Type.VEC2 || value === Type.IVEC2 || value === Type.MAT2) {\n            return 2;\n        }\n        else if (value === Type.UVEC3 || value === Type.BVEC3 || value === Type.VEC3 || value === Type.IVEC3 || value === Type.MAT3) {\n            return 3;\n        }\n        else if (value === Type.UVEC4 || value === Type.BVEC4 || value === Type.VEC4 || value === Type.IVEC4 || value === Type.MAT4) {\n            return 4;\n        }\n        else {\n            return this.arrayCount;\n        }\n    }\n    // For index expressions\n    indexType() {\n        let value = this;\n        if (value === Type.BVEC2 || value === Type.BVEC3 || value === Type.BVEC4) {\n            return Type.BOOL;\n        }\n        else if (value === Type.VEC2 || value === Type.VEC3 || value === Type.VEC4) {\n            return Type.FLOAT;\n        }\n        else if (value === Type.IVEC2 || value === Type.IVEC3 || value === Type.IVEC4) {\n            return Type.INT;\n        }\n        else if (value === Type.UVEC2 || value === Type.UVEC3 || value === Type.UVEC4) {\n            return Type.UINT;\n        }\n        else if (value === Type.MAT2) {\n            return Type.VEC2;\n        }\n        else if (value === Type.MAT3) {\n            return Type.VEC3;\n        }\n        else if (value === Type.MAT4) {\n            return Type.VEC4;\n        }\n        else {\n            return this.isArrayOf;\n        }\n    }\n    // For constructor expressions, returns the number of required elements\n    componentCount() {\n        let value = this;\n        if (value === Type.BOOL || value === Type.FLOAT || value === Type.INT || value === Type.UINT) {\n            return 1;\n        }\n        else if (value === Type.BVEC2 || value === Type.VEC2 || value === Type.IVEC2 || value === Type.UVEC2) {\n            return 2;\n        }\n        else if (value === Type.BVEC3 || value === Type.VEC3 || value === Type.IVEC3 || value === Type.UVEC3) {\n            return 3;\n        }\n        else if (value === Type.BVEC4 || value === Type.VEC4 || value === Type.IVEC4 || value === Type.MAT2 || value === Type.UVEC4) {\n            return 4;\n        }\n        else if (value === Type.MAT3) {\n            return 9;\n        }\n        else if (value === Type.MAT4) {\n            return 16;\n        }\n        else {\n            return 0;\n        }\n    }\n    // For constructor expressions, returns the base element type corresponding to componentCount\n    componentType() {\n        let value = this;\n        if (value === Type.BOOL || value === Type.BVEC2 || value === Type.BVEC3 || value === Type.BVEC4) {\n            return Type.BOOL;\n        }\n        else if (value === Type.FLOAT || value === Type.VEC2 || value === Type.VEC3 || value === Type.VEC4 || value === Type.MAT2 || value === Type.MAT3 || value === Type.MAT4) {\n            return Type.FLOAT;\n        }\n        else if (value === Type.INT || value === Type.IVEC2 || value === Type.IVEC3 || value === Type.IVEC4) {\n            return Type.INT;\n        }\n        else if (value === Type.UINT || value === Type.UVEC2 || value === Type.UVEC3 || value === Type.UVEC4) {\n            return Type.UINT;\n        }\n        else {\n            return null;\n        }\n    }\n    // Vector types are the only ones with swizzles\n    isVector() {\n        let value = this;\n        if (value === Type.BVEC2 || value === Type.BVEC3 || value === Type.BVEC4 || value === Type.IVEC2 || value === Type.IVEC3 || value === Type.IVEC4 || value === Type.VEC2 || value === Type.VEC3 || value === Type.VEC4 || value === Type.UVEC2 || value === Type.UVEC3 || value === Type.UVEC3 || value === Type.UVEC4) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    isMatrix() {\n        let value = this;\n        if (value === Type.MAT2 || value === Type.MAT3 || value === Type.MAT4) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    hasIntComponents() {\n        let value = this;\n        if (value === Type.INT || value === Type.IVEC2 || value === Type.IVEC3 || value === Type.IVEC4 || value === Type.UINT) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    hasFloatComponents() {\n        let value = this;\n        if (value === Type.FLOAT || value === Type.VEC2 || value === Type.VEC3 || value === Type.VEC4) {\n            return true;\n        }\n        else if (value === Type.MAT2 || value === Type.MAT3 || value === Type.MAT4) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    isIntOrFloat() {\n        return this.hasIntComponents() || this.hasFloatComponents();\n    }\n    canUseEqualityOperators() {\n        return !this.containsSampler && !this.containsArray;\n    }\n    _setContainsSampler() {\n        this.containsSampler = true;\n        return this;\n    }\n}\nType.BOOL = new StructSymbol(-1, null, 'bool', null).resolvedType();\nType.BVEC2 = new StructSymbol(-2, null, 'bvec2', null).resolvedType();\nType.BVEC3 = new StructSymbol(-3, null, 'bvec3', null).resolvedType();\nType.BVEC4 = new StructSymbol(-4, null, 'bvec4', null).resolvedType();\nType.ERROR = new StructSymbol(-5, null, '<error>', null).resolvedType();\nType.FLOAT = new StructSymbol(-6, null, 'float', null).resolvedType();\nType.INT = new StructSymbol(-7, null, 'int', null).resolvedType();\nType.UINT = new StructSymbol(-8, null, 'uint', null).resolvedType();\nType.IVEC2 = new StructSymbol(-9, null, 'ivec2', null).resolvedType();\nType.IVEC3 = new StructSymbol(-10, null, 'ivec3', null).resolvedType();\nType.IVEC4 = new StructSymbol(-11, null, 'ivec4', null).resolvedType();\nType.UVEC2 = new StructSymbol(-12, null, 'uvec2', null).resolvedType();\nType.UVEC3 = new StructSymbol(-13, null, 'uvec3', null).resolvedType();\nType.UVEC4 = new StructSymbol(-14, null, 'uvec4', null).resolvedType();\nType.MAT2 = new StructSymbol(-15, null, 'mat2', null).resolvedType();\nType.MAT3 = new StructSymbol(-16, null, 'mat3', null).resolvedType();\nType.MAT4 = new StructSymbol(-17, null, 'mat4', null).resolvedType();\nType.SAMPLER2D = new StructSymbol(-18, null, 'sampler2D', null).resolvedType()._setContainsSampler();\nType.SAMPLERCUBE = new StructSymbol(-19, null, 'samplerCube', null).resolvedType()._setContainsSampler();\nType.VEC2 = new StructSymbol(-20, null, 'vec2', null).resolvedType();\nType.VEC3 = new StructSymbol(-21, null, 'vec3', null).resolvedType();\nType.VEC4 = new StructSymbol(-22, null, 'vec4', null).resolvedType();\nType.VOID = new StructSymbol(-23, null, 'void', null).resolvedType();\nType.SAMPLER3D = new StructSymbol(-24, null, 'sampler3D', null).resolvedType()._setContainsSampler();\nType.ISAMPLERCUBE = new StructSymbol(-25, null, 'isamplerCube', null).resolvedType()._setContainsSampler();\nType.USAMPLERCUBE = new StructSymbol(-26, null, 'usamplerCube', null).resolvedType()._setContainsSampler();\nType.SAMPLER2DARRAY = new StructSymbol(-27, null, 'sampler2DArray', null).resolvedType()._setContainsSampler();\nType.ISAMPLER2DARRAY = new StructSymbol(-28, null, 'isampler2DArray', null).resolvedType()._setContainsSampler();\nType.USAMPLER2DARRAY = new StructSymbol(-29, null, 'usampler2DArray', null).resolvedType()._setContainsSampler();\nType.SAMPLER2DSHADOW = new StructSymbol(-30, null, 'sampler2DShadow', null).resolvedType()._setContainsSampler();\nType.SAMPLERCUBESHADOW = new StructSymbol(-31, null, 'samplerCubeShadow', null).resolvedType()._setContainsSampler();\nType.SAMPLER2DARRAYSHADOW = new StructSymbol(-32, null, 'sampler2DArrayShadow', null).resolvedType()._setContainsSampler();\nType.USAMPLER2DARRAYSHADOW = new StructSymbol(-33, null, 'usampler2DArrayShadow', null).resolvedType()._setContainsSampler();\nType.ISAMPLER2D = new StructSymbol(-34, null, 'isampler2D', null).resolvedType()._setContainsSampler();\nType.USAMPLER2D = new StructSymbol(-35, null, 'usampler2D', null).resolvedType()._setContainsSampler();\nType.ISAMPLER3D = new StructSymbol(-36, null, 'isampler3D', null).resolvedType()._setContainsSampler();\nType.USAMPLER3D = new StructSymbol(-37, null, 'usampler3D', null).resolvedType()._setContainsSampler();\nType.ISAMPLER2DARRAYSHADOW = new StructSymbol(-38, null, 'isampler2DArrayShadow', null).resolvedType()._setContainsSampler();\nType.BUILT_INS = [Type.BOOL, Type.BVEC2, Type.BVEC3, Type.BVEC4, Type.FLOAT, Type.INT, Type.UINT, Type.IVEC2, Type.IVEC3, Type.IVEC4, Type.UVEC2, Type.UVEC3, Type.UVEC4, Type.MAT2, Type.MAT3, Type.MAT4, Type.SAMPLER2D, Type.SAMPLERCUBE, Type.VEC2, Type.VEC3, Type.VEC4, Type.SAMPLER3D, Type.ISAMPLERCUBE, Type.USAMPLERCUBE, Type.SAMPLER2DARRAY, Type.ISAMPLER2DARRAY, Type.USAMPLER2DARRAY, Type.SAMPLER2DSHADOW, Type.SAMPLERCUBESHADOW, Type.SAMPLER2DARRAYSHADOW, Type.USAMPLER2DARRAYSHADOW, Type.ISAMPLER2D, Type.USAMPLER2D, Type.ISAMPLER3D, Type.USAMPLER3D, Type.ISAMPLER2DARRAYSHADOW];\n","import { List_set1 } from \"./native-js\";\nexport function List_setLast(self, x) {\n    return List_set1(self, self.length - 1, x);\n}\nexport function int_compare1(self, x) {\n    return (x < self ? 1 : 0) - (x > self ? 1 : 0);\n}\nexport let RELEASE = false;\n","import { assert } from \"../../native-js\";\nimport { Type } from \"./type\";\nexport function strings(componentCount) {\n    switch (componentCount) {\n        case 2: {\n            return _STRINGS_2;\n        }\n        case 3: {\n            return _STRINGS_3;\n        }\n        case 4: {\n            return _STRINGS_4;\n        }\n    }\n    assert(false);\n    return null;\n}\nexport function swizzleType(comonentType, componentCount) {\n    let value = comonentType;\n    if (value === Type.BOOL) {\n        switch (componentCount) {\n            case 1: {\n                return Type.BOOL;\n            }\n            case 2: {\n                return Type.BVEC2;\n            }\n            case 3: {\n                return Type.BVEC3;\n            }\n            case 4: {\n                return Type.BVEC4;\n            }\n        }\n    }\n    else if (value === Type.FLOAT) {\n        switch (componentCount) {\n            case 1: {\n                return Type.FLOAT;\n            }\n            case 2: {\n                return Type.VEC2;\n            }\n            case 3: {\n                return Type.VEC3;\n            }\n            case 4: {\n                return Type.VEC4;\n            }\n        }\n    }\n    else if (value === Type.INT) {\n        switch (componentCount) {\n            case 1: {\n                return Type.INT;\n            }\n            case 2: {\n                return Type.IVEC2;\n            }\n            case 3: {\n                return Type.IVEC3;\n            }\n            case 4: {\n                return Type.IVEC4;\n            }\n        }\n    }\n    else if (value === Type.UINT) {\n        switch (componentCount) {\n            case 1: {\n                return Type.UINT;\n            }\n            case 2: {\n                return Type.UVEC2;\n            }\n            case 3: {\n                return Type.UVEC3;\n            }\n            case 4: {\n                return Type.UVEC4;\n            }\n        }\n    }\n    assert(false);\n    return null;\n}\nexport let _STRINGS_2 = ['xy', 'st', 'rg'];\nexport let _STRINGS_3 = ['xyz', 'stp', 'rgb'];\nexport let _STRINGS_4 = ['xyzw', 'stpq', 'rgba'];\n","import { RELEASE } from \"../../native\";\nimport { List_first, List_get2, assert, string_get5 } from \"../../native-js\";\nimport { Node, NodeKind } from \"./node\";\nimport { strings, swizzleType } from \"./swizzle\";\nimport { Type } from \"./type\";\nexport function fold(node) {\n    if (RELEASE) {\n        return _fold(node);\n    }\n    // Run sanity checks in debug mode\n    else {\n        let folded = _fold(node);\n        if (folded !== null) {\n            assert(folded.parent() === null);\n            if (folded.kind !== NodeKind.UNKNOWN_CONSTANT) {\n                _check(folded);\n            }\n        }\n        return folded;\n    }\n}\nexport function _check(node) {\n    switch (node.kind) {\n        case NodeKind.INT: {\n            assert(node.resolvedType === Type.INT && !node.hasChildren());\n            break;\n        }\n        case NodeKind.BOOL: {\n            assert(node.resolvedType === Type.BOOL && !node.hasChildren());\n            break;\n        }\n        case NodeKind.FLOAT: {\n            assert(node.resolvedType === Type.FLOAT && !node.hasChildren());\n            break;\n        }\n        case NodeKind.CALL: {\n            let target = node.callTarget();\n            assert(target.kind === NodeKind.TYPE);\n            assert(target.resolvedType === node.resolvedType);\n            let componentType = target.resolvedType.componentType();\n            let componentCount = target.resolvedType.componentCount();\n            // Native component types\n            if (componentType !== null) {\n                assert(node.childCount() === 1 + componentCount);\n                assert(target.resolvedType !== Type.INT && target.resolvedType !== Type.BOOL && target.resolvedType !== Type.FLOAT);\n                for (let child = target.nextSibling(); child !== null; child = child.nextSibling()) {\n                    assert(child.resolvedType === componentType);\n                    assert(child.kind !== NodeKind.CALL);\n                    _check(child);\n                }\n            }\n            // User-defined structs\n            else {\n                let struct = target.resolvedType.symbol.asStruct();\n                let i = 0;\n                assert(node.childCount() === 1 + struct.variables.length);\n                for (let child1 = target.nextSibling(); child1 !== null; child1 = child1.nextSibling()) {\n                    assert(child1.resolvedType === List_get2(struct.variables, i).type.resolvedType);\n                    _check(child1);\n                    i = i + 1;\n                }\n            }\n            break;\n        }\n        default: {\n            assert(false);\n            break;\n        }\n    }\n}\nexport function _fold(node) {\n    assert(node.resolvedType !== null);\n    if (node.resolvedType === Type.ERROR) {\n        return null;\n    }\n    switch (node.kind) {\n        case NodeKind.INT:\n        case NodeKind.FLOAT:\n        case NodeKind.BOOL: {\n            return node.clone();\n        }\n        case NodeKind.NAME: {\n            return _foldName(node);\n        }\n        case NodeKind.SEQUENCE: {\n            return _foldSequence(node);\n        }\n        case NodeKind.HOOK: {\n            return _foldHook(node);\n        }\n        case NodeKind.DOT: {\n            return _foldDot(node);\n        }\n        case NodeKind.INDEX: {\n            return _foldIndex(node);\n        }\n        case NodeKind.CALL: {\n            return _foldCall(node);\n        }\n        case NodeKind.NEGATIVE: {\n            return _foldUnaryFloatOrInt(node, (x) => {\n                return -x;\n            }, (x) => {\n                return -x;\n            });\n        }\n        case NodeKind.NOT: {\n            return _foldUnaryBool(node, (x) => {\n                return !x;\n            });\n        }\n        case NodeKind.POSITIVE: {\n            return _foldUnaryFloatOrInt(node, (x) => {\n                return +x;\n            }, (x) => {\n                return +x;\n            });\n        }\n        case NodeKind.ADD: {\n            return _foldBinaryFloatOrInt(node, (a, b) => {\n                return a + b;\n            }, (a, b) => {\n                return a + b;\n            });\n        }\n        case NodeKind.SUBTRACT: {\n            return _foldBinaryFloatOrInt(node, (a, b) => {\n                return a - b;\n            }, (a, b) => {\n                return a - b;\n            });\n        }\n        case NodeKind.MULTIPLY: {\n            return _foldMultiply(node);\n        }\n        // Dividing by zero is undefined\n        case NodeKind.DIVIDE: {\n            return _foldBinaryFloatOrInt(node, (a, b) => {\n                return b !== 0 ? a / b : 0;\n            }, (a, b) => {\n                return b !== 0 ? a / b | 0 : 0;\n            });\n        }\n        case NodeKind.EQUAL:\n        case NodeKind.NOT_EQUAL: {\n            return _foldBinaryEquality(node);\n        }\n        case NodeKind.LOGICAL_AND: {\n            return _foldBinaryBool(node, (a, b) => {\n                return a && b;\n            });\n        }\n        case NodeKind.LOGICAL_OR: {\n            return _foldBinaryBool(node, (a, b) => {\n                return a || b;\n            });\n        }\n        case NodeKind.LOGICAL_XOR: {\n            return _foldBinaryBool(node, (a, b) => {\n                return a !== b;\n            });\n        }\n        case NodeKind.GREATER_THAN: {\n            return _foldBinaryFloatOrIntToBool(node, (a, b) => {\n                return a > b;\n            });\n        }\n        case NodeKind.GREATER_THAN_OR_EQUAL: {\n            return _foldBinaryFloatOrIntToBool(node, (a, b) => {\n                return a >= b;\n            });\n        }\n        case NodeKind.LESS_THAN: {\n            return _foldBinaryFloatOrIntToBool(node, (a, b) => {\n                return a < b;\n            });\n        }\n        case NodeKind.LESS_THAN_OR_EQUAL: {\n            return _foldBinaryFloatOrIntToBool(node, (a, b) => {\n                return a <= b;\n            });\n        }\n    }\n    return null;\n}\nexport function _foldName(node) {\n    let symbol = node.symbol;\n    if (symbol !== null && symbol.isConst()) {\n        if (symbol.constantValue !== null) {\n            return symbol.constantValue.clone();\n        }\n        if (symbol.asVariable().kind !== 0 /* ARGUMENT */) {\n            return Node.createUnknownConstant(node.resolvedType);\n        }\n    }\n    return null;\n}\nexport function _foldSequence(node) {\n    for (let child = node.firstChild(); child !== null; child = child.nextSibling()) {\n        let folded = fold(child);\n        if (folded === null || child === node.lastChild()) {\n            return folded;\n        }\n    }\n    return null;\n}\nexport function _foldHook(node) {\n    let foldedTest = fold(node.hookTest());\n    let foldedTrue = fold(node.hookTrue());\n    let foldedFalse = fold(node.hookFalse());\n    if (foldedTest !== null && foldedTest.kind === NodeKind.BOOL && foldedTrue !== null && foldedFalse !== null) {\n        return foldedTest.asBool() ? foldedTrue : foldedFalse;\n    }\n    return null;\n}\nexport function _foldDot(node) {\n    let folded = fold(node.dotTarget());\n    if (folded !== null && folded.kind === NodeKind.CALL) {\n        let resolvedType = folded.resolvedType;\n        let name = node.asString();\n        // Evaluate a swizzle\n        if (resolvedType.isVector()) {\n            let count = name.length;\n            let componentCount = resolvedType.componentCount();\n            // Find the swizzle set\n            for (const set of strings(componentCount)) {\n                if (set.indexOf(string_get5(name, 0)) !== -1) {\n                    if (count === 1) {\n                        return folded.childAt(1 + set.indexOf(name)).remove();\n                    }\n                    let sType = swizzleType(resolvedType.componentType(), count);\n                    let result = Node.createConstructorCall(sType);\n                    for (let i = 0, count1 = count; i < count1; i = i + 1) {\n                        result.appendChild(folded.childAt(1 + set.indexOf(string_get5(name, i))).clone());\n                    }\n                    return result;\n                }\n            }\n        }\n        // Evaluate a struct field\n        else if (resolvedType.symbol !== null && resolvedType.symbol.isStruct()) {\n            let symbol = resolvedType.symbol.asStruct();\n            let variables = symbol.variables;\n            assert(folded.childCount() === 1 + variables.length);\n            // Extract the field from the constructor call\n            for (let i1 = 0, count2 = variables.length; i1 < count2; i1 = i1 + 1) {\n                let variable = List_get2(variables, i1);\n                if (variable.name === name) {\n                    return folded.childAt(1 + i1).remove();\n                }\n            }\n        }\n    }\n    return null;\n}\nexport function _foldIndex(node) {\n    let foldedLeft = fold(node.binaryLeft());\n    let foldedRight = fold(node.binaryRight());\n    // Both children must also be constants\n    if (foldedLeft !== null && foldedLeft.kind === NodeKind.CALL && foldedRight !== null && foldedRight.kind === NodeKind.INT) {\n        let type = foldedLeft.resolvedType;\n        if (type.isVector()) {\n            let indexCount = type.indexCount();\n            let index = foldedRight.asInt();\n            // The index must be in range\n            if (0 <= index && index < indexCount) {\n                return foldedLeft.childAt(index + 1).remove();\n            }\n        }\n        // Indexing into a matrix creates a vector\n        else if (type.isMatrix()) {\n            let indexCount1 = type.indexCount();\n            let index1 = foldedRight.asInt();\n            assert(foldedLeft.childCount() === 1 + indexCount1 * indexCount1);\n            // The index must be in range\n            if (0 <= index1 && index1 < indexCount1) {\n                let indexType = type.indexType();\n                let result = Node.createConstructorCall(indexType);\n                let before = foldedLeft.childAt(index1 * indexCount1);\n                for (let i = 0, count = indexCount1; i < count; i = i + 1) {\n                    result.appendChild(before.nextSibling().remove());\n                }\n                return result;\n            }\n        }\n    }\n    return null;\n}\nexport function _foldCall(node) {\n    let target = node.callTarget();\n    // Only constructor calls are considered constants\n    if (target.kind !== NodeKind.TYPE) {\n        return null;\n    }\n    let type = target.resolvedType;\n    let componentType = type.componentType();\n    let matrixStride = 0;\n    let _arguments = [];\n    let count = 0;\n    // Make sure all arguments are constants\n    for (let child = target.nextSibling(); child !== null; child = child.nextSibling()) {\n        let folded = fold(child);\n        if (folded === null) {\n            return null;\n        }\n        // Expand values inline from constructed native types\n        if (folded.kind === NodeKind.CALL && componentType !== null && folded.callTarget().resolvedType.componentType() !== null) {\n            for (let value = folded.callTarget().nextSibling(); value !== null; value = value.nextSibling()) {\n                let casted = _castValue(componentType, value);\n                if (casted === null) {\n                    return null;\n                }\n                _arguments.push(casted);\n            }\n        }\n        // Auto-cast values for primitive types\n        else {\n            if (componentType !== null) {\n                folded = _castValue(componentType, folded);\n                if (folded === null) {\n                    return null;\n                }\n            }\n            _arguments.push(folded);\n        }\n        if (folded.resolvedType.isMatrix()) {\n            matrixStride = folded.resolvedType.indexCount();\n        }\n        count = count + 1;\n    }\n    // If a matrix argument is given to a matrix constructor, it is an error\n    // to have any other arguments\n    if (type.isMatrix() && matrixStride !== 0 && count !== 1) {\n        return null;\n    }\n    // Native component-based types\n    if (type.componentType() !== null) {\n        return _foldComponentConstructor(_arguments, type, type.isMatrix() ? matrixStride : 0);\n    }\n    // User-defined struct types\n    if (type.symbol !== null && type.symbol.isStruct()) {\n        return _foldStruct(_arguments, type);\n    }\n    return null;\n}\nexport function _floatValues(node) {\n    let values = [];\n    for (let child = node.callTarget().nextSibling(); child !== null; child = child.nextSibling()) {\n        values.push(child.asFloat());\n    }\n    return values;\n}\nexport function _foldMultiply(node) {\n    let ref;\n    let left = fold(node.binaryLeft());\n    let right = fold(node.binaryRight());\n    let leftType = left !== null ? left.resolvedType : null;\n    let rightType = right !== null ? right.resolvedType : null;\n    if (left !== null && right !== null) {\n        // Vector-matrix multiply\n        if (leftType === Type.VEC2 && rightType === Type.MAT2 || leftType === Type.VEC3 && rightType === Type.MAT3 || leftType === Type.VEC4 && rightType === Type.MAT4) {\n            let stride = leftType.indexCount();\n            let result = Node.createConstructorCall(leftType);\n            let leftValues = _floatValues(left);\n            let rightValues = _floatValues(right);\n            for (let i = 0, count1 = stride; i < count1; i = i + 1) {\n                let total = 0;\n                for (let col = 0, count = stride; col < count; col = col + 1) {\n                    total += List_get2(leftValues, col) * List_get2(rightValues, col + i * stride);\n                }\n                result.appendChild(Node.createFloat(total));\n            }\n            return result;\n        }\n        // Matrix-vector multiply\n        if (leftType === Type.MAT2 && rightType === Type.VEC2 || leftType === Type.MAT3 && rightType === Type.VEC3 || leftType === Type.MAT4 && rightType === Type.VEC4) {\n            let stride1 = leftType.indexCount();\n            let result1 = Node.createConstructorCall(rightType);\n            let leftValues1 = _floatValues(left);\n            let rightValues1 = _floatValues(right);\n            for (let i1 = 0, count3 = stride1; i1 < count3; i1 = i1 + 1) {\n                let total1 = 0;\n                for (let row = 0, count2 = stride1; row < count2; row = row + 1) {\n                    total1 += List_get2(leftValues1, i1 + row * stride1) * List_get2(rightValues1, row);\n                }\n                result1.appendChild(Node.createFloat(total1));\n            }\n            return result1;\n        }\n        // Matrix-matrix multiply\n        if (leftType.isMatrix() && rightType === leftType) {\n            let stride2 = leftType.indexCount();\n            let result2 = Node.createConstructorCall(leftType);\n            let leftValues2 = _floatValues(left);\n            let rightValues2 = _floatValues(right);\n            for (let row1 = 0, count6 = stride2; row1 < count6; row1 = row1 + 1) {\n                for (let col1 = 0, count5 = stride2; col1 < count5; col1 = col1 + 1) {\n                    let total2 = 0;\n                    for (let i2 = 0, count4 = stride2; i2 < count4; i2 = i2 + 1) {\n                        total2 += List_get2(leftValues2, col1 + i2 * stride2) * List_get2(rightValues2, i2 + row1 * stride2);\n                    }\n                    result2.appendChild(Node.createFloat(total2));\n                }\n            }\n            return result2;\n        }\n        return (ref = _foldFloat2(left, right, (a, b) => {\n            return a * b;\n        })) !== null ? ref : _foldInt2(left, right, (a, b) => {\n            return a * b;\n        });\n    }\n    return null;\n}\nexport function _castValue(type, node) {\n    let value = 0;\n    switch (node.kind) {\n        case NodeKind.BOOL: {\n            value = node.asBool() ? 1 : 0;\n            break;\n        }\n        case NodeKind.INT: {\n            value = node.asInt();\n            break;\n        }\n        case NodeKind.FLOAT: {\n            value = node.asFloat();\n            break;\n        }\n        default: {\n            return null;\n        }\n    }\n    let value1 = type;\n    if (value1 === Type.BOOL) {\n        return Node.createBool(!!value);\n    }\n    else if (value1 === Type.INT) {\n        return Node.createInt(value | 0);\n    }\n    else if (value1 === Type.FLOAT) {\n        return Node.createFloat(value);\n    }\n    return null;\n}\nexport function _foldComponentConstructor(_arguments, type, matrixStride) {\n    let componentCount = type.componentCount();\n    let componentType = type.componentType();\n    let node = Node.createConstructorCall(type);\n    assert(componentCount > 0);\n    // Passing a single component as an argument always works\n    if (_arguments.length === 1) {\n        let argument = List_first(_arguments);\n        if (argument.resolvedType !== componentType) {\n            return null;\n        }\n        // When doing this with a matrix, only the diagonal is filled\n        let isMatrix = type.isMatrix();\n        let stride = type.indexCount();\n        // Fill the target by repeating the single component\n        for (let i = 0, count = componentCount; i < count; i = i + 1) {\n            let isOffMatrixDiagonal = isMatrix && i % (stride + 1) !== 0;\n            node.appendChild(isOffMatrixDiagonal ? Node.createFloat(0) : argument.clone());\n        }\n    }\n    // If a matrix is constructed from a matrix, then each component (column i,\n    // row j) in the result that has a corresponding component (column i, row j)\n    // in the argument will be initialized from there. All other components will\n    // be initialized to the identity matrix.\n    else if (matrixStride !== 0) {\n        let stride1 = type.indexCount();\n        assert(type.isMatrix());\n        assert(stride1 * stride1 === componentCount);\n        for (let row = 0, count2 = stride1; row < count2; row = row + 1) {\n            for (let col = 0, count1 = stride1; col < count1; col = col + 1) {\n                node.appendChild(col < matrixStride && row < matrixStride ? List_get2(_arguments, col + row * matrixStride) : Node.createFloat(col === row ? 1 : 0));\n            }\n        }\n    }\n    // Multiple arguments are more involved\n    else {\n        // Extra arguments are ignored\n        if (_arguments.length < componentCount) {\n            return null;\n        }\n        // The constructed value is represented as a constructor call\n        for (let i1 = 0, count3 = componentCount; i1 < count3; i1 = i1 + 1) {\n            let argument1 = List_get2(_arguments, i1);\n            // All casts should be resolved by this point\n            if (argument1.resolvedType !== componentType) {\n                return null;\n            }\n            node.appendChild(argument1);\n        }\n    }\n    // Don't wrap primitive types\n    if (type.indexType() === null) {\n        return node.lastChild().remove();\n    }\n    return node;\n}\nexport function _foldStruct(_arguments, type) {\n    let variables = type.symbol.asStruct().variables;\n    let node = Node.createConstructorCall(type);\n    // Structs can only be constructed with the exact number of arguments\n    if (_arguments.length !== variables.length) {\n        return null;\n    }\n    // The constructed value is represented as a constructor call\n    for (let i = 0, count = _arguments.length; i < count; i = i + 1) {\n        if (List_get2(_arguments, i).resolvedType !== List_get2(variables, i).type.resolvedType) {\n            return null;\n        }\n        node.appendChild(List_get2(_arguments, i));\n    }\n    return node;\n}\nexport function _foldBinaryEquality(node) {\n    let left = fold(node.binaryLeft());\n    let right = fold(node.binaryRight());\n    if (left !== null && right !== null) {\n        let value = left.looksTheSameAs(right);\n        return Node.createBool(node.kind === NodeKind.EQUAL ? value : !value);\n    }\n    return null;\n}\n/////////////////////////////////////////////////////////////////////////////////\nexport function _foldComponentwiseUnary(node, componentType, argumentKind, op) {\n    if (node.kind === NodeKind.CALL && node.callTarget().kind === NodeKind.TYPE && node.callTarget().resolvedType.componentType() === componentType) {\n        let result = Node.createConstructorCall(node.callTarget().resolvedType);\n        for (let child = node.callTarget().nextSibling(); child !== null; child = child.nextSibling()) {\n            let folded = fold(child);\n            if (folded === null || folded.kind !== argumentKind) {\n                return null;\n            }\n            result.appendChild(op(folded));\n        }\n        return result;\n    }\n    return null;\n}\nexport function _foldFloat1(node, op) {\n    if (node.kind === NodeKind.FLOAT) {\n        return Node.createFloat(op(node.asFloat()));\n    }\n    return _foldComponentwiseUnary(node, Type.FLOAT, NodeKind.FLOAT, (x) => {\n        return Node.createFloat(op(x.asFloat()));\n    });\n}\nexport function _foldInt1(node, op) {\n    if (node.kind === NodeKind.INT) {\n        return Node.createInt(op(node.asInt()));\n    }\n    return _foldComponentwiseUnary(node, Type.INT, NodeKind.INT, (x) => {\n        return Node.createInt(op(x.asInt()));\n    });\n}\n/////////////////////////////////////////////////////////////////////////////////\nexport function _foldComponentwiseBinary(left, right, componentType, argumentKind, op) {\n    let leftHasComponents = left.kind === NodeKind.CALL && left.callTarget().kind === NodeKind.TYPE && left.callTarget().resolvedType.componentType() === componentType;\n    let rightHasComponents = right.kind === NodeKind.CALL && right.callTarget().kind === NodeKind.TYPE && right.callTarget().resolvedType.componentType() === componentType;\n    // Vector-vector binary operator\n    if (leftHasComponents && rightHasComponents && right.resolvedType === left.resolvedType) {\n        let result = Node.createConstructorCall(left.resolvedType);\n        let leftChild = left.callTarget().nextSibling();\n        let rightChild = right.callTarget().nextSibling();\n        while (leftChild !== null && rightChild !== null) {\n            let foldedLeft = fold(leftChild);\n            let foldedRight = fold(rightChild);\n            if (foldedLeft === null || foldedLeft.kind !== argumentKind || foldedRight === null || foldedRight.kind !== argumentKind) {\n                return null;\n            }\n            result.appendChild(op(foldedLeft, foldedRight));\n            leftChild = leftChild.nextSibling();\n            rightChild = rightChild.nextSibling();\n        }\n        if (leftChild === null && rightChild === null) {\n            return result;\n        }\n    }\n    // Vector-scalar binary operator\n    else if (leftHasComponents && right.kind === argumentKind) {\n        let result1 = Node.createConstructorCall(left.resolvedType);\n        for (let child = left.callTarget().nextSibling(); child !== null; child = child.nextSibling()) {\n            let folded = fold(child);\n            if (folded === null || folded.kind !== argumentKind) {\n                return null;\n            }\n            result1.appendChild(op(folded, right));\n        }\n        return result1;\n    }\n    // Scalar-vector binary operator\n    else if (left.kind === argumentKind && rightHasComponents) {\n        let result2 = Node.createConstructorCall(right.resolvedType);\n        for (let child1 = right.callTarget().nextSibling(); child1 !== null; child1 = child1.nextSibling()) {\n            let folded1 = fold(child1);\n            if (folded1 === null || folded1.kind !== argumentKind) {\n                return null;\n            }\n            result2.appendChild(op(left, folded1));\n        }\n        return result2;\n    }\n    return null;\n}\nexport function _foldFloat2(left, right, op) {\n    if (left.kind === NodeKind.FLOAT && right.kind === NodeKind.FLOAT) {\n        return Node.createFloat(op(left.asFloat(), right.asFloat()));\n    }\n    return _foldComponentwiseBinary(left, right, Type.FLOAT, NodeKind.FLOAT, (a, b) => {\n        return Node.createFloat(op(a.asFloat(), b.asFloat()));\n    });\n}\nexport function _foldInt2(left, right, op) {\n    if (left.kind === NodeKind.INT && right.kind === NodeKind.INT) {\n        return Node.createInt(op(left.asInt(), right.asInt()));\n    }\n    return _foldComponentwiseBinary(left, right, Type.INT, NodeKind.INT, (a, b) => {\n        return Node.createInt(op(a.asInt(), b.asInt()));\n    });\n}\n/////////////////////////////////////////////////////////////////////////////////\nexport function _foldUnaryBool(node, op) {\n    let value = fold(node.unaryValue());\n    if (value !== null && value.kind === NodeKind.BOOL) {\n        return Node.createBool(op(value.asBool()));\n    }\n    return null;\n}\nexport function _foldUnaryFloatOrInt(node, floatOp, intOp) {\n    let ref;\n    let value = fold(node.unaryValue());\n    if (value !== null) {\n        return (ref = _foldFloat1(value, floatOp)) !== null ? ref : _foldInt1(value, intOp);\n    }\n    return null;\n}\n/////////////////////////////////////////////////////////////////////////////////\nexport function _foldBinaryBool(node, op) {\n    let left = fold(node.binaryLeft());\n    let right = fold(node.binaryRight());\n    if (left !== null && right !== null && left.kind === NodeKind.BOOL && right.kind === NodeKind.BOOL) {\n        return Node.createBool(op(left.asBool(), right.asBool()));\n    }\n    return null;\n}\nexport function _foldBinaryFloatOrInt(node, floatOp, intOp) {\n    let ref;\n    let left = fold(node.binaryLeft());\n    let right = fold(node.binaryRight());\n    if (left !== null && right !== null) {\n        return (ref = _foldFloat2(left, right, floatOp)) !== null ? ref : _foldInt2(left, right, intOp);\n    }\n    return null;\n}\nexport function _foldBinaryFloatOrIntToBool(node, op) {\n    let left = fold(node.binaryLeft());\n    let right = fold(node.binaryRight());\n    // The comparison operators only work on scalars in GLSL. To do comparisons\n    // on vectors, the functions greaterThan(), lessThan(), greaterThanEqual(),\n    // and lessThanEqual() must be used.\n    if (left !== null && right !== null) {\n        if (left.kind === NodeKind.FLOAT && right.kind === NodeKind.FLOAT) {\n            return Node.createBool(op(left.asFloat(), right.asFloat()));\n        }\n        if (left.kind === NodeKind.INT && right.kind === NodeKind.INT) {\n            return Node.createBool(op(left.asInt(), right.asInt()));\n        }\n    }\n    return null;\n}\n","import { assert, string_slice2 } from \"../../native-js\";\nexport class Range {\n    constructor(source, start, end) {\n        this.source = source;\n        this.start = start;\n        this.end = end;\n    }\n    toString() {\n        return string_slice2(this.source.contents, this.start, this.end);\n    }\n    overlaps(range) {\n        return this.source === range.source && this.start < range.end && range.start < this.end;\n    }\n    touches(index) {\n        return this.start <= index && index <= this.end;\n    }\n    slice(offsetStart, offsetEnd) {\n        assert(offsetStart >= 0 && offsetStart <= offsetEnd && offsetEnd <= this.end - this.start);\n        return new Range(this.source, this.start + offsetStart, this.start + offsetEnd);\n    }\n    lineColumn() {\n        return this.source.indexToLineColumn(this.start);\n    }\n    rangeAtEnd() {\n        return new Range(this.source, this.end, this.end);\n    }\n    static span(start, end) {\n        assert(start.source === end.source);\n        assert(start.start <= end.end);\n        return new Range(start.source, start.start, end.end);\n    }\n}\n","import { List_get2, StringMap_get3, StringMap_insert, StringMap_set2, string_get12 } from \"../../native-js\";\nimport { Range } from \"./range\";\nimport { DefineStatement } from \"./symbol\";\nexport var TokenKind;\n(function (TokenKind) {\n    TokenKind[TokenKind[\"SINGLE_LINE_COMMENT\"] = 0] = \"SINGLE_LINE_COMMENT\";\n    TokenKind[TokenKind[\"MULTI_LINE_COMMENT\"] = 1] = \"MULTI_LINE_COMMENT\";\n    // Standard keywords\n    TokenKind[TokenKind[\"ATTRIBUTE\"] = 2] = \"ATTRIBUTE\";\n    TokenKind[TokenKind[\"BOOL\"] = 3] = \"BOOL\";\n    TokenKind[TokenKind[\"BREAK\"] = 4] = \"BREAK\";\n    TokenKind[TokenKind[\"BVEC2\"] = 5] = \"BVEC2\";\n    TokenKind[TokenKind[\"BVEC3\"] = 6] = \"BVEC3\";\n    TokenKind[TokenKind[\"BVEC4\"] = 7] = \"BVEC4\";\n    TokenKind[TokenKind[\"CONST\"] = 8] = \"CONST\";\n    TokenKind[TokenKind[\"CONTINUE\"] = 9] = \"CONTINUE\";\n    TokenKind[TokenKind[\"DISCARD\"] = 10] = \"DISCARD\";\n    TokenKind[TokenKind[\"DO\"] = 11] = \"DO\";\n    TokenKind[TokenKind[\"ELSE\"] = 12] = \"ELSE\";\n    TokenKind[TokenKind[\"FALSE\"] = 13] = \"FALSE\";\n    TokenKind[TokenKind[\"FLOAT\"] = 14] = \"FLOAT\";\n    TokenKind[TokenKind[\"FOR\"] = 15] = \"FOR\";\n    TokenKind[TokenKind[\"HIGHP\"] = 16] = \"HIGHP\";\n    TokenKind[TokenKind[\"IF\"] = 17] = \"IF\";\n    TokenKind[TokenKind[\"IN\"] = 18] = \"IN\";\n    TokenKind[TokenKind[\"INOUT\"] = 19] = \"INOUT\";\n    TokenKind[TokenKind[\"INT\"] = 20] = \"INT\";\n    TokenKind[TokenKind[\"UINT\"] = 21] = \"UINT\";\n    TokenKind[TokenKind[\"INVARIANT\"] = 22] = \"INVARIANT\";\n    TokenKind[TokenKind[\"IVEC2\"] = 23] = \"IVEC2\";\n    TokenKind[TokenKind[\"IVEC3\"] = 24] = \"IVEC3\";\n    TokenKind[TokenKind[\"IVEC4\"] = 25] = \"IVEC4\";\n    TokenKind[TokenKind[\"LOWP\"] = 26] = \"LOWP\";\n    TokenKind[TokenKind[\"MAT2\"] = 27] = \"MAT2\";\n    TokenKind[TokenKind[\"MAT3\"] = 28] = \"MAT3\";\n    TokenKind[TokenKind[\"MAT4\"] = 29] = \"MAT4\";\n    TokenKind[TokenKind[\"MEDIUMP\"] = 30] = \"MEDIUMP\";\n    TokenKind[TokenKind[\"OUT\"] = 31] = \"OUT\";\n    TokenKind[TokenKind[\"PRECISION\"] = 32] = \"PRECISION\";\n    TokenKind[TokenKind[\"RETURN\"] = 33] = \"RETURN\";\n    TokenKind[TokenKind[\"SAMPLER2D\"] = 34] = \"SAMPLER2D\";\n    TokenKind[TokenKind[\"SAMPLER3D\"] = 35] = \"SAMPLER3D\";\n    TokenKind[TokenKind[\"SAMPLERCUBE\"] = 36] = \"SAMPLERCUBE\";\n    TokenKind[TokenKind[\"ISAMPLERCUBE\"] = 37] = \"ISAMPLERCUBE\";\n    TokenKind[TokenKind[\"USAMPLERCUBE\"] = 38] = \"USAMPLERCUBE\";\n    TokenKind[TokenKind[\"SAMPLER2DARRAY\"] = 39] = \"SAMPLER2DARRAY\";\n    TokenKind[TokenKind[\"ISAMPLER2DARRAY\"] = 40] = \"ISAMPLER2DARRAY\";\n    TokenKind[TokenKind[\"USAMPLER2DARRAY\"] = 41] = \"USAMPLER2DARRAY\";\n    TokenKind[TokenKind[\"SAMPLER2DSHADOW\"] = 42] = \"SAMPLER2DSHADOW\";\n    TokenKind[TokenKind[\"SAMPLERCUBESHADOW\"] = 43] = \"SAMPLERCUBESHADOW\";\n    TokenKind[TokenKind[\"SAMPLER2DARRAYSHADOW\"] = 44] = \"SAMPLER2DARRAYSHADOW\";\n    TokenKind[TokenKind[\"USAMPLER2DARRAYSHADOW\"] = 45] = \"USAMPLER2DARRAYSHADOW\";\n    TokenKind[TokenKind[\"ISAMPLER2DARRAYSHADOW\"] = 46] = \"ISAMPLER2DARRAYSHADOW\";\n    TokenKind[TokenKind[\"ISAMPLER2D\"] = 47] = \"ISAMPLER2D\";\n    TokenKind[TokenKind[\"USAMPLER2D\"] = 48] = \"USAMPLER2D\";\n    TokenKind[TokenKind[\"ISAMPLER3D\"] = 49] = \"ISAMPLER3D\";\n    TokenKind[TokenKind[\"USAMPLER3D\"] = 50] = \"USAMPLER3D\";\n    TokenKind[TokenKind[\"STRUCT\"] = 51] = \"STRUCT\";\n    TokenKind[TokenKind[\"TRUE\"] = 52] = \"TRUE\";\n    TokenKind[TokenKind[\"UNIFORM\"] = 53] = \"UNIFORM\";\n    TokenKind[TokenKind[\"VARYING\"] = 54] = \"VARYING\";\n    TokenKind[TokenKind[\"VEC2\"] = 55] = \"VEC2\";\n    TokenKind[TokenKind[\"VEC3\"] = 56] = \"VEC3\";\n    TokenKind[TokenKind[\"VEC4\"] = 57] = \"VEC4\";\n    TokenKind[TokenKind[\"UVEC2\"] = 58] = \"UVEC2\";\n    TokenKind[TokenKind[\"UVEC3\"] = 59] = \"UVEC3\";\n    TokenKind[TokenKind[\"UVEC4\"] = 60] = \"UVEC4\";\n    TokenKind[TokenKind[\"VOID\"] = 61] = \"VOID\";\n    TokenKind[TokenKind[\"WHILE\"] = 62] = \"WHILE\";\n    // Non-standard keywords\n    TokenKind[TokenKind[\"EXPORT\"] = 63] = \"EXPORT\";\n    TokenKind[TokenKind[\"IMPORT\"] = 64] = \"IMPORT\";\n    // Unary\n    TokenKind[TokenKind[\"COMPLEMENT\"] = 65] = \"COMPLEMENT\";\n    TokenKind[TokenKind[\"DECREMENT\"] = 66] = \"DECREMENT\";\n    TokenKind[TokenKind[\"INCREMENT\"] = 67] = \"INCREMENT\";\n    TokenKind[TokenKind[\"NOT\"] = 68] = \"NOT\";\n    // Binary\n    TokenKind[TokenKind[\"BITWISE_AND\"] = 69] = \"BITWISE_AND\";\n    TokenKind[TokenKind[\"BITWISE_OR\"] = 70] = \"BITWISE_OR\";\n    TokenKind[TokenKind[\"BITWISE_XOR\"] = 71] = \"BITWISE_XOR\";\n    TokenKind[TokenKind[\"DIVIDE\"] = 72] = \"DIVIDE\";\n    TokenKind[TokenKind[\"EQUAL\"] = 73] = \"EQUAL\";\n    TokenKind[TokenKind[\"GREATER_THAN\"] = 74] = \"GREATER_THAN\";\n    TokenKind[TokenKind[\"GREATER_THAN_OR_EQUAL\"] = 75] = \"GREATER_THAN_OR_EQUAL\";\n    TokenKind[TokenKind[\"LESS_THAN\"] = 76] = \"LESS_THAN\";\n    TokenKind[TokenKind[\"LESS_THAN_OR_EQUAL\"] = 77] = \"LESS_THAN_OR_EQUAL\";\n    TokenKind[TokenKind[\"LOGICAL_AND\"] = 78] = \"LOGICAL_AND\";\n    TokenKind[TokenKind[\"LOGICAL_OR\"] = 79] = \"LOGICAL_OR\";\n    TokenKind[TokenKind[\"LOGICAL_XOR\"] = 80] = \"LOGICAL_XOR\";\n    TokenKind[TokenKind[\"MINUS\"] = 81] = \"MINUS\";\n    TokenKind[TokenKind[\"MULTIPLY\"] = 82] = \"MULTIPLY\";\n    TokenKind[TokenKind[\"NOT_EQUAL\"] = 83] = \"NOT_EQUAL\";\n    TokenKind[TokenKind[\"PLUS\"] = 84] = \"PLUS\";\n    TokenKind[TokenKind[\"REMAINDER\"] = 85] = \"REMAINDER\";\n    TokenKind[TokenKind[\"SHIFT_LEFT\"] = 86] = \"SHIFT_LEFT\";\n    TokenKind[TokenKind[\"SHIFT_RIGHT\"] = 87] = \"SHIFT_RIGHT\";\n    // Binary assignment\n    TokenKind[TokenKind[\"ASSIGN\"] = 88] = \"ASSIGN\";\n    TokenKind[TokenKind[\"ASSIGN_ADD\"] = 89] = \"ASSIGN_ADD\";\n    TokenKind[TokenKind[\"ASSIGN_BITWISE_AND\"] = 90] = \"ASSIGN_BITWISE_AND\";\n    TokenKind[TokenKind[\"ASSIGN_BITWISE_OR\"] = 91] = \"ASSIGN_BITWISE_OR\";\n    TokenKind[TokenKind[\"ASSIGN_BITWISE_XOR\"] = 92] = \"ASSIGN_BITWISE_XOR\";\n    TokenKind[TokenKind[\"ASSIGN_DIVIDE\"] = 93] = \"ASSIGN_DIVIDE\";\n    TokenKind[TokenKind[\"ASSIGN_MULTIPLY\"] = 94] = \"ASSIGN_MULTIPLY\";\n    TokenKind[TokenKind[\"ASSIGN_REMAINDER\"] = 95] = \"ASSIGN_REMAINDER\";\n    TokenKind[TokenKind[\"ASSIGN_SHIFT_LEFT\"] = 96] = \"ASSIGN_SHIFT_LEFT\";\n    TokenKind[TokenKind[\"ASSIGN_SHIFT_RIGHT\"] = 97] = \"ASSIGN_SHIFT_RIGHT\";\n    TokenKind[TokenKind[\"ASSIGN_SUBTRACT\"] = 98] = \"ASSIGN_SUBTRACT\";\n    // Other operators\n    TokenKind[TokenKind[\"COLON\"] = 99] = \"COLON\";\n    TokenKind[TokenKind[\"COMMA\"] = 100] = \"COMMA\";\n    TokenKind[TokenKind[\"DOT\"] = 101] = \"DOT\";\n    TokenKind[TokenKind[\"LEFT_BRACE\"] = 102] = \"LEFT_BRACE\";\n    TokenKind[TokenKind[\"LEFT_BRACKET\"] = 103] = \"LEFT_BRACKET\";\n    TokenKind[TokenKind[\"LEFT_PARENTHESIS\"] = 104] = \"LEFT_PARENTHESIS\";\n    TokenKind[TokenKind[\"QUESTION\"] = 105] = \"QUESTION\";\n    TokenKind[TokenKind[\"RIGHT_BRACE\"] = 106] = \"RIGHT_BRACE\";\n    TokenKind[TokenKind[\"RIGHT_BRACKET\"] = 107] = \"RIGHT_BRACKET\";\n    TokenKind[TokenKind[\"RIGHT_PARENTHESIS\"] = 108] = \"RIGHT_PARENTHESIS\";\n    TokenKind[TokenKind[\"SEMICOLON\"] = 109] = \"SEMICOLON\";\n    // Pragmas\n    TokenKind[TokenKind[\"EXTENSION\"] = 110] = \"EXTENSION\";\n    TokenKind[TokenKind[\"VERSION\"] = 111] = \"VERSION\";\n    TokenKind[TokenKind[\"INCLUDE\"] = 112] = \"INCLUDE\";\n    TokenKind[TokenKind[\"DEFINE\"] = 113] = \"DEFINE\";\n    TokenKind[TokenKind[\"PRAGMA\"] = 114] = \"PRAGMA\";\n    // Literals\n    TokenKind[TokenKind[\"FLOAT_LITERAL\"] = 115] = \"FLOAT_LITERAL\";\n    TokenKind[TokenKind[\"IDENTIFIER\"] = 116] = \"IDENTIFIER\";\n    TokenKind[TokenKind[\"INT_LITERAL\"] = 117] = \"INT_LITERAL\";\n    TokenKind[TokenKind[\"STRING_LITERAL\"] = 118] = \"STRING_LITERAL\";\n    // This is always at the end of the token stream\n    TokenKind[TokenKind[\"END_OF_FILE\"] = 119] = \"END_OF_FILE\";\n})(TokenKind || (TokenKind = {}));\nexport class Token {\n    constructor(range, kind, comments) {\n        this.range = range;\n        this.kind = kind;\n        this.comments = comments;\n    }\n}\nexport function collectDefines(log, source) {\n    // This is super fragile and doesn't cover multiline defines\n    let result = null;\n    while ((result = _defineRegex.exec(source.contents)) !== null) {\n        let statement = new DefineStatement(result[1], result[2]);\n        StringMap_set2(log.defines, statement.name, statement);\n    }\n}\nexport function replaceDefines(log, source) {\n    for (const defineStatement of Array.from(log.defines.values())) {\n        // TODO: Better than dynamic replace?\n        source.contents = source.contents.replace(new RegExp('(?<!#define\\\\s+)\\\\b' + defineStatement.name + '\\\\b', 'g'), defineStatement.value);\n    }\n}\nexport function tokenize(log, source, purpose) {\n    let parts = source.contents.split(_tokenRegex);\n    let tokens = [];\n    let comments = null;\n    let prevCommentTokenCount = 0;\n    let start = 0;\n    for (let i = 0, count1 = parts.length; i < count1; i = i + 1) {\n        let part = List_get2(parts, i);\n        let count = part.length;\n        let end = start + count;\n        let range = new Range(source, start, end);\n        if (i % 2 !== 0) {\n            let c = string_get12(part, 0);\n            // Identifier\n            if (c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 95) {\n                let keyword = StringMap_get3(keywords, part, TokenKind.END_OF_FILE);\n                if (keyword !== TokenKind.END_OF_FILE) {\n                    tokens.push(new Token(range, keyword, comments));\n                }\n                else if (reservedWords.has(part)) {\n                    log.syntaxErrorReservedWord(range);\n                }\n                else {\n                    tokens.push(new Token(range, TokenKind.IDENTIFIER, comments));\n                }\n            }\n            // Number\n            else if (c >= 48 && c <= 57 || c === 46 && count > 1) {\n                tokens.push(new Token(range, _intRegex.test(part) ? TokenKind.INT_LITERAL : TokenKind.FLOAT_LITERAL, comments));\n            }\n            // Pragma\n            else if (c === 35) {\n                let kind = TokenKind.PRAGMA;\n                let value = part;\n                if (value === '#version') {\n                    kind = TokenKind.VERSION;\n                }\n                else if (value === '#extension') {\n                    kind = TokenKind.EXTENSION;\n                }\n                else if (value === '#include') {\n                    kind = TokenKind.INCLUDE;\n                }\n                else if (value === '#define') {\n                    kind = TokenKind.DEFINE;\n                }\n                tokens.push(new Token(range, kind, comments));\n            }\n            // String literal\n            else if (c === 34) {\n                tokens.push(new Token(range, TokenKind.STRING_LITERAL, comments));\n            }\n            // Operator\n            else {\n                let kind1 = StringMap_get3(operators, part, TokenKind.END_OF_FILE);\n                if (kind1 === TokenKind.END_OF_FILE) {\n                    if (part.startsWith('//')) {\n                        if (purpose === 1 /* FORMAT */) {\n                            kind1 = TokenKind.SINGLE_LINE_COMMENT;\n                        }\n                        else {\n                            (comments !== null ? comments : comments = []).push(range);\n                        }\n                    }\n                    else if (part.startsWith('/*')) {\n                        if (purpose === 1 /* FORMAT */) {\n                            kind1 = TokenKind.MULTI_LINE_COMMENT;\n                        }\n                        else {\n                            (comments !== null ? comments : comments = []).push(range);\n                        }\n                    }\n                }\n                if (kind1 !== TokenKind.END_OF_FILE) {\n                    tokens.push(new Token(range, kind1, comments));\n                }\n            }\n        }\n        else if (part !== '') {\n            log.syntaxErrorExtraData(range, part);\n            break;\n        }\n        // Reset the comment list after every non-comment token\n        if (tokens.length !== prevCommentTokenCount) {\n            comments = null;\n            prevCommentTokenCount = tokens.length;\n        }\n        start = end;\n    }\n    tokens.push(new Token(new Range(source, start, start), TokenKind.END_OF_FILE, comments));\n    return tokens;\n}\nexport let _defineRegex = new RegExp('#define\\\\s+(\\\\w+\\\\b)\\\\s?(.+)?', 'g');\n// The order matters here due to greedy matching\nexport let _tokenRegex = new RegExp('(' +\n    // Float literal\n    '\\\\.[0-9]+[eE][+-]?[0-9]+\\\\b|' + // Floating-point constant\n    '\\\\.[0-9]+\\\\b|' + // Floating-point constant\n    '[0-9]+\\\\.[0-9]+[eE][+-]?[0-9]+\\\\b|' + // Floating-point constant\n    '[0-9]+\\\\.[0-9]+\\\\b|' + // Floating-point constant\n    '[0-9]+\\\\.[eE][+-]?[0-9]+\\\\b|' + // Floating-point constant\n    '[0-9]+\\\\.|' + // Floating-point constant\n    '[0-9]+[eE][+-]?[0-9]+\\\\b|' + // Floating-point constant\n    // Int literals\n    '[1-9][0-9]*\\\\b|' + // Decimal int literal\n    '0[0-7]*\\\\b|' + // Octal int literal\n    '0[xX][0-9A-Fa-f]+\\\\b|' + // Hexadecimal int literal\n    // Other\n    '[ \\t\\r\\n]|' + // Whitespace\n    '/\\\\*(?:.|\\r\\n|\\n)*?\\\\*/|' + // Multi-line comment\n    '//.*|' + // Single-line comment\n    '&&|\\\\|\\\\||\\\\^\\\\^|\\\\+\\\\+|--|<<=?|>>=?|[()[\\\\]{}\\\\.,?:;]|[+\\\\-*/%=!<>&|^~]=?|' + // Operator\n    '[A-Za-z_][A-Za-z0-9_]*\\\\b|' + // Identifier\n    '#\\\\w+\\\\b|' + // Pragma\n    '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + // String literal\n    ')');\nexport let _intRegex = new RegExp('^(' + '[1-9][0-9]*|' + '0[0-7]*|' + '0[xX][0-9A-Fa-f]+' + ')$');\nexport let keywords = StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(new Map(), 'attribute', TokenKind.ATTRIBUTE), 'bool', TokenKind.BOOL), 'break', TokenKind.BREAK), 'bvec2', TokenKind.BVEC2), 'bvec3', TokenKind.BVEC3), 'bvec4', TokenKind.BVEC4), 'const', TokenKind.CONST), 'continue', TokenKind.CONTINUE), 'discard', TokenKind.DISCARD), 'do', TokenKind.DO), 'else', TokenKind.ELSE), 'false', TokenKind.FALSE), 'float', TokenKind.FLOAT), 'for', TokenKind.FOR), 'highp', TokenKind.HIGHP), 'if', TokenKind.IF), 'in', TokenKind.IN), 'inout', TokenKind.INOUT), 'int', TokenKind.INT), 'invariant', TokenKind.INVARIANT), 'ivec2', TokenKind.IVEC2), 'ivec3', TokenKind.IVEC3), 'ivec4', TokenKind.IVEC4), 'uint', TokenKind.UINT), 'uvec2', TokenKind.UVEC2), 'uvec3', TokenKind.UVEC3), 'uvec4', TokenKind.UVEC4), 'lowp', TokenKind.LOWP), 'mat2', TokenKind.MAT2), 'mat3', TokenKind.MAT3), 'mat4', TokenKind.MAT4), 'mediump', TokenKind.MEDIUMP), 'out', TokenKind.OUT), 'precision', TokenKind.PRECISION), 'return', TokenKind.RETURN), 'sampler2D', TokenKind.SAMPLER2D), 'sampler3D', TokenKind.SAMPLER3D), 'samplerCube', TokenKind.SAMPLERCUBE), 'isamplerCube', TokenKind.ISAMPLERCUBE), 'usamplerCube', TokenKind.USAMPLERCUBE), 'sampler2DArray', TokenKind.SAMPLER2DARRAY), 'isampler2DArray', TokenKind.ISAMPLER2DARRAY), 'usampler2DArray', TokenKind.USAMPLER2DARRAY), 'sampler2DShadow', TokenKind.SAMPLER2DSHADOW), 'samplerCubeShadow', TokenKind.SAMPLERCUBESHADOW), 'sampler2DArrayShadow', TokenKind.SAMPLER2DARRAYSHADOW), 'usampler2DArrayShadow', TokenKind.USAMPLER2DARRAYSHADOW), 'isampler2DArrayShadow', TokenKind.ISAMPLER2DARRAYSHADOW), 'isampler2D', TokenKind.ISAMPLER2D), 'usampler2D', TokenKind.USAMPLER2D), 'isampler3D', TokenKind.ISAMPLER3D), 'usampler3D', TokenKind.USAMPLER3D), 'struct', TokenKind.STRUCT), 'true', TokenKind.TRUE), 'uniform', TokenKind.UNIFORM), 'varying', TokenKind.VARYING), 'vec2', TokenKind.VEC2), 'vec3', TokenKind.VEC3), 'vec4', TokenKind.VEC4), 'void', TokenKind.VOID), 'while', TokenKind.WHILE), 'export', TokenKind.EXPORT), 'import', TokenKind.IMPORT);\nexport let operators = StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(new Map(), '~', TokenKind.COMPLEMENT), '--', TokenKind.DECREMENT), '++', TokenKind.INCREMENT), '!', TokenKind.NOT), '&', TokenKind.BITWISE_AND), '|', TokenKind.BITWISE_OR), '^', TokenKind.BITWISE_XOR), '/', TokenKind.DIVIDE), '==', TokenKind.EQUAL), '>', TokenKind.GREATER_THAN), '>=', TokenKind.GREATER_THAN_OR_EQUAL), '<', TokenKind.LESS_THAN), '<=', TokenKind.LESS_THAN_OR_EQUAL), '&&', TokenKind.LOGICAL_AND), '||', TokenKind.LOGICAL_OR), '^^', TokenKind.LOGICAL_XOR), '-', TokenKind.MINUS), '*', TokenKind.MULTIPLY), '!=', TokenKind.NOT_EQUAL), '+', TokenKind.PLUS), '%', TokenKind.REMAINDER), '<<', TokenKind.SHIFT_LEFT), '>>', TokenKind.SHIFT_RIGHT), '=', TokenKind.ASSIGN), '+=', TokenKind.ASSIGN_ADD), '&=', TokenKind.ASSIGN_BITWISE_AND), '|=', TokenKind.ASSIGN_BITWISE_OR), '^=', TokenKind.ASSIGN_BITWISE_XOR), '/=', TokenKind.ASSIGN_DIVIDE), '*=', TokenKind.ASSIGN_MULTIPLY), '%=', TokenKind.ASSIGN_REMAINDER), '<<=', TokenKind.ASSIGN_SHIFT_LEFT), '>>=', TokenKind.ASSIGN_SHIFT_RIGHT), '-=', TokenKind.ASSIGN_SUBTRACT), ':', TokenKind.COLON), ',', TokenKind.COMMA), '.', TokenKind.DOT), '{', TokenKind.LEFT_BRACE), '[', TokenKind.LEFT_BRACKET), '(', TokenKind.LEFT_PARENTHESIS), '?', TokenKind.QUESTION), '}', TokenKind.RIGHT_BRACE), ']', TokenKind.RIGHT_BRACKET), ')', TokenKind.RIGHT_PARENTHESIS), ';', TokenKind.SEMICOLON);\nexport let reservedWords = StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(new Map(), 'asm', 0), 'cast', 0), 'class', 0), 'default', 0), 'double', 0), 'dvec2', 0), 'dvec3', 0), 'dvec4', 0), 'enum', 0), 'extern', 0), 'external', 0), 'fixed', 0), 'flat', 0), 'fvec2', 0), 'fvec3', 0), 'fvec4', 0), 'goto', 0), 'half', 0), 'hvec2', 0), 'hvec3', 0), 'hvec4', 0), 'inline', 0), 'input', 0), 'interface', 0), 'long', 0), 'namespace', 0), 'noinline', 0), 'output', 0), 'packed', 0), 'public', 0), 'sampler1D', 0), 'sampler1DShadow', 0), 'sampler2DRect', 0), 'sampler2DRectShadow', 0), 'sampler3DRect', 0), 'short', 0), 'sizeof', 0), 'static', 0), 'superp', 0), 'switch', 0), 'template', 0), 'this', 0), 'typedef', 0), 'union', 0), 'unsigned', 0), 'using', 0), 'volatile', 0);\n","import { IntMap_get4, IntMap_set3, List_get2, assert } from \"../../native-js\";\nimport { Range } from \"./range\";\nimport { TokenKind } from \"./tokenizer\";\nexport class Include {\n    constructor(originalRange, includedRange) {\n        this.originalRange = originalRange;\n        this.includedRange = includedRange;\n    }\n}\nexport class ParserContext {\n    constructor(log, _tokens, compilationData, resolver, processedIncludes) {\n        this.log = log;\n        this._tokens = _tokens;\n        this.compilationData = compilationData;\n        this.resolver = resolver;\n        this.processedIncludes = processedIncludes;\n        this.includes = [];\n        this.flags = 0;\n        this._index = 0;\n        this._scope = null;\n    }\n    current() {\n        return List_get2(this._tokens, this._index);\n    }\n    next() {\n        let token = this.current();\n        if (this._index + 1 < this._tokens.length) {\n            this._index = this._index + 1;\n        }\n        return token;\n    }\n    spanSince(range) {\n        let previous = List_get2(this._tokens, this._index > 0 ? this._index - 1 : 0);\n        return previous.range.end < range.start ? range : Range.span(range, previous.range);\n    }\n    peek(kind) {\n        return this.current().kind === kind;\n    }\n    eat(kind) {\n        if (this.peek(kind)) {\n            this.next();\n            return true;\n        }\n        return false;\n    }\n    expect(kind) {\n        if (this.eat(kind)) {\n            return true;\n        }\n        let token = this.current();\n        let range = token.range;\n        let previous = (this._index > 0 ? List_get2(this._tokens, this._index - 1) : token).range;\n        // Put errors about missing semicolons and about tokens on the next line\n        // after the previous token instead of at the next token\n        if (kind === TokenKind.SEMICOLON || previous.lineColumn().line !== range.lineColumn().line) {\n            this.log.syntaxErrorExpectedToken1(previous.rangeAtEnd(), kind);\n        }\n        else {\n            this.log.syntaxErrorExpectedToken2(range, token.kind, kind);\n        }\n        return false;\n    }\n    unexpectedToken() {\n        this.log.syntaxErrorUnexpectedToken(this.current());\n    }\n    scope() {\n        return this._scope;\n    }\n    pushScope(newScope) {\n        assert(newScope.parent === this._scope);\n        this._scope = newScope;\n    }\n    popScope() {\n        assert(this._scope !== null);\n        this._scope = this._scope.parent;\n    }\n}\nexport class Parselet {\n    constructor(precedence) {\n        this.precedence = precedence;\n        this.prefix = null;\n        this.infix = null;\n    }\n}\n// A Pratt parser is a parser that associates up to two operations per token,\n// each with its own precedence. Pratt parsers excel at parsing expression\n// trees with deeply nested precedence levels. For an excellent writeup, see:\n//\n//   http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\n//\nexport class Pratt {\n    constructor() {\n        this._table = new Map();\n    }\n    parselet(kind, precedence) {\n        let parselet = IntMap_get4(this._table, kind, null);\n        if (parselet === null) {\n            let created = new Parselet(precedence);\n            parselet = created;\n            IntMap_set3(this._table, kind, created);\n        }\n        else if (precedence > parselet.precedence) {\n            parselet.precedence = precedence;\n        }\n        return parselet;\n    }\n    parse(context, precedence) {\n        let token = context.current();\n        let parselet = IntMap_get4(this._table, token.kind, null);\n        if (parselet === null || parselet.prefix === null) {\n            context.unexpectedToken();\n            return null;\n        }\n        let node = this.resume(context, precedence, parselet.prefix(context));\n        assert(node === null || node.range !== null); // Parselets must set the range of every node\n        return node;\n    }\n    resume(context, precedence, left) {\n        while (left !== null) {\n            let kind = context.current().kind;\n            let parselet = IntMap_get4(this._table, kind, null);\n            if (parselet === null || parselet.infix === null || parselet.precedence <= precedence) {\n                break;\n            }\n            left = parselet.infix(context, left);\n            assert(left === null || left.range !== null); // Parselets must set the range of every node\n        }\n        return left;\n    }\n    literal(kind, callback) {\n        this.parselet(kind, 0 /* LOWEST */).prefix = (context) => {\n            return callback(context, context.next());\n        };\n    }\n    prefix(kind, precedence, callback) {\n        this.parselet(kind, 0 /* LOWEST */).prefix = (context) => {\n            let token = context.next();\n            let value = this.parse(context, precedence);\n            return value !== null ? callback(context, token, value) : null;\n        };\n    }\n    postfix(kind, precedence, callback) {\n        this.parselet(kind, precedence).infix = (context, left) => {\n            return callback(context, left, context.next());\n        };\n    }\n    infix(kind, precedence, callback) {\n        this.parselet(kind, precedence).infix = (context, left) => {\n            let token = context.next();\n            let right = this.parse(context, precedence);\n            return right !== null ? callback(context, left, token, right) : null;\n        };\n    }\n    infixRight(kind, precedence, callback) {\n        this.parselet(kind, precedence).infix = (context, left) => {\n            let token = context.next();\n            let right = this.parse(context, precedence - 1); // Subtract 1 for right-associativity\n            return right !== null ? callback(context, left, token, right) : null;\n        };\n    }\n}\n","import { StringMap_get11, StringMap_get3, StringMap_set2, assert } from \"../../native-js\";\nexport class Scope {\n    constructor(kind, parent) {\n        this.kind = kind;\n        this.parent = parent;\n        this.symbols = new Map();\n    }\n    define(symbol) {\n        assert(!this.symbols.has(symbol.name));\n        StringMap_set2(this.symbols, symbol.name, symbol);\n    }\n    redefine(symbol) {\n        assert(this.symbols.has(symbol.name));\n        assert(StringMap_get11(this.symbols, symbol.name) !== symbol);\n        StringMap_set2(this.symbols, symbol.name, symbol);\n    }\n    find(name) {\n        let symbol = StringMap_get3(this.symbols, name, null);\n        if (symbol !== null) {\n            return symbol;\n        }\n        if (this.parent !== null) {\n            return this.parent.find(name);\n        }\n        return null;\n    }\n}\n","import { List_get2, StringMap_get11, StringMap_get3, StringMap_insert, StringMap_set2, assert, string_get12, string_slice2 } from \"../../native-js\";\nimport { fold } from \"./folder\";\nimport { Node, NodeKind, NodeKind_isBinary, NodeKind_isUnaryPostfix, NodeKind_isUnaryPrefix } from \"./node\";\nimport { Include, ParserContext, Pratt } from \"./pratt\";\nimport { Range } from \"./range\";\nimport { Scope } from \"./scope\";\nimport { FunctionSymbol, StructSymbol, SymbolFlags, VariableSymbol } from \"./symbol\";\nimport { TokenKind, tokenize } from \"./tokenizer\";\nimport { Type } from \"./type\";\nexport class ParseResult {\n    constructor(includes) {\n        this.includes = includes;\n    }\n}\nexport function typeParselet(type) {\n    return (context, token) => {\n        return Node.createType(type).withRange(token.range);\n    };\n}\nexport function unaryPrefix(kind) {\n    assert(NodeKind_isUnaryPrefix(kind));\n    return (context, token, value) => {\n        return Node.createUnary(kind, value).withRange(Range.span(token.range, value.range)).withInternalRange(token.range);\n    };\n}\nexport function unaryPostfix(kind) {\n    assert(NodeKind_isUnaryPostfix(kind));\n    return (context, value, token) => {\n        return Node.createUnary(kind, value).withRange(Range.span(value.range, token.range)).withInternalRange(token.range);\n    };\n}\nexport function binaryParselet(kind) {\n    assert(NodeKind_isBinary(kind));\n    return (context, left, token, right) => {\n        return Node.createBinary(kind, left, right).withRange(Range.span(left.range, right.range)).withInternalRange(token.range);\n    };\n}\nexport function parseInt(text) {\n    if (text.length > 1 && string_get12(text, 0) === 48 && (string_get12(text, 1) !== 120 && string_get12(text, 1) !== 88)) {\n        return Number.parseInt(text, 8);\n    }\n    // @ts-ignore:next-line\n    return text | 0;\n}\nexport function parseFloat(text) {\n    return +text;\n}\nexport function createExpressionParser() {\n    let pratt = new Pratt();\n    let invalidUnaryOperator = (context, token, value) => {\n        context.log.syntaxErrorInvalidOperator(token.range);\n        return Node.createUnknownConstant(Type.ERROR).withRange(Range.span(token.range, value.range));\n    };\n    let invalidBinaryOperator = (context, left, token, right) => {\n        context.log.syntaxErrorInvalidOperator(token.range);\n        return Node.createUnknownConstant(Type.ERROR).withRange(Range.span(left.range, right.range));\n    };\n    pratt.literal(TokenKind.TRUE, (context, token) => {\n        return Node.createBool(true).withRange(token.range);\n    });\n    pratt.literal(TokenKind.FALSE, (context, token) => {\n        return Node.createBool(false).withRange(token.range);\n    });\n    pratt.literal(TokenKind.INT_LITERAL, (context, token) => {\n        return Node.createInt(parseInt(token.range.toString())).withRange(token.range);\n    });\n    pratt.literal(TokenKind.FLOAT_LITERAL, (context, token) => {\n        return Node.createFloat(parseFloat(token.range.toString())).withRange(token.range);\n    });\n    pratt.literal(TokenKind.BOOL, typeParselet(Type.BOOL));\n    pratt.literal(TokenKind.BVEC2, typeParselet(Type.BVEC2));\n    pratt.literal(TokenKind.BVEC3, typeParselet(Type.BVEC3));\n    pratt.literal(TokenKind.BVEC4, typeParselet(Type.BVEC4));\n    pratt.literal(TokenKind.FLOAT, typeParselet(Type.FLOAT));\n    pratt.literal(TokenKind.INT, typeParselet(Type.INT));\n    pratt.literal(TokenKind.IVEC2, typeParselet(Type.IVEC2));\n    pratt.literal(TokenKind.IVEC3, typeParselet(Type.IVEC3));\n    pratt.literal(TokenKind.IVEC4, typeParselet(Type.IVEC4));\n    pratt.literal(TokenKind.MAT2, typeParselet(Type.MAT2));\n    pratt.literal(TokenKind.MAT3, typeParselet(Type.MAT3));\n    pratt.literal(TokenKind.MAT4, typeParselet(Type.MAT4));\n    pratt.literal(TokenKind.VEC2, typeParselet(Type.VEC2));\n    pratt.literal(TokenKind.VEC3, typeParselet(Type.VEC3));\n    pratt.literal(TokenKind.VEC4, typeParselet(Type.VEC4));\n    pratt.literal(TokenKind.UINT, typeParselet(Type.UINT));\n    pratt.literal(TokenKind.UVEC2, typeParselet(Type.UVEC2));\n    pratt.literal(TokenKind.UVEC3, typeParselet(Type.UVEC3));\n    pratt.literal(TokenKind.UVEC4, typeParselet(Type.UVEC4));\n    pratt.literal(TokenKind.VOID, typeParselet(Type.VOID));\n    pratt.prefix(TokenKind.COMPLEMENT, 14 /* UNARY_PREFIX */, invalidUnaryOperator);\n    pratt.prefix(TokenKind.DECREMENT, 14 /* UNARY_PREFIX */, unaryPrefix(NodeKind.PREFIX_DECREMENT));\n    pratt.prefix(TokenKind.INCREMENT, 14 /* UNARY_PREFIX */, unaryPrefix(NodeKind.PREFIX_INCREMENT));\n    pratt.prefix(TokenKind.MINUS, 14 /* UNARY_PREFIX */, unaryPrefix(NodeKind.NEGATIVE));\n    pratt.prefix(TokenKind.NOT, 14 /* UNARY_PREFIX */, unaryPrefix(NodeKind.NOT));\n    pratt.prefix(TokenKind.PLUS, 14 /* UNARY_PREFIX */, unaryPrefix(NodeKind.POSITIVE));\n    pratt.postfix(TokenKind.DECREMENT, 15 /* UNARY_POSTFIX */, unaryPostfix(NodeKind.POSTFIX_DECREMENT));\n    pratt.postfix(TokenKind.INCREMENT, 15 /* UNARY_POSTFIX */, unaryPostfix(NodeKind.POSTFIX_INCREMENT));\n    pratt.infix(TokenKind.DIVIDE, 13 /* MULTIPLY */, binaryParselet(NodeKind.DIVIDE));\n    pratt.infix(TokenKind.EQUAL, 10 /* COMPARE */, binaryParselet(NodeKind.EQUAL));\n    pratt.infix(TokenKind.GREATER_THAN, 10 /* COMPARE */, binaryParselet(NodeKind.GREATER_THAN));\n    pratt.infix(TokenKind.GREATER_THAN_OR_EQUAL, 10 /* COMPARE */, binaryParselet(NodeKind.GREATER_THAN_OR_EQUAL));\n    pratt.infix(TokenKind.LESS_THAN, 10 /* COMPARE */, binaryParselet(NodeKind.LESS_THAN));\n    pratt.infix(TokenKind.LESS_THAN_OR_EQUAL, 10 /* COMPARE */, binaryParselet(NodeKind.LESS_THAN_OR_EQUAL));\n    pratt.infix(TokenKind.MINUS, 12 /* ADD */, binaryParselet(NodeKind.SUBTRACT));\n    pratt.infix(TokenKind.MULTIPLY, 13 /* MULTIPLY */, binaryParselet(NodeKind.MULTIPLY));\n    pratt.infix(TokenKind.NOT_EQUAL, 10 /* COMPARE */, binaryParselet(NodeKind.NOT_EQUAL));\n    pratt.infix(TokenKind.PLUS, 12 /* ADD */, binaryParselet(NodeKind.ADD));\n    pratt.infix(TokenKind.REMAINDER, 13 /* MULTIPLY */, invalidBinaryOperator);\n    pratt.infix(TokenKind.SHIFT_LEFT, 11 /* SHIFT */, invalidBinaryOperator);\n    pratt.infix(TokenKind.SHIFT_RIGHT, 11 /* SHIFT */, invalidBinaryOperator);\n    pratt.infix(TokenKind.LOGICAL_OR, 3 /* LOGICAL_OR */, binaryParselet(NodeKind.LOGICAL_OR));\n    pratt.infix(TokenKind.LOGICAL_XOR, 4 /* LOGICAL_XOR */, binaryParselet(NodeKind.LOGICAL_XOR));\n    pratt.infix(TokenKind.LOGICAL_AND, 5 /* LOGICAL_AND */, binaryParselet(NodeKind.LOGICAL_AND));\n    pratt.infix(TokenKind.BITWISE_AND, 8 /* BITWISE_AND */, invalidBinaryOperator);\n    pratt.infix(TokenKind.BITWISE_OR, 6 /* BITWISE_OR */, invalidBinaryOperator);\n    pratt.infix(TokenKind.BITWISE_XOR, 7 /* BITWISE_XOR */, invalidBinaryOperator);\n    pratt.infixRight(TokenKind.ASSIGN, 2 /* ASSIGN */, binaryParselet(NodeKind.ASSIGN));\n    pratt.infixRight(TokenKind.ASSIGN_ADD, 2 /* ASSIGN */, binaryParselet(NodeKind.ASSIGN_ADD));\n    pratt.infixRight(TokenKind.ASSIGN_BITWISE_AND, 2 /* ASSIGN */, invalidBinaryOperator);\n    pratt.infixRight(TokenKind.ASSIGN_BITWISE_OR, 2 /* ASSIGN */, invalidBinaryOperator);\n    pratt.infixRight(TokenKind.ASSIGN_BITWISE_XOR, 2 /* ASSIGN */, invalidBinaryOperator);\n    pratt.infixRight(TokenKind.ASSIGN_DIVIDE, 2 /* ASSIGN */, binaryParselet(NodeKind.ASSIGN_DIVIDE));\n    pratt.infixRight(TokenKind.ASSIGN_MULTIPLY, 2 /* ASSIGN */, binaryParselet(NodeKind.ASSIGN_MULTIPLY));\n    pratt.infixRight(TokenKind.ASSIGN_REMAINDER, 2 /* ASSIGN */, invalidBinaryOperator);\n    pratt.infixRight(TokenKind.ASSIGN_SHIFT_LEFT, 2 /* ASSIGN */, invalidBinaryOperator);\n    pratt.infixRight(TokenKind.ASSIGN_SHIFT_RIGHT, 2 /* ASSIGN */, invalidBinaryOperator);\n    pratt.infixRight(TokenKind.ASSIGN_SUBTRACT, 2 /* ASSIGN */, binaryParselet(NodeKind.ASSIGN_SUBTRACT));\n    // Name\n    pratt.literal(TokenKind.IDENTIFIER, (context, token) => {\n        let name = token.range.toString();\n        let symbol = context.scope().find(name);\n        if (symbol === null) {\n            context.log.syntaxErrorBadSymbolReference(token.range);\n            return Node.createParseError().withRange(token.range);\n        }\n        // Check extension usage\n        if (symbol.requiredExtension !== null && context.compilationData.extensionBehavior(symbol.requiredExtension) === 1 /* DISABLE */) {\n            context.log.syntaxErrorDisabledExtension(token.range, name, symbol.requiredExtension);\n        }\n        symbol.useCount = symbol.useCount + 1;\n        return (symbol.isStruct() ? Node.createType(symbol.resolvedType()) : Node.createName(symbol)).withRange(token.range);\n    });\n    // Sequence\n    pratt.infix(TokenKind.COMMA, 1 /* COMMA */, (context, left, token, right) => {\n        if (left.kind !== NodeKind.SEQUENCE) {\n            left = Node.createSequence().appendChild(left).withRange(left.range);\n        }\n        left.appendChild(right);\n        return left.withRange(context.spanSince(left.range));\n    });\n    // Dot\n    pratt.parselet(TokenKind.DOT, 16 /* MEMBER */).infix = (context, left) => {\n        let dot = context.current().range;\n        context.next();\n        let name = context.current().range;\n        if (!context.expect(TokenKind.IDENTIFIER)) {\n            return Node.createDot(left, '').withRange(context.spanSince(left.range)).withInternalRange(dot.rangeAtEnd());\n        }\n        return Node.createDot(left, name.toString()).withRange(context.spanSince(left.range)).withInternalRange(name);\n    };\n    // Group\n    pratt.parselet(TokenKind.LEFT_PARENTHESIS, 0 /* LOWEST */).prefix = (context) => {\n        let token = context.next();\n        let value = pratt.parse(context, 0 /* LOWEST */);\n        if (value === null || !context.expect(TokenKind.RIGHT_PARENTHESIS)) {\n            return Node.createParseError().withRange(context.spanSince(token.range));\n        }\n        return value.withRange(context.spanSince(token.range));\n    };\n    // Call\n    pratt.parselet(TokenKind.LEFT_PARENTHESIS, 15 /* UNARY_POSTFIX */).infix = (context, left) => {\n        let token = context.next();\n        let node = Node.createCall(left);\n        if (!parseCommaSeparatedList(context, node, TokenKind.RIGHT_PARENTHESIS)) {\n            return Node.createParseError().withRange(context.spanSince(token.range));\n        }\n        return node.withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range));\n    };\n    // Index\n    pratt.parselet(TokenKind.LEFT_BRACKET, 16 /* MEMBER */).infix = (context, left) => {\n        let token = context.next();\n        // The \"[]\" syntax isn't valid but skip over it and recover\n        if (context.peek(TokenKind.RIGHT_BRACKET)) {\n            context.unexpectedToken();\n            context.next();\n            return Node.createParseError().withRange(context.spanSince(token.range));\n        }\n        let value = pratt.parse(context, 0 /* LOWEST */);\n        if (value === null || !context.expect(TokenKind.RIGHT_BRACKET)) {\n            return Node.createParseError().withRange(context.spanSince(token.range));\n        }\n        return Node.createBinary(NodeKind.INDEX, left, value).withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range));\n    };\n    // Hook\n    pratt.parselet(TokenKind.QUESTION, 2 /* ASSIGN */).infix = (context, left) => {\n        let token = context.next();\n        let middle = pratt.parse(context, 1 /* COMMA */);\n        if (middle === null || !context.expect(TokenKind.COLON)) {\n            return Node.createParseError().withRange(context.spanSince(token.range));\n        }\n        let right = pratt.parse(context, 1 /* COMMA */);\n        if (right === null) {\n            return Node.createParseError().withRange(context.spanSince(token.range));\n        }\n        return Node.createHook(left, middle, right).withRange(context.spanSince(left.range));\n    };\n    return pratt;\n}\nexport function parseCommaSeparatedList(context, parent, stop) {\n    let isFirst = true;\n    while (!context.eat(stop)) {\n        if (!isFirst) {\n            context.expect(TokenKind.COMMA);\n        }\n        let firstToken = context.current();\n        let value = pratt.parse(context, 1 /* COMMA */);\n        if (value !== null) {\n            parent.appendChild(value);\n        }\n        else {\n            // Recover from errors due to partially-typed calls\n            parent.appendChild(Node.createParseError().withRange(context.spanSince(firstToken.range)));\n            if (context.current().kind !== TokenKind.COMMA && context.current().kind !== stop) {\n                return false;\n            }\n        }\n        isFirst = false;\n    }\n    return true;\n}\nexport function parseDoWhile(context) {\n    let token = context.next();\n    context.pushScope(new Scope(3 /* LOOP */, context.scope()));\n    let body = parseStatement(context, 2 /* LOCAL */);\n    if (body === null || !context.expect(TokenKind.WHILE) || !context.expect(TokenKind.LEFT_PARENTHESIS)) {\n        return null;\n    }\n    let test = pratt.parse(context, 0 /* LOWEST */);\n    if (test === null) {\n        return null;\n    }\n    if (!context.expect(TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n    }\n    context.popScope();\n    return checkForSemicolon(context, token.range, Node.createDoWhile(body, test));\n}\nexport function parseExportOrImport(context) {\n    let token = context.next();\n    let old = context.flags;\n    context.flags |= token.kind === TokenKind.EXPORT ? SymbolFlags.EXPORTED : SymbolFlags.IMPORTED;\n    // Parse a modifier block\n    if (context.eat(TokenKind.LEFT_BRACE)) {\n        let node = Node.createModifierBlock();\n        if (!parseStatements(context, node, 1 /* GLOBAL */) || !context.expect(TokenKind.RIGHT_BRACE)) {\n            return null;\n        }\n        context.flags = old;\n        return node.withRange(context.spanSince(token.range));\n    }\n    // Just parse a single statement\n    let statement = parseStatement(context, 1 /* GLOBAL */);\n    if (statement === null) {\n        return null;\n    }\n    context.flags = old;\n    return statement;\n}\nexport function parseExtension(context) {\n    let token = context.next();\n    let range = context.current().range;\n    if (!context.expect(TokenKind.IDENTIFIER)) {\n        return null;\n    }\n    let name = range.toString();\n    // Parse an extension block (a non-standard addition)\n    if (context.eat(TokenKind.LEFT_BRACE)) {\n        if (!context.compilationData.currentExtensions.has(name)) {\n            StringMap_set2(context.compilationData.currentExtensions, name, 0 /* DEFAULT */); // Silence warnings about this name\n        }\n        let block = Node.createModifierBlock();\n        if (!parseStatements(context, block, 1 /* GLOBAL */) || !context.expect(TokenKind.RIGHT_BRACE)) {\n            return null;\n        }\n        for (let child = block.firstChild(); child !== null; child = child.nextSibling()) {\n            if (child.kind === NodeKind.VARIABLES) {\n                for (let variable = child.variablesType().nextSibling(); variable !== null; variable = variable.nextSibling()) {\n                    variable.symbol.requiredExtension = name;\n                }\n            }\n            else if (child.symbol !== null) {\n                child.symbol.requiredExtension = name;\n            }\n        }\n        return block.withRange(context.spanSince(token.range));\n    }\n    // Warn about typos\n    if (!_knownWebGLExtensions.has(name) && !context.compilationData.currentExtensions.has(name)) {\n        context.log.syntaxWarningUnknownExtension(range, name);\n    }\n    // Parse a regular extension pragma\n    if (!context.expect(TokenKind.COLON)) {\n        return null;\n    }\n    let text = context.current().range.toString();\n    if (!_extensionBehaviors.has(text)) {\n        context.unexpectedToken();\n        return null;\n    }\n    context.next();\n    // Activate or deactivate the extension\n    let behavior = StringMap_get11(_extensionBehaviors, text);\n    StringMap_set2(context.compilationData.currentExtensions, name, behavior);\n    return Node.createExtension(name, behavior).withRange(context.spanSince(token.range)).withInternalRange(range);\n}\nexport function parseFor(context) {\n    let token = context.next();\n    context.pushScope(new Scope(3 /* LOOP */, context.scope()));\n    if (!context.expect(TokenKind.LEFT_PARENTHESIS)) {\n        return null;\n    }\n    // Setup\n    let setup = null;\n    if (!context.eat(TokenKind.SEMICOLON)) {\n        // Check for a type\n        let comments = parseLeadingComments(context);\n        let flags = parseFlags(context, 2 /* LOCAL */);\n        let type = null;\n        // @ts-ignore:next-line\n        if (flags !== 0) {\n            type = parseType(context, 1 /* REPORT_ERRORS */);\n            if (type === null) {\n                return null;\n            }\n        }\n        else {\n            type = parseType(context, 0 /* IGNORE_ERRORS */);\n        }\n        // Try to parse a variable\n        if (type !== null) {\n            setup = parseAfterType(context, token.range, flags, type, 0 /* AVOID_FUNCTIONS */, comments);\n            if (setup === null) {\n                return null;\n            }\n        }\n        else {\n            setup = pratt.parse(context, 0 /* LOWEST */);\n            if (setup === null) {\n                return null;\n            }\n            if (!context.expect(TokenKind.SEMICOLON)) {\n                return null;\n            }\n        }\n    }\n    // Test\n    let test = null;\n    if (!context.eat(TokenKind.SEMICOLON)) {\n        test = pratt.parse(context, 0 /* LOWEST */);\n        if (test === null) {\n            return null;\n        }\n        if (!context.expect(TokenKind.SEMICOLON)) {\n            return null;\n        }\n    }\n    // Update\n    let update = null;\n    if (!context.eat(TokenKind.RIGHT_PARENTHESIS)) {\n        update = pratt.parse(context, 0 /* LOWEST */);\n        if (update === null) {\n            return null;\n        }\n        if (!context.expect(TokenKind.RIGHT_PARENTHESIS)) {\n            return null;\n        }\n    }\n    // Body\n    let body = parseStatement(context, 2 /* LOCAL */);\n    if (body === null) {\n        return null;\n    }\n    context.popScope();\n    return Node.createFor(setup, test, update, body).withRange(context.spanSince(token.range));\n}\nexport function parseIf(context) {\n    let token = context.next();\n    if (!context.expect(TokenKind.LEFT_PARENTHESIS)) {\n        return null;\n    }\n    let firstToken = context.current();\n    let test = pratt.parse(context, 0 /* LOWEST */);\n    if (test === null) {\n        test = Node.createParseError().withRange(context.spanSince(firstToken.range));\n    }\n    if (!context.expect(TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n    }\n    let yes = parseStatement(context, 2 /* LOCAL */);\n    if (yes === null) {\n        return null;\n    }\n    let no = null;\n    if (context.eat(TokenKind.ELSE)) {\n        no = parseStatement(context, 2 /* LOCAL */);\n        if (no === null) {\n            return null;\n        }\n    }\n    return Node.createIf(test, yes, no).withRange(context.spanSince(token.range));\n}\nexport function parseVersion(context) {\n    let token = context.next();\n    let range = context.current().range;\n    if (!context.expect(TokenKind.INT_LITERAL)) {\n        return null;\n    }\n    // @ts-ignore:next-line\n    return Node.createVersion(range.toString() | 0).withRange(context.spanSince(token.range));\n}\nexport function parseDefine(context) {\n    // Skip #define\n    let start = context.next().range;\n    let startLine = start.lineColumn().line;\n    let token = context.next();\n    if (token.kind !== TokenKind.IDENTIFIER || token.range.lineColumn().line !== startLine) {\n        context.unexpectedToken();\n        return null;\n    }\n    // Eat till the end of line \n    while (context.current().range.lineColumn().line === startLine) {\n        context.next();\n    }\n    // Note: we are not creating a symbol for `#define` statements\n    // as they are processed by the preprocessor.\n    return Node.createDefine().withRange(context.spanSince(start));\n}\nexport function parseWhile(context) {\n    let token = context.next();\n    context.pushScope(new Scope(3 /* LOOP */, context.scope()));\n    if (!context.expect(TokenKind.LEFT_PARENTHESIS)) {\n        return null;\n    }\n    let firstToken = context.current();\n    let test = pratt.parse(context, 0 /* LOWEST */);\n    if (test === null) {\n        test = Node.createParseError().withRange(context.spanSince(firstToken.range));\n    }\n    if (!context.expect(TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n    }\n    let body = parseStatement(context, 2 /* LOCAL */);\n    if (body === null) {\n        return null;\n    }\n    context.popScope();\n    return Node.createWhile(test, body).withRange(context.spanSince(token.range));\n}\nexport function parseReturn(context) {\n    let token = context.next();\n    let value = null;\n    if (!context.eat(TokenKind.SEMICOLON)) {\n        let firstToken = context.current();\n        value = pratt.parse(context, 0 /* LOWEST */);\n        if (value === null) {\n            value = Node.createParseError().withRange(context.spanSince(firstToken.range));\n        }\n        context.expect(TokenKind.SEMICOLON);\n    }\n    return Node.createReturn(value).withRange(context.spanSince(token.range));\n}\nexport function parsePrecision(context) {\n    let token = context.next();\n    let flag = 0;\n    switch (context.current().kind) {\n        case TokenKind.LOWP: {\n            flag = SymbolFlags.LOWP;\n            break;\n        }\n        case TokenKind.MEDIUMP: {\n            flag = SymbolFlags.MEDIUMP;\n            break;\n        }\n        case TokenKind.HIGHP: {\n            flag = SymbolFlags.HIGHP;\n            break;\n        }\n        default: {\n            context.unexpectedToken();\n            return null;\n        }\n    }\n    context.next();\n    let type = parseType(context, 1 /* REPORT_ERRORS */);\n    if (type === null) {\n        return null;\n    }\n    return checkForSemicolon(context, token.range, Node.createPrecision(flag, type));\n}\nexport function parseStruct(context, flags, comments) {\n    let name = context.current().range;\n    if (!context.expect(TokenKind.IDENTIFIER)) {\n        return null;\n    }\n    let symbol = new StructSymbol(context.compilationData.nextSymbolID(), name, name.toString(), new Scope(4 /* STRUCT */, context.scope()));\n    symbol.flags |= context.flags | flags;\n    symbol.comments = comments;\n    if (!tryToDefineUniquelyInScope(context, symbol)) {\n        return null;\n    }\n    let range = context.current().range;\n    let block = Node.createStructBlock();\n    let variables = null;\n    if (!context.expect(TokenKind.LEFT_BRACE)) {\n        return null;\n    }\n    context.pushScope(symbol.scope);\n    while (!context.peek(TokenKind.RIGHT_BRACE) && !context.peek(TokenKind.END_OF_FILE)) {\n        let statement = parseStatement(context, 3 /* STRUCT */);\n        if (statement === null) {\n            return null;\n        }\n        if (statement.kind !== NodeKind.VARIABLES) {\n            context.log.syntaxErrorInsideStruct(statement.range);\n            continue;\n        }\n        block.appendChild(statement);\n        for (let child = statement.variablesType().nextSibling(); child !== null; child = child.nextSibling()) {\n            let variable = child.symbol.asVariable();\n            symbol.variables.push(variable);\n            if (variable.value() !== null) {\n                context.log.syntaxErrorStructVariableInitializer(variable.value().range);\n            }\n        }\n    }\n    context.popScope();\n    if (!context.expect(TokenKind.RIGHT_BRACE)) {\n        return null;\n    }\n    block.withRange(context.spanSince(range));\n    // Parse weird struct-variable hybrid things\n    //\n    //   struct S { int x; } y, z[2];\n    //\n    if (context.peek(TokenKind.IDENTIFIER)) {\n        variables = parseVariables(0, Node.createType(symbol.resolvedType()), context.next().range, context, comments);\n        if (variables === null) {\n            return null;\n        }\n    }\n    else {\n        context.expect(TokenKind.SEMICOLON);\n    }\n    return Node.createStruct(symbol, block, variables);\n}\nexport function checkForLoopAndSemicolon(context, range, node) {\n    let found = false;\n    for (let scope = context.scope(); scope !== null; scope = scope.parent) {\n        if (scope.kind === 3 /* LOOP */) {\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        context.log.syntaxErrorOutsideLoop(range);\n    }\n    return checkForSemicolon(context, range, node);\n}\nexport function checkForSemicolon(context, range, node) {\n    context.expect(TokenKind.SEMICOLON);\n    return node.withRange(context.spanSince(range));\n}\nexport function parseAfterType(context, range, flags, type, allow, comments) {\n    let name = context.current().range;\n    // @ts-ignore:next-line\n    if (flags === 0 && !context.peek(TokenKind.IDENTIFIER)) {\n        let value = pratt.resume(context, 0 /* LOWEST */, type);\n        if (value === null) {\n            return null;\n        }\n        return checkForSemicolon(context, range, Node.createExpression(value));\n    }\n    if (!context.expect(TokenKind.IDENTIFIER)) {\n        return null;\n    }\n    if (context.eat(TokenKind.LEFT_PARENTHESIS)) {\n        return parseFunction(flags, type, name, context, comments);\n    }\n    let variables = parseVariables(flags, type, name, context, comments);\n    if (variables === null) {\n        return null;\n    }\n    return variables.withRange(context.spanSince(range));\n}\nexport function parseLeadingComments(context) {\n    let firstToken = context.current();\n    let comments = firstToken.comments;\n    if (comments === null) {\n        return null;\n    }\n    let nextRangeStart = firstToken.range.start;\n    let leadingComments = null;\n    // Scan the comments backwards\n    for (let i = comments.length - 1; i >= 0; i = i - 1) {\n        let comment = List_get2(comments, i);\n        // Count the newlines in between this token and the next token\n        let whitespace = string_slice2(comment.source.contents, comment.end, nextRangeStart);\n        let newlineCount = 0;\n        for (let j = 0; j < whitespace.length; j = j + 1) {\n            let c = string_get12(whitespace, j);\n            if (c === 13 || c === 10) {\n                newlineCount = newlineCount + 1;\n                if (c === 13 && j + 1 < whitespace.length && string_get12(whitespace, j + 1) === 10) {\n                    j = j + 1;\n                }\n            }\n        }\n        // Don't count comments if there's a blank line in between the comment and the statement\n        if (newlineCount > 1) {\n            break;\n        }\n        // Otherwise, count this comment\n        (leadingComments !== null ? leadingComments : leadingComments = []).push(comment.toString());\n        nextRangeStart = comment.start;\n    }\n    if (leadingComments !== null) {\n        leadingComments.reverse();\n    }\n    return leadingComments;\n}\nexport function parseStatement(context, mode) {\n    let token = context.current();\n    switch (token.kind) {\n        case TokenKind.BREAK: {\n            return checkForLoopAndSemicolon(context, context.next().range, Node.createBreak());\n        }\n        case TokenKind.CONTINUE: {\n            return checkForLoopAndSemicolon(context, context.next().range, Node.createContinue());\n        }\n        case TokenKind.DISCARD: {\n            return checkForSemicolon(context, context.next().range, Node.createDiscard());\n        }\n        case TokenKind.DO: {\n            return parseDoWhile(context);\n        }\n        case TokenKind.EXPORT:\n        case TokenKind.IMPORT: {\n            return parseExportOrImport(context);\n        }\n        case TokenKind.EXTENSION: {\n            return parseExtension(context);\n        }\n        case TokenKind.FOR: {\n            return parseFor(context);\n        }\n        case TokenKind.IF: {\n            return parseIf(context);\n        }\n        case TokenKind.LEFT_BRACE: {\n            return parseBlock(context);\n        }\n        case TokenKind.PRECISION: {\n            return parsePrecision(context);\n        }\n        case TokenKind.RETURN: {\n            return parseReturn(context);\n        }\n        case TokenKind.SEMICOLON: {\n            return Node.createBlock().withRange(context.next().range);\n        }\n        case TokenKind.VERSION: {\n            return parseVersion(context);\n        }\n        case TokenKind.DEFINE: {\n            return parseDefine(context);\n        }\n        case TokenKind.WHILE: {\n            return parseWhile(context);\n        }\n    }\n    // Try to parse a variable or function\n    let comments = parseLeadingComments(context);\n    let flags = parseFlags(context, mode);\n    let type = null;\n    if (context.eat(TokenKind.STRUCT)) {\n        let struct = parseStruct(context, flags, comments);\n        if (struct === null) {\n            return null;\n        }\n        return struct.withRange(context.spanSince(token.range));\n    }\n    // @ts-ignore:next-line\n    if (flags !== 0) {\n        type = parseType(context, 1 /* REPORT_ERRORS */);\n        if (type === null) {\n            return null;\n        }\n    }\n    else {\n        type = parseType(context, 0 /* IGNORE_ERRORS */);\n    }\n    if (type !== null) {\n        return parseAfterType(context, token.range, flags, type, 1 /* ALLOW_FUNCTIONS */, comments);\n    }\n    // Parse an expression\n    let value = pratt.parse(context, 0 /* LOWEST */);\n    if (value === null) {\n        return null;\n    }\n    return checkForSemicolon(context, token.range, Node.createExpression(value));\n}\nexport function checkStatementLocation(context, node) {\n    if (node.kind === NodeKind.VARIABLES || node.kind === NodeKind.STRUCT || node.kind === NodeKind.DEFINE) {\n        return;\n    }\n    let isOutsideFunction = context.scope().kind === 1 /* GLOBAL */ || context.scope().kind === 4 /* STRUCT */;\n    let shouldBeOutsideFunction = node.kind === NodeKind.EXTENSION || node.kind === NodeKind.FUNCTION || node.kind === NodeKind.PRECISION || node.kind === NodeKind.VERSION;\n    if (shouldBeOutsideFunction && !isOutsideFunction) {\n        context.log.syntaxErrorInsideFunction(node.range);\n    }\n    else if (!shouldBeOutsideFunction && isOutsideFunction) {\n        context.log.syntaxErrorOutsideFunction(node.range);\n    }\n}\nexport function parseInclude(context, parent) {\n    // See if there is a string literal\n    let range = context.current().range;\n    if (!context.expect(TokenKind.STRING_LITERAL)) {\n        return false;\n    }\n    // Decode the escapes\n    let path = null;\n    try {\n        path = JSON.parse(range.toString());\n    }\n    catch (_a) {\n        context.log.syntaxErrorInvalidString(range);\n        return false;\n    }\n    // Must have access to the file system\n    let fileAccess = context.compilationData.fileAccess;\n    if (fileAccess === null) {\n        context.log.semanticErrorIncludeWithoutFileAccess(range);\n        return false;\n    }\n    // Must be able to read the file\n    let source = fileAccess(path, range.source.name);\n    if (source === null) {\n        context.log.semanticErrorIncludeBadPath(range, path);\n        return false;\n    }\n    if (context.processedIncludes.has(source.name)) {\n        // We've already processed this include; no need to do it again\n        return true;\n    }\n    StringMap_set2(context.processedIncludes, source.name, true);\n    // Track the included file for jump-to-file in the IDE\n    context.includes.push(new Include(range, source.entireRange()));\n    // Parse the file and insert it into the parent\n    let tokens = tokenize(context.log, source, 0 /* COMPILE */);\n    let nestedContext = new ParserContext(context.log, tokens, context.compilationData, context.resolver, context.processedIncludes);\n    nestedContext.pushScope(context.scope());\n    if (!parseStatements(nestedContext, parent, 1 /* GLOBAL */) || !nestedContext.expect(TokenKind.END_OF_FILE)) {\n        return false;\n    }\n    return true;\n}\nexport function parseBlock(context) {\n    let token = context.current();\n    let block = Node.createBlock();\n    context.pushScope(new Scope(2 /* LOCAL */, context.scope()));\n    if (!context.expect(TokenKind.LEFT_BRACE) || !parseStatements(context, block, 2 /* LOCAL */) || !context.expect(TokenKind.RIGHT_BRACE)) {\n        return null;\n    }\n    context.popScope();\n    return block.withRange(context.spanSince(token.range));\n}\nexport function parseFlags(context, mode) {\n    let flags = 0;\n    while (true) {\n        let kind = context.current().kind;\n        switch (kind) {\n            case TokenKind.ATTRIBUTE: {\n                flags |= SymbolFlags.ATTRIBUTE;\n                break;\n            }\n            case TokenKind.CONST: {\n                flags |= SymbolFlags.CONST;\n                break;\n            }\n            case TokenKind.HIGHP: {\n                flags |= SymbolFlags.HIGHP;\n                break;\n            }\n            case TokenKind.IN: {\n                flags |= SymbolFlags.IN;\n                break;\n            }\n            case TokenKind.INOUT: {\n                flags |= SymbolFlags.INOUT;\n                break;\n            }\n            case TokenKind.LOWP: {\n                flags |= SymbolFlags.LOWP;\n                break;\n            }\n            case TokenKind.MEDIUMP: {\n                flags |= SymbolFlags.MEDIUMP;\n                break;\n            }\n            case TokenKind.OUT: {\n                flags |= SymbolFlags.OUT;\n                break;\n            }\n            case TokenKind.UNIFORM: {\n                flags |= SymbolFlags.UNIFORM;\n                break;\n            }\n            case TokenKind.VARYING: {\n                flags |= SymbolFlags.VARYING;\n                break;\n            }\n            default: {\n                return flags;\n            }\n        }\n        if (mode === 0 /* ARGUMENT */ && (kind === TokenKind.ATTRIBUTE || kind === TokenKind.UNIFORM || kind === TokenKind.VARYING) || mode === 3 /* STRUCT */ && kind !== TokenKind.LOWP && kind !== TokenKind.MEDIUMP && kind !== TokenKind.HIGHP || mode !== 0 /* ARGUMENT */ && (kind === TokenKind.INOUT || kind === TokenKind.OUT && mode !== 1 /* GLOBAL */ || kind === TokenKind.IN && mode !== 1 /* GLOBAL */)) {\n            context.log.syntaxErrorBadQualifier(context.current().range);\n        }\n        context.next();\n    }\n}\nexport function parseType(context, mode) {\n    let token = context.current();\n    let type = null;\n    switch (token.kind) {\n        case TokenKind.BOOL: {\n            type = Type.BOOL;\n            break;\n        }\n        case TokenKind.BVEC2: {\n            type = Type.BVEC2;\n            break;\n        }\n        case TokenKind.BVEC3: {\n            type = Type.BVEC3;\n            break;\n        }\n        case TokenKind.BVEC4: {\n            type = Type.BVEC4;\n            break;\n        }\n        case TokenKind.FLOAT: {\n            type = Type.FLOAT;\n            break;\n        }\n        case TokenKind.UINT: {\n            type = Type.UINT;\n            break;\n        }\n        case TokenKind.INT: {\n            type = Type.INT;\n            break;\n        }\n        case TokenKind.IVEC2: {\n            type = Type.IVEC2;\n            break;\n        }\n        case TokenKind.IVEC3: {\n            type = Type.IVEC3;\n            break;\n        }\n        case TokenKind.IVEC4: {\n            type = Type.IVEC4;\n            break;\n        }\n        case TokenKind.MAT2: {\n            type = Type.MAT2;\n            break;\n        }\n        case TokenKind.MAT3: {\n            type = Type.MAT3;\n            break;\n        }\n        case TokenKind.MAT4: {\n            type = Type.MAT4;\n            break;\n        }\n        case TokenKind.SAMPLER2D: {\n            type = Type.SAMPLER2D;\n            break;\n        }\n        case TokenKind.SAMPLER3D: {\n            type = Type.SAMPLER3D;\n            break;\n        }\n        case TokenKind.SAMPLERCUBE: {\n            type = Type.SAMPLERCUBE;\n            break;\n        }\n        case TokenKind.ISAMPLERCUBE: {\n            type = Type.ISAMPLERCUBE;\n            break;\n        }\n        case TokenKind.USAMPLERCUBE: {\n            type = Type.USAMPLERCUBE;\n            break;\n        }\n        case TokenKind.SAMPLER2DARRAY: {\n            type = Type.SAMPLER2DARRAY;\n            break;\n        }\n        case TokenKind.ISAMPLER2DARRAY: {\n            type = Type.ISAMPLER2DARRAY;\n            break;\n        }\n        case TokenKind.USAMPLER2DARRAY: {\n            type = Type.USAMPLER2DARRAY;\n            break;\n        }\n        case TokenKind.SAMPLER2DSHADOW: {\n            type = Type.SAMPLER2DSHADOW;\n            break;\n        }\n        case TokenKind.SAMPLERCUBESHADOW: {\n            type = Type.SAMPLERCUBESHADOW;\n            break;\n        }\n        case TokenKind.SAMPLER2DARRAYSHADOW: {\n            type = Type.SAMPLER2DARRAYSHADOW;\n            break;\n        }\n        case TokenKind.USAMPLER2DARRAYSHADOW: {\n            type = Type.USAMPLER2DARRAYSHADOW;\n            break;\n        }\n        case TokenKind.ISAMPLER2DARRAYSHADOW: {\n            type = Type.ISAMPLER2DARRAYSHADOW;\n            break;\n        }\n        case TokenKind.ISAMPLER2D: {\n            type = Type.ISAMPLER2D;\n            break;\n        }\n        case TokenKind.USAMPLER2D: {\n            type = Type.USAMPLER2D;\n            break;\n        }\n        case TokenKind.ISAMPLER3D: {\n            type = Type.ISAMPLER3D;\n            break;\n        }\n        case TokenKind.USAMPLER3D: {\n            type = Type.USAMPLER3D;\n            break;\n        }\n        case TokenKind.VEC2: {\n            type = Type.VEC2;\n            break;\n        }\n        case TokenKind.VEC3: {\n            type = Type.VEC3;\n            break;\n        }\n        case TokenKind.VEC4: {\n            type = Type.VEC4;\n            break;\n        }\n        case TokenKind.UVEC2: {\n            type = Type.UVEC2;\n            break;\n        }\n        case TokenKind.UVEC3: {\n            type = Type.UVEC3;\n            break;\n        }\n        case TokenKind.UVEC4: {\n            type = Type.UVEC4;\n            break;\n        }\n        case TokenKind.VOID: {\n            type = Type.VOID;\n            break;\n        }\n        case TokenKind.IDENTIFIER: {\n            let symbol = context.scope().find(token.range.toString());\n            if (symbol === null || !symbol.isStruct()) {\n                if (mode === 1 /* REPORT_ERRORS */) {\n                    context.unexpectedToken();\n                }\n                return null;\n            }\n            type = symbol.resolvedType();\n            break;\n        }\n        default: {\n            if (mode === 1 /* REPORT_ERRORS */) {\n                context.unexpectedToken();\n            }\n            return null;\n        }\n    }\n    context.next();\n    return Node.createType(type).withRange(context.spanSince(token.range));\n}\nexport function parseFunction(flags, type, name, context, comments) {\n    let originalScope = context.scope();\n    let _function = new FunctionSymbol(context.compilationData.nextSymbolID(), name, name.toString(), new Scope(0 /* FUNCTION */, originalScope));\n    _function.flags |= context.flags | flags | (_function.name === 'main' ? SymbolFlags.EXPORTED : 0);\n    _function.comments = comments;\n    _function.returnType = type;\n    context.pushScope(_function.scope);\n    // Takes no arguments\n    if (context.eat(TokenKind.VOID)) {\n        if (!context.expect(TokenKind.RIGHT_PARENTHESIS)) {\n            return null;\n        }\n    }\n    // Takes arguments\n    else if (!context.eat(TokenKind.RIGHT_PARENTHESIS)) {\n        while (true) {\n            // Parse leading flags\n            let argumentFlags = parseFlags(context, 0 /* ARGUMENT */);\n            // Parse the type\n            let argumentType = parseType(context, 1 /* REPORT_ERRORS */);\n            if (argumentType === null) {\n                return null;\n            }\n            // Parse the identifier\n            let argumentName = context.current().range;\n            if (!context.expect(TokenKind.IDENTIFIER)) {\n                return null;\n            }\n            // Create the argument\n            let argument = new VariableSymbol(context.compilationData.nextSymbolID(), argumentName, argumentName.toString(), context.scope(), 0 /* ARGUMENT */);\n            argument.flags |= argumentFlags;\n            argument.type = argumentType;\n            _function._arguments.push(argument);\n            tryToDefineUniquelyInScope(context, argument);\n            // Array size\n            if (!parseArraySize(context, argument)) {\n                return null;\n            }\n            // Parse another argument?\n            if (!context.eat(TokenKind.COMMA)) {\n                break;\n            }\n        }\n        if (!context.expect(TokenKind.RIGHT_PARENTHESIS)) {\n            return null;\n        }\n    }\n    let previous = StringMap_get3(originalScope.symbols, name.toString(), null);\n    let hasBlock = !context.eat(TokenKind.SEMICOLON);\n    // Merge adjacent function symbols to support overloading\n    if (previous === null) {\n        originalScope.define(_function);\n    }\n    else if (previous.isFunction()) {\n        for (let link = previous.asFunction(); link !== null; link = link.previousOverload) {\n            if (!link.hasSameArgumentTypesAs(_function)) {\n                continue;\n            }\n            // Overloading by return type is not allowed\n            if (link.returnType.resolvedType !== _function.returnType.resolvedType) {\n                context.log.syntaxErrorDifferentReturnType(_function.returnType.range, _function.name, _function.returnType.resolvedType, link.returnType.resolvedType, link.returnType.range);\n            }\n            // Defining a function more than once is not allowed\n            else if (link.block !== null || !hasBlock) {\n                context.log.syntaxErrorDuplicateSymbolDefinition(_function.range, link.range);\n            }\n            // Merge the function with its forward declaration\n            else {\n                assert(link.sibling === null);\n                assert(_function.sibling === null);\n                link.sibling = _function;\n                _function.sibling = link;\n                _function.flags |= link.flags;\n                link.flags = _function.flags;\n            }\n            break;\n        }\n        // Use a singly-linked list to store the function overloads\n        _function.previousOverload = previous.asFunction();\n        originalScope.redefine(_function);\n    }\n    else {\n        context.log.syntaxErrorDuplicateSymbolDefinition(name, previous.range);\n        return null;\n    }\n    if (hasBlock) {\n        let old = context.flags;\n        context.flags &= ~(SymbolFlags.EXPORTED | SymbolFlags.IMPORTED);\n        _function.block = parseBlock(context);\n        context.flags &= old;\n        if (_function.block === null) {\n            return null;\n        }\n    }\n    context.popScope();\n    return Node.createFunction(_function).withRange(context.spanSince(type.range));\n}\nexport function parseArraySize(context, variable) {\n    let token = context.current();\n    if (context.eat(TokenKind.LEFT_BRACKET)) {\n        // The \"[]\" syntax isn't valid but skip over it and recover\n        if (context.eat(TokenKind.RIGHT_BRACKET)) {\n            context.log.syntaxErrorMissingArraySize(context.spanSince(token.range));\n            return true;\n        }\n        variable.arrayCount = pratt.parse(context, 0 /* LOWEST */);\n        if (variable.arrayCount === null || !context.expect(TokenKind.RIGHT_BRACKET)) {\n            return false;\n        }\n        // The array size must be resolved immediately\n        let count = 0;\n        context.resolver.resolveNode(variable.arrayCount);\n        context.resolver.checkConversion(variable.arrayCount, Type.INT);\n        if (variable.arrayCount.resolvedType !== Type.ERROR) {\n            let folded = fold(variable.arrayCount);\n            if (folded === null) {\n                context.log.syntaxErrorConstantRequired(variable.arrayCount.range);\n            }\n            else if (folded.kind === NodeKind.INT) {\n                let value = folded.asInt();\n                if (value < 1) {\n                    context.log.syntaxErrorInvalidArraySize(variable.arrayCount.range, value);\n                }\n                else {\n                    count = value;\n                }\n            }\n        }\n        // Multidimensional arrays are not supported\n        while (context.peek(TokenKind.LEFT_BRACKET)) {\n            token = context.next();\n            if (!context.peek(TokenKind.RIGHT_BRACKET) && pratt.parse(context, 0 /* LOWEST */) === null || !context.expect(TokenKind.RIGHT_BRACKET)) {\n                return false;\n            }\n            context.log.syntaxErrorMultidimensionalArray(context.spanSince(token.range));\n        }\n        variable.type = Node.createType(variable.type.resolvedType.arrayType(count)).withRange(variable.type.range);\n    }\n    return true;\n}\nexport function parseVariables(flags, type, name, context, comments) {\n    let variables = Node.createVariables(context.flags | flags, type);\n    while (true) {\n        let symbol = new VariableSymbol(context.compilationData.nextSymbolID(), name, name.toString(), context.scope(), context.scope().kind === 1 /* GLOBAL */ ? 1 /* GLOBAL */ : context.scope().kind === 4 /* STRUCT */ ? 3 /* STRUCT */ : 2 /* LOCAL */);\n        symbol.flags |= context.flags | flags;\n        symbol.comments = comments;\n        symbol.type = type;\n        // Array size\n        if (!parseArraySize(context, symbol)) {\n            return null;\n        }\n        // Initial value\n        let assign = context.current().range;\n        let value = null;\n        if (context.eat(TokenKind.ASSIGN)) {\n            let firstToken = context.current();\n            value = pratt.parse(context, 1 /* COMMA */);\n            if (value === null) {\n                value = Node.createParseError().withRange(context.spanSince(firstToken.range));\n            }\n        }\n        else {\n            assign = null;\n        }\n        // Constants must be resolved immediately\n        let variable = Node.createVariable(symbol, value).withRange(context.spanSince(symbol.range)).withInternalRange(assign);\n        symbol.node = variable;\n        if (symbol.isConst()) {\n            context.resolver.resolveNode(variable);\n        }\n        variables.appendChild(variable);\n        tryToDefineUniquelyInScope(context, symbol);\n        // Are there more variables in this statement?\n        if (!context.eat(TokenKind.COMMA)) {\n            context.expect(TokenKind.SEMICOLON);\n            return variables;\n        }\n        name = context.current().range;\n        if (!context.expect(TokenKind.IDENTIFIER)) {\n            return null;\n        }\n    }\n}\nexport function tryToDefineUniquelyInScope(context, symbol) {\n    let previous = StringMap_get3(context.scope().symbols, symbol.name, null);\n    if (previous !== null) {\n        context.log.syntaxErrorDuplicateSymbolDefinition(symbol.range, previous.range);\n        return false;\n    }\n    context.scope().define(symbol);\n    return true;\n}\nexport function parseStatements(context, parent, mode) {\n    while (!context.peek(TokenKind.END_OF_FILE) && !context.peek(TokenKind.RIGHT_BRACE)) {\n        let includeRange = context.current().range;\n        if (context.eat(TokenKind.INCLUDE)) {\n            if (mode !== 1 /* GLOBAL */) {\n                context.log.syntaxErrorIncludeOutsideGlobal(includeRange);\n                context.eat(TokenKind.STRING_LITERAL);\n                return false;\n            }\n            if (!parseInclude(context, parent)) {\n                return false;\n            }\n            continue;\n        }\n        let statement = parseStatement(context, mode);\n        if (statement === null) {\n            return false;\n        }\n        // Extension blocks are temporary and don't exist in the parsed result\n        if (statement.kind === NodeKind.MODIFIER_BLOCK) {\n            while (statement.hasChildren()) {\n                let child = statement.firstChild().remove();\n                checkStatementLocation(context, child);\n                parent.appendChild(child);\n            }\n        }\n        else {\n            checkStatementLocation(context, statement);\n            parent.appendChild(statement);\n        }\n    }\n    return true;\n}\nexport function parse(log, tokens, global, data, scope, resolver) {\n    if (pratt === null) {\n        pratt = createExpressionParser();\n    }\n    let processedIncludes = new Map();\n    let context = new ParserContext(log, tokens, data, resolver, processedIncludes);\n    context.pushScope(scope);\n    if (parseStatements(context, global, 1 /* GLOBAL */)) {\n        context.expect(TokenKind.END_OF_FILE);\n    }\n    return new ParseResult(context.includes);\n}\nexport let pratt = null;\nexport let _extensionBehaviors = StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(new Map(), 'disable', 1 /* DISABLE */), 'enable', 2 /* ENABLE */), 'require', 3 /* REQUIRE */), 'warn', 4 /* WARN */);\n// From https://www.khronos.org/registry/webgl/extensions/\nexport let _knownWebGLExtensions = StringMap_insert(StringMap_insert(StringMap_insert(StringMap_insert(new Map(), 'GL_OES_standard_derivatives', 0), 'GL_EXT_frag_depth', 0), 'GL_EXT_draw_buffers', 0), 'GL_EXT_shader_texture_lod', 0);\n","import { List_setLast } from \"../../native\";\nimport { List_last, List_takeLast } from \"../../native-js\";\nimport { NodeKind, NodeKind_isLoop } from \"./node\";\nexport class ControlFlowAnalyzer {\n    constructor() {\n        this._isLoopBreakTarget = [];\n        this._isControlFlowLive = [];\n    }\n    pushBlock(node) {\n        let parent = node.parent();\n        // Push control flow\n        this._isControlFlowLive.push(this._isControlFlowLive.length === 0 || List_last(this._isControlFlowLive));\n        // Push loop info\n        if (parent !== null && NodeKind_isLoop(parent.kind)) {\n            this._isLoopBreakTarget.push(false);\n        }\n    }\n    popBlock(node) {\n        let parent = node.parent();\n        // Pop control flow\n        let isLive = List_takeLast(this._isControlFlowLive);\n        if (isLive) {\n            node.hasControlFlowAtEnd = true;\n        }\n        // Pop loop info\n        if (parent !== null && NodeKind_isLoop(parent.kind) && !List_takeLast(this._isLoopBreakTarget) && (parent.kind === NodeKind.WHILE && parent.whileTest().isTrue() || parent.kind === NodeKind.DO_WHILE && parent.doWhileTest().isTrue() || parent.kind === NodeKind.FOR && (parent.forTest() === null || parent.forTest().isTrue()))) {\n            List_setLast(this._isControlFlowLive, false);\n        }\n    }\n    visitStatement(node) {\n        if (!List_last(this._isControlFlowLive)) {\n            return;\n        }\n        switch (node.kind) {\n            case NodeKind.BREAK: {\n                if (!(this._isLoopBreakTarget.length === 0)) {\n                    List_setLast(this._isLoopBreakTarget, true);\n                }\n                List_setLast(this._isControlFlowLive, false);\n                break;\n            }\n            case NodeKind.RETURN:\n            case NodeKind.DISCARD:\n            case NodeKind.CONTINUE: {\n                List_setLast(this._isControlFlowLive, false);\n                break;\n            }\n            case NodeKind.IF: {\n                let test = node.ifTest();\n                let trueValue = node.ifTrue();\n                let falseValue = node.ifFalse();\n                if (test.isTrue()) {\n                    if (!trueValue.hasControlFlowAtEnd) {\n                        List_setLast(this._isControlFlowLive, false);\n                    }\n                }\n                else if (test.isFalse() && falseValue !== null) {\n                    if (!falseValue.hasControlFlowAtEnd) {\n                        List_setLast(this._isControlFlowLive, false);\n                    }\n                }\n                else if (trueValue !== null && falseValue !== null) {\n                    if (!trueValue.hasControlFlowAtEnd && !falseValue.hasControlFlowAtEnd) {\n                        List_setLast(this._isControlFlowLive, false);\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n","import { List_first, List_get2, List_removeIf, StringMap_set2, assert, string_get5, string_slice2 } from \"../../native-js\";\nimport { API_NAME } from \"./api\";\nimport { ControlFlowAnalyzer } from \"./controlflow\";\nimport { fold } from \"./folder\";\nimport { Node, NodeKind, NodeKind_isBinary, NodeKind_isBinaryAssign, NodeKind_isExpression, NodeKind_isStatement, NodeKind_isUnary, NodeKind_isUnaryAssign } from \"./node\";\nimport { Range } from \"./range\";\nimport { strings, swizzleType } from \"./swizzle\";\nimport { Type } from \"./type\";\nexport class Resolver {\n    constructor(_log, _data) {\n        this._log = _log;\n        this._data = _data;\n        this._controlFlow = new ControlFlowAnalyzer();\n        this._versions = [];\n        this._generatedExtensions = new Map();\n        this._returnType = null;\n    }\n    resolveGlobal(global) {\n        this.resolveNode(global);\n        // Remove all version statements\n        for (const version of this._versions) {\n            version.remove();\n        }\n        // Re-insert the first version statement\n        let first = global.firstChild();\n        if (!(this._versions.length === 0)) {\n            global.insertChildBefore(first, List_first(this._versions));\n        }\n        // Insert all automatically generated extensions\n        for (const extension of Array.from(this._generatedExtensions.values())) {\n            global.insertChildBefore(first, extension);\n        }\n    }\n    _maybeMarkAsUnused(symbol) {\n        if (symbol.range.source.name !== API_NAME && symbol.useCount === 0 && !symbol.isExported()) {\n            this._log.unusedSymbols.push(symbol);\n        }\n    }\n    resolveNode(node) {\n        if (node.resolvedType !== null) {\n            return;\n        }\n        node.resolvedType = Type.ERROR;\n        let kind = node.kind;\n        switch (kind) {\n            case NodeKind.GLOBAL:\n            case NodeKind.STRUCT_BLOCK: {\n                this._resolveChildren(node);\n                break;\n            }\n            case NodeKind.VARIABLE: {\n                let symbol = node.symbol.asVariable();\n                this._maybeMarkAsUnused(symbol);\n                this.resolveNode(symbol.type);\n                // Variables must have a type\n                let type = symbol.type.resolvedType;\n                if (type === Type.VOID) {\n                    this._log.semanticErrorBadVariableType(symbol.type.range, type);\n                    type = Type.ERROR;\n                }\n                // Array size\n                if (symbol.arrayCount !== null) {\n                    this._resolveAsExpression(symbol.arrayCount);\n                    this.checkConversion(symbol.arrayCount, Type.INT);\n                }\n                // Initial value\n                if (symbol.value() !== null) {\n                    this._resolveAsExpression(symbol.value());\n                    this.checkConversion(symbol.value(), type);\n                    if (type.containsArray) {\n                        this._log.semanticErrorArrayAssignment(node.internalRange, type);\n                    }\n                }\n                // Constants must be initialized\n                if (symbol.isConst()) {\n                    if (symbol.value() !== null) {\n                        if (symbol.value().resolvedType !== Type.ERROR) {\n                            let folded = fold(symbol.value());\n                            if (folded === null) {\n                                this._log.syntaxErrorConstantRequired(symbol.value().range);\n                            }\n                            else {\n                                assert(folded.parent() === null);\n                                assert(folded.resolvedType !== null);\n                                symbol.constantValue = folded;\n                            }\n                        }\n                    }\n                    else if (symbol.kind === 2 /* LOCAL */) {\n                        this._log.semanticErrorUninitializedConstant(symbol.range);\n                    }\n                }\n                break;\n            }\n            case NodeKind.BLOCK: {\n                this._resolveBlockOrStatement(node);\n                break;\n            }\n            case NodeKind.BREAK:\n            case NodeKind.CONTINUE:\n            case NodeKind.DISCARD: {\n                break;\n            }\n            case NodeKind.DO_WHILE: {\n                this._resolveBlockOrStatement(node.doWhileBody());\n                this.resolveNode(node.doWhileTest());\n                this.checkConversion(node.doWhileTest(), Type.BOOL);\n                break;\n            }\n            case NodeKind.EXPRESSION: {\n                this.resolveNode(node.expressionValue());\n                break;\n            }\n            case NodeKind.EXTENSION: {\n                break;\n            }\n            case NodeKind.DEFINE: {\n                break;\n            }\n            case NodeKind.FOR: {\n                if (node.forSetup() !== null) {\n                    this._resolveAsExpression(node.forSetup());\n                }\n                if (node.forTest() !== null) {\n                    this._resolveAsExpression(node.forTest());\n                    this.checkConversion(node.forTest(), Type.BOOL);\n                }\n                if (node.forUpdate() !== null) {\n                    this._resolveAsExpression(node.forUpdate());\n                }\n                this._resolveBlockOrStatement(node.forBody());\n                break;\n            }\n            case NodeKind.FUNCTION: {\n                let symbol1 = node.symbol.asFunction();\n                this._maybeMarkAsUnused(symbol1);\n                for (const argument of symbol1._arguments) {\n                    this.resolveNode(argument.type);\n                }\n                this.resolveNode(symbol1.returnType);\n                if (symbol1.block !== null) {\n                    this._returnType = symbol1.returnType.resolvedType;\n                    this._resolveBlockOrStatement(symbol1.block);\n                    // Missing a return statement is an error\n                    if (this._returnType !== null && this._returnType !== Type.VOID && symbol1.block.hasControlFlowAtEnd) {\n                        this._log.semanticErrorMissingReturn(symbol1.range, symbol1.name, this._returnType);\n                    }\n                    this._returnType = null;\n                }\n                break;\n            }\n            case NodeKind.IF: {\n                this.resolveNode(node.ifTest());\n                this.checkConversion(node.ifTest(), Type.BOOL);\n                this._resolveBlockOrStatement(node.ifTrue());\n                if (node.ifFalse() !== null) {\n                    this._resolveBlockOrStatement(node.ifFalse());\n                }\n                break;\n            }\n            case NodeKind.PRECISION: {\n                break;\n            }\n            case NodeKind.RETURN: {\n                if (node.returnValue() !== null) {\n                    this.resolveNode(node.returnValue());\n                    this.checkConversion(node.returnValue(), this._returnType !== null ? this._returnType : Type.ERROR);\n                }\n                else {\n                    node.resolvedType = Type.VOID;\n                    this.checkConversion(node, this._returnType !== null ? this._returnType : Type.ERROR);\n                }\n                break;\n            }\n            case NodeKind.STRUCT: {\n                let symbol2 = node.symbol.asStruct();\n                this._maybeMarkAsUnused(symbol2);\n                this._resolveChildren(node);\n                // A struct loses operator \"==\" and \"!=\" when it contains a type without those operators\n                let resolvedType = symbol2.resolvedType();\n                for (const variable of symbol2.asStruct().variables) {\n                    let type1 = variable.type.resolvedType;\n                    if (type1.containsArray) {\n                        resolvedType.containsArray = true;\n                    }\n                    if (type1.containsSampler) {\n                        resolvedType.containsSampler = true;\n                    }\n                }\n                break;\n            }\n            case NodeKind.VARIABLES: {\n                this._resolveChildren(node);\n                break;\n            }\n            case NodeKind.VERSION: {\n                this._versions.push(node);\n                break;\n            }\n            case NodeKind.WHILE: {\n                this.resolveNode(node.whileTest());\n                this.checkConversion(node.whileTest(), Type.BOOL);\n                this._resolveBlockOrStatement(node.whileBody());\n                break;\n            }\n            case NodeKind.CALL: {\n                this._resolveCall(node);\n                break;\n            }\n            case NodeKind.DOT: {\n                this._resolveDot(node);\n                break;\n            }\n            case NodeKind.HOOK: {\n                let test = node.hookTest();\n                let no = node.hookFalse();\n                let yes = node.hookTrue();\n                this._resolveAsExpression(test);\n                this.checkConversion(test, Type.BOOL);\n                this._resolveAsExpression(yes);\n                this._resolveAsExpression(no);\n                if (yes.resolvedType !== no.resolvedType) {\n                    this._log.semanticErrorBadHookTypes(Range.span(yes.range, no.range), yes.resolvedType, no.resolvedType);\n                }\n                else if (yes.resolvedType.containsArray) {\n                    this._log.semanticErrorArrayHook(Range.span(yes.range, no.range), yes.resolvedType);\n                }\n                else {\n                    node.resolvedType = yes.resolvedType;\n                }\n                break;\n            }\n            case NodeKind.NAME: {\n                let symbol3 = node.symbol;\n                if (symbol3.isVariable()) {\n                    this.resolveNode(symbol3.asVariable().type);\n                    node.resolvedType = symbol3.asVariable().type.resolvedType;\n                }\n                else if (symbol3.isFunction() && !node.isCallTarget()) {\n                    this._log.semanticErrorMustCallFunction(node.range, symbol3.name);\n                }\n                else {\n                    node.resolvedType = symbol3.resolvedType();\n                }\n                // Make sure the extension is enabled if it hasn't been specified\n                let name = symbol3.requiredExtension;\n                if (name !== null && !this._generatedExtensions.has(name) && this._data.extensionBehavior(name) === 0 /* DEFAULT */) {\n                    StringMap_set2(this._generatedExtensions, name, Node.createExtension(name, 2 /* ENABLE */));\n                }\n                break;\n            }\n            case NodeKind.SEQUENCE: {\n                for (let child = node.firstChild(); child !== null; child = child.nextSibling()) {\n                    this._resolveAsExpression(child);\n                }\n                node.resolvedType = node.lastChild().resolvedType;\n                break;\n            }\n            default: {\n                if (NodeKind_isUnary(kind)) {\n                    this._resolveUnary(node);\n                }\n                else if (NodeKind_isBinary(kind)) {\n                    this._resolveBinary(node);\n                }\n                else {\n                    assert(false);\n                }\n                break;\n            }\n        }\n        assert(node.resolvedType !== null);\n    }\n    _resolveBlockOrStatement(node) {\n        assert(NodeKind_isStatement(node.kind));\n        this._controlFlow.pushBlock(node);\n        if (node.kind === NodeKind.BLOCK) {\n            for (let child = node.firstChild(); child !== null; child = child.nextSibling()) {\n                this.resolveNode(child);\n                this._controlFlow.visitStatement(child);\n            }\n        }\n        else {\n            this.resolveNode(node);\n            this._controlFlow.visitStatement(node);\n        }\n        this._controlFlow.popBlock(node);\n    }\n    _resolveUnary(node) {\n        let value = node.unaryValue();\n        this._resolveAsExpression(value);\n        if (NodeKind_isUnaryAssign(node.kind)) {\n            this._checkStorage(value);\n        }\n        let valueType = value.resolvedType;\n        switch (node.kind) {\n            case NodeKind.NEGATIVE:\n            case NodeKind.POSITIVE:\n            case NodeKind.PREFIX_DECREMENT:\n            case NodeKind.PREFIX_INCREMENT:\n            case NodeKind.POSTFIX_DECREMENT:\n            case NodeKind.POSTFIX_INCREMENT: {\n                node.resolvedType = valueType.isIntOrFloat() ? valueType : Type.ERROR;\n                break;\n            }\n            case NodeKind.NOT: {\n                node.resolvedType = valueType === Type.BOOL ? Type.BOOL : Type.ERROR;\n                break;\n            }\n        }\n        if (node.resolvedType === Type.ERROR && valueType !== Type.ERROR) {\n            this._log.semanticErrorBadUnaryOperator(node.internalRange, node.internalRange.toString(), valueType);\n        }\n    }\n    _resolveBinary(node) {\n        let left = node.binaryLeft();\n        let right = node.binaryRight();\n        this._resolveAsExpression(left);\n        this._resolveAsExpression(right);\n        if (NodeKind_isBinaryAssign(node.kind)) {\n            this._checkStorage(left);\n        }\n        let leftType = left.resolvedType;\n        let rightType = right.resolvedType;\n        let isSame = leftType === rightType;\n        switch (node.kind) {\n            case NodeKind.ADD:\n            case NodeKind.SUBTRACT:\n            case NodeKind.MULTIPLY:\n            case NodeKind.DIVIDE: {\n                node.resolvedType = isSame && leftType.componentType() !== null ? leftType : leftType.hasFloatComponents() && rightType === Type.FLOAT ? leftType : leftType.hasIntComponents() && rightType === Type.INT ? leftType : leftType === Type.FLOAT && rightType.hasFloatComponents() ? rightType : leftType === Type.INT && rightType.hasIntComponents() ? rightType : node.kind === NodeKind.MULTIPLY && (leftType === Type.VEC2 && rightType === Type.MAT2 || leftType === Type.MAT2 && rightType === Type.VEC2) ? Type.VEC2 : node.kind === NodeKind.MULTIPLY && (leftType === Type.VEC3 && rightType === Type.MAT3 || leftType === Type.MAT3 && rightType === Type.VEC3) ? Type.VEC3 : node.kind === NodeKind.MULTIPLY && (leftType === Type.VEC4 && rightType === Type.MAT4 || leftType === Type.MAT4 && rightType === Type.VEC4) ? Type.VEC4 : Type.ERROR;\n                break;\n            }\n            case NodeKind.EQUAL:\n            case NodeKind.NOT_EQUAL: {\n                node.resolvedType = isSame && leftType.canUseEqualityOperators() ? Type.BOOL : Type.ERROR;\n                break;\n            }\n            case NodeKind.LOGICAL_AND:\n            case NodeKind.LOGICAL_OR:\n            case NodeKind.LOGICAL_XOR: {\n                node.resolvedType = isSame && leftType === Type.BOOL ? Type.BOOL : Type.ERROR;\n                break;\n            }\n            case NodeKind.LESS_THAN:\n            case NodeKind.LESS_THAN_OR_EQUAL:\n            case NodeKind.GREATER_THAN:\n            case NodeKind.GREATER_THAN_OR_EQUAL: {\n                node.resolvedType = isSame && (leftType === Type.FLOAT || leftType === Type.INT) ? Type.BOOL : Type.ERROR;\n                break;\n            }\n            case NodeKind.ASSIGN: {\n                node.resolvedType = leftType;\n                if (leftType.containsArray) {\n                    this._log.semanticErrorArrayAssignment(node.internalRange, leftType);\n                }\n                this.checkConversion(right, leftType);\n                return;\n            }\n            case NodeKind.ASSIGN_ADD:\n            case NodeKind.ASSIGN_SUBTRACT:\n            case NodeKind.ASSIGN_MULTIPLY:\n            case NodeKind.ASSIGN_DIVIDE: {\n                node.resolvedType = isSame && leftType.componentType() !== null ? leftType : leftType.hasFloatComponents() && rightType === Type.FLOAT ? leftType : leftType.hasIntComponents() && rightType === Type.INT ? leftType : node.kind === NodeKind.ASSIGN_MULTIPLY && (leftType === Type.VEC2 && rightType === Type.MAT2 || leftType === Type.VEC3 && rightType === Type.MAT3 || leftType === Type.VEC4 && rightType === Type.MAT4) ? leftType : Type.ERROR;\n                break;\n            }\n            case NodeKind.INDEX: {\n                if (rightType === Type.INT) {\n                    let indexType = leftType.indexType();\n                    if (indexType !== null) {\n                        node.resolvedType = indexType;\n                    }\n                    // Run bounds checking on the constant-folded value\n                    let folded = fold(right);\n                    if (folded !== null && folded.kind === NodeKind.INT) {\n                        let value = folded.asInt();\n                        let count = leftType.indexCount();\n                        // Negative indices are always invalid even if the array size is unknown\n                        if (value < 0 || count !== 0 && value >= count) {\n                            this._log.semanticErrorOutOfBoundsIndex(right.range, value, leftType);\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        // If we get here, show an error about an invalid operator\n        if (node.resolvedType === Type.ERROR && leftType !== Type.ERROR && rightType !== Type.ERROR) {\n            if (node.kind === NodeKind.INDEX) {\n                this._log.semanticErrorBadIndex(node.internalRange, leftType, rightType);\n            }\n            else {\n                this._log.semanticErrorBadBinaryOperator(node.internalRange, node.internalRange.toString(), leftType, rightType);\n            }\n        }\n    }\n    _resolveCall(node) {\n        let callTarget = node.callTarget();\n        this.resolveNode(callTarget);\n        let type = callTarget.resolvedType;\n        let symbol = type.symbol;\n        let _arguments = [];\n        let hasError = false;\n        for (let child = callTarget.nextSibling(); child !== null; child = child.nextSibling()) {\n            this._resolveAsExpression(child);\n            _arguments.push(child);\n            if (child.resolvedType === Type.ERROR) {\n                hasError = true;\n            }\n        }\n        if (hasError) {\n            return;\n        }\n        if (symbol !== null) {\n            if (symbol.isFunction()) {\n                this._resolveFunctionOverloads(symbol.asFunction(), node, _arguments);\n                return;\n            }\n            if (symbol.isStruct()) {\n                this._resolveConstructor(type, node, _arguments);\n                return;\n            }\n        }\n        if (type !== Type.ERROR) {\n            this._log.semanticErrorBadCall(callTarget.range, type);\n        }\n    }\n    _resolveDot(node) {\n        let dotTarget = node.dotTarget();\n        let name = node.asString();\n        let range = node.internalRange;\n        this._resolveAsExpression(dotTarget);\n        if (name === '') {\n            // Ignore this case since the error was already reported\n            return;\n        }\n        let type = dotTarget.resolvedType;\n        let isAssignTarget = node.isAssignTarget();\n        let value = type;\n        if (value === Type.BVEC2 || value === Type.IVEC2 || value === Type.VEC2 || value === Type.BVEC3 || value === Type.IVEC3 || value === Type.VEC3 || value === Type.BVEC4 || value === Type.IVEC4 || value === Type.VEC4 || value === Type.UVEC2 || value === Type.UVEC3 || value === Type.UVEC4) {\n            node.resolvedType = this._validateSwizzle(range, type, name, isAssignTarget);\n        }\n        else if (value === Type.ERROR) {\n            // Ignore this case since the error was already reported\n        }\n        else {\n            if (type.symbol !== null && type.symbol.isStruct()) {\n                for (const variable of type.symbol.asStruct().variables) {\n                    if (variable.name === name) {\n                        node.symbol = variable;\n                        this.resolveNode(variable.type);\n                        node.resolvedType = variable.type.resolvedType;\n                        break;\n                    }\n                }\n            }\n            if (node.symbol === null) {\n                this._log.semanticErrorBadMember(range, type, name);\n            }\n        }\n    }\n    _resolveFunctionOverloads(overloaded, node, _arguments) {\n        let overloads = [];\n        // Collect all relevant overloads but ignore forward-declared functions that also have an implementation\n        for (let overload = overloaded; overload !== null; overload = overload.previousOverload) {\n            if (!(overloads.indexOf(overload.sibling) !== -1)) {\n                overloads.push(overload);\n            }\n        }\n        // Narrow down by argument count\n        if (overloads.length !== 1) {\n            overloads = overloads.slice();\n            List_removeIf(overloads, (overload) => {\n                return overload._arguments.length !== _arguments.length;\n            });\n            // Narrow down by argument types\n            if (overloads.length !== 1) {\n                let overloadsBeforeTypeFilter = overloads.slice();\n                List_removeIf(overloads, (overload) => {\n                    for (let i = 0, count = _arguments.length; i < count; i = i + 1) {\n                        if (List_get2(overload._arguments, i).type.resolvedType !== List_get2(_arguments, i).resolvedType) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n                // Narrow down by argument types with \"conversions\" to get better error messages\n                if (overloads.length !== 1) {\n                    overloads = overloadsBeforeTypeFilter;\n                    List_removeIf(overloads, (overload) => {\n                        for (let i = 0, count = _arguments.length; i < count; i = i + 1) {\n                            let from = List_get2(overload._arguments, i).type.resolvedType;\n                            let to = List_get2(_arguments, i).resolvedType;\n                            let fromSize = from.componentCount();\n                            let toSize = to.componentCount();\n                            if (from !== to && (fromSize === 0 || toSize === 0 || fromSize !== toSize)) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    });\n                }\n            }\n        }\n        // Match failure\n        if (overloads.length !== 1) {\n            this._log.semanticErrorBadOverloadMatch(node.callTarget().range, overloaded.name);\n            return;\n        }\n        // Match success\n        let overload1 = List_first(overloads);\n        if (overload1._arguments.length !== _arguments.length) {\n            this._log.semanticErrorArgumentCountFunction(node.internalRange, overload1._arguments.length, _arguments.length, overload1.name, overload1.range);\n        }\n        else {\n            for (let i = 0, count = _arguments.length; i < count; i = i + 1) {\n                this.checkConversion(List_get2(_arguments, i), List_get2(overload1._arguments, i).type.resolvedType);\n            }\n        }\n        node.callTarget().symbol = overload1;\n        node.resolvedType = overload1.returnType.resolvedType;\n    }\n    _resolveConstructor(type, node, _arguments) {\n        node.resolvedType = type;\n        if (type === Type.ERROR) {\n            return;\n        }\n        if (type.componentType() !== null) {\n            let count = type.componentCount();\n            let hasMatrixArgument = false;\n            // Visit each argument and make sure it's useful toward construction\n            let providedCount = 0;\n            for (const argument of _arguments) {\n                let argumentType = argument.resolvedType;\n                let deltaCount = argumentType.componentCount();\n                // Each type in a component-based types must be able to itself be unpacked into components\n                if (argumentType.componentType() === null) {\n                    if (argumentType !== Type.ERROR) {\n                        this._log.semanticErrorBadConstructorValue(argument.range, argumentType, type);\n                    }\n                    return;\n                }\n                // Passing extra values to a constructor is allowed sometimes\n                //\n                // Allowed:\n                //\n                //   vec3(vec4(1.0));\n                //   vec3(1.0, vec4(1.0));\n                //\n                // Not allowed:\n                //\n                //   vec3(vec4(1.0), 1.0);\n                //   vec3(vec3(1.0), vec3(1.0));\n                //\n                if (providedCount >= count) {\n                    this._log.semanticErrorExtraConstructorValue(argument.range, type, count, providedCount + deltaCount);\n                }\n                if (argumentType.isMatrix()) {\n                    hasMatrixArgument = true;\n                }\n                providedCount = providedCount + deltaCount;\n            }\n            // If a matrix argument is given to a matrix constructor, it is an error\n            // to have any other arguments\n            let isMatrixMatrixConstructor = type.isMatrix() && hasMatrixArgument;\n            if (isMatrixMatrixConstructor && _arguments.length !== 1) {\n                this._log.semanticErrorBadMatrixConstructor(node.internalRange);\n            }\n            // Validate the count (constructing a matrix using a matrix should always work)\n            else if (providedCount < count && providedCount !== 1 && !isMatrixMatrixConstructor) {\n                this._log.semanticErrorBadConstructorCount(node.internalRange, type, providedCount);\n            }\n            return;\n        }\n        let symbol = type.symbol.asStruct();\n        let variables = symbol.variables;\n        let variableCount = variables.length;\n        let argumentCount = _arguments.length;\n        // Validate argument count\n        if (variableCount !== argumentCount) {\n            this._log.semanticErrorArgumentCountConstructor(node.internalRange, variableCount, argumentCount, symbol.name, symbol.range);\n            return;\n        }\n        // Validate argument types\n        for (let i = 0, count1 = variableCount; i < count1; i = i + 1) {\n            this.checkConversion(List_get2(_arguments, i), List_get2(variables, i).type.resolvedType);\n        }\n    }\n    _validateSwizzle(range, type, name, isAssignTarget) {\n        let count = name.length;\n        if (count < 1 || count > 4) {\n            this._log.semanticErrorBadSwizzle(range, type, name);\n            return Type.ERROR;\n        }\n        let componentCount = type.componentCount();\n        for (const set of strings(componentCount)) {\n            if (set.indexOf(string_get5(name, 0)) !== -1) {\n                for (let i = 1, count1 = count; i < count1; i = i + 1) {\n                    if (!(set.indexOf(string_get5(name, i)) !== -1)) {\n                        this._log.semanticErrorBadSwizzle(range, type, name);\n                        return Type.ERROR;\n                    }\n                    if (isAssignTarget && string_slice2(name, 0, i).indexOf(string_get5(name, i)) !== -1) {\n                        this._log.semanticErrorBadSwizzleAssignment(range.slice(i, i + 1), string_get5(name, i));\n                        return Type.ERROR;\n                    }\n                }\n                return swizzleType(type.componentType(), count);\n            }\n        }\n        this._log.semanticErrorBadSwizzle(range, type, name);\n        return Type.ERROR;\n    }\n    _resolveAsExpression(node) {\n        this.resolveNode(node);\n        if (node.kind === NodeKind.TYPE && node.resolvedType !== Type.ERROR) {\n            this._log.semanticErrorUnexpectedType(node.range, node.resolvedType);\n            node.resolvedType = Type.ERROR;\n        }\n    }\n    _resolveChildren(node) {\n        for (let child = node.firstChild(); child !== null; child = child.nextSibling()) {\n            this.resolveNode(child);\n        }\n    }\n    _checkStorage(node) {\n        let n = node;\n        assert(NodeKind_isExpression(node.kind));\n        label: while (true) {\n            if (n.resolvedType === Type.ERROR) {\n                break;\n            }\n            switch (n.kind) {\n                case NodeKind.NAME: {\n                    if (n.symbol.isConst() || n.symbol.isUniform()) {\n                        this._log.semanticErrorBadStorage(node.range);\n                    }\n                    break label;\n                }\n                case NodeKind.DOT: {\n                    n = n.dotTarget();\n                    break;\n                }\n                case NodeKind.INDEX: {\n                    n = n.binaryLeft();\n                    break;\n                }\n                default: {\n                    this._log.semanticErrorBadStorage(node.range);\n                    break label;\n                }\n            }\n        }\n    }\n    checkConversion(node, type) {\n        if (node.resolvedType !== type && node.resolvedType !== Type.ERROR && type !== Type.ERROR) {\n            this._log.semanticErrorBadConversion(node.range, node.resolvedType, type);\n        }\n    }\n}\n","import { List_append2, StringMap_get3 } from \"../../native-js\";\nimport { Node } from \"./node\";\nimport { parse } from \"./parser\";\nimport { Resolver } from \"./resolver\";\nimport { Scope } from \"./scope\";\nimport { collectDefines, replaceDefines, tokenize } from \"./tokenizer\";\nexport class CompilerOptions {\n    constructor() {\n        this.compactSyntaxTree = true;\n        this.removeWhitespace = true;\n        this.runPreprocessor = true;\n        this.renameSymbols = 0 /* ALL */;\n        this.trimSymbols = true;\n        this.fileAccess = null;\n        this.globals = null;\n    }\n}\nexport class CompilerData {\n    constructor(fileAccess) {\n        this.currentExtensions = new Map();\n        this.fileAccess = fileAccess;\n        this._nextSymbolID = 0;\n    }\n    nextSymbolID() {\n        this._nextSymbolID = this._nextSymbolID + 1;\n        return this._nextSymbolID;\n    }\n    extensionBehavior(name) {\n        return StringMap_get3(this.currentExtensions, name, 0 /* DEFAULT */);\n    }\n}\nexport class TypeCheckResult {\n    constructor(global, includes) {\n        this.global = global;\n        this.includes = includes;\n    }\n}\nexport function rawTypeCheck(log, sources, options) {\n    if (options.runPreprocessor) {\n        for (const source of sources) {\n            collectDefines(log, source);\n        }\n        for (const source1 of sources) {\n            replaceDefines(log, source1);\n        }\n    }\n    for (const source2 of sources) {\n        if (source2.tokens === null) {\n            source2.tokens = tokenize(log, source2, 0 /* COMPILE */);\n        }\n    }\n    let global = Node.createGlobal();\n    let scope = new Scope(1 /* GLOBAL */, null);\n    let data = new CompilerData(options.fileAccess);\n    let resolver = new Resolver(log, data);\n    // Parse everything next\n    let includes = [];\n    for (const source3 of sources) {\n        let result = parse(log, source3.tokens, global, data, scope, resolver);\n        List_append2(includes, result.includes);\n    }\n    // Then run type checking\n    resolver.resolveGlobal(global);\n    // Always return even when there were errors since the partial result is still useful\n    return new TypeCheckResult(global, includes);\n}\n","import { string_slice1, string_slice2 } from \"../../native-js\";\nexport class Emitter {\n    static floatToString(value, mode) {\n        let text = value.toString();\n        // Check to see if exponential form is smaller\n        let exponential = value.toExponential();\n        if (exponential.length < text.length) {\n            text = exponential;\n        }\n        // Strip off the exponent\n        let e = text.indexOf('e');\n        let exponent = '';\n        if (e !== -1) {\n            exponent = string_slice1(text, e);\n            text = string_slice2(text, 0, e);\n        }\n        // 32-bit floating point only needs six digits\n        text = (+(+text).toFixed(6)).toString();\n        // Make sure there's a dot if there isn't an exponent\n        if (exponent === '' && !(text.indexOf('.') !== -1)) {\n            text += mode === 1 /* MINIFIED */ ? '.' : '.0';\n        }\n        // Strip the leading zero\n        if (mode === 1 /* MINIFIED */ && text.startsWith('0.') && text !== '0.') {\n            text = string_slice1(text, 1);\n        }\n        // Strip the leading zero with a minus sign\n        if (mode === 1 /* MINIFIED */ && text.startsWith('-0.') && text !== '-0.') {\n            text = '-' + string_slice1(text, 2);\n        }\n        // Put the exponent back\n        return text + exponent;\n    }\n}\n","import { int_compare1 } from \"../../native\";\nimport { List_first, List_get2, List_removeIf, List_set1, StringMap_get11, StringMap_set2, assert, string_compare2, string_get12, string_get5, string_slice2 } from \"../../native-js\";\nimport { Emitter } from \"./emitter\";\nimport { NodeKind } from \"./node\";\nimport { strings, swizzleType } from \"./swizzle\";\nimport { SymbolFlags_toString } from \"./symbol\";\nimport { Type } from \"./type\";\nexport class Tooltip {\n    constructor(code, documentation) {\n        this.code = code;\n        this.documentation = documentation;\n    }\n}\nexport class SymbolQuery {\n    constructor(source, index) {\n        this.source = source;\n        this.index = index;\n        this.resolvedType = null;\n        this.symbol = null;\n        this.range = null;\n        this.swizzleName = null;\n        this.swizzleType = null;\n    }\n    generateTooltip() {\n        if (this.swizzleName !== null) {\n            return new Tooltip(`${this.swizzleType} ${this.swizzleName};`, '');\n        }\n        if (this.symbol !== null) {\n            return new Tooltip(_tooltipForSymbol(this.symbol), _leadingCommentsToMarkdown(this.symbol.comments));\n        }\n        return null;\n    }\n    run(global) {\n        this._visit(global);\n    }\n    _touches(range) {\n        return range.source === this.source && range.touches(this.index);\n    }\n    _visitSymbol(query) {\n        if (this._touches(query.range)) {\n            this.resolvedType = query.resolvedType();\n            this.symbol = query;\n            this.range = query.range;\n            return true;\n        }\n        return false;\n    }\n    _visitVariable(variable) {\n        return this._visitSymbol(variable) || this._visit(variable.type) || this._visit(variable.arrayCount) || this._visit(variable.value());\n    }\n    _visitFunction(_function) {\n        for (const argument of _function._arguments) {\n            if (this._visitVariable(argument)) {\n                return true;\n            }\n        }\n        return this._visitSymbol(_function) || this._visit(_function.returnType) || this._visit(_function.block);\n    }\n    _visitStruct(struct) {\n        for (const variable of struct.variables) {\n            if (this._visitVariable(variable)) {\n                return true;\n            }\n        }\n        return this._visitSymbol(struct);\n    }\n    _visit(node) {\n        let ref;\n        if (node === null) {\n            return false;\n        }\n        for (let child = node.firstChild(); child !== null; child = child.nextSibling()) {\n            if (this._visit(child)) {\n                return true;\n            }\n        }\n        switch (node.kind) {\n            case NodeKind.NAME: {\n                if (this._touches(node.range)) {\n                    this.resolvedType = node.resolvedType;\n                    this.symbol = node.symbol;\n                    this.range = node.range;\n                    return true;\n                }\n                break;\n            }\n            case NodeKind.TYPE: {\n                if (this._touches(node.range)) {\n                    this.resolvedType = node.resolvedType;\n                    this.symbol = ((ref = this.resolvedType).isArrayOf !== null ? ref.isArrayOf : this.resolvedType).symbol;\n                    this.range = node.range;\n                    return true;\n                }\n                break;\n            }\n            case NodeKind.DOT: {\n                if (this._touches(node.internalRange)) {\n                    this.resolvedType = node.resolvedType;\n                    if (node.dotTarget().resolvedType.isVector()) {\n                        this.swizzleName = node.asString();\n                        this.swizzleType = node.resolvedType;\n                    }\n                    else {\n                        this.symbol = node.symbol;\n                    }\n                    this.range = node.internalRange;\n                    return true;\n                }\n                break;\n            }\n            case NodeKind.VARIABLE: {\n                return this._visitVariable(node.symbol.asVariable());\n            }\n            case NodeKind.FUNCTION: {\n                return this._visitFunction(node.symbol.asFunction());\n            }\n            case NodeKind.STRUCT: {\n                return this._visitStruct(node.symbol.asStruct());\n            }\n        }\n        return false;\n    }\n}\nexport class SymbolsQuery {\n    constructor(source) {\n        this.source = source;\n        this.symbols = [];\n    }\n    run(global) {\n        this._visit(global);\n    }\n    _visit(node) {\n        switch (node.kind) {\n            case NodeKind.STRUCT:\n            case NodeKind.FUNCTION: {\n                this._collectSymbol(node.symbol);\n                break;\n            }\n            case NodeKind.VARIABLES: {\n                for (let child = node.variablesType().nextSibling(); child !== null; child = child.nextSibling()) {\n                    assert(child.kind === NodeKind.VARIABLE);\n                    this._collectSymbol(child.symbol);\n                }\n                break;\n            }\n            case NodeKind.GLOBAL: {\n                for (let child1 = node.firstChild(); child1 !== null; child1 = child1.nextSibling()) {\n                    this._visit(child1);\n                }\n                break;\n            }\n        }\n    }\n    _collectSymbol(symbol) {\n        if (symbol.range !== null && symbol.range.source === this.source) {\n            this.symbols.push(symbol);\n        }\n    }\n}\nexport class RenameQuery {\n    constructor(source, index) {\n        this.source = source;\n        this.index = index;\n        this.ranges = [];\n        this.symbol = null;\n    }\n    run(global) {\n        let query = new SymbolQuery(this.source, this.index);\n        query.run(global);\n        this.symbol = query.symbol;\n        if (this.symbol !== null) {\n            this._visit(global);\n            // Remove overlapping ranges just in case\n            let current = null;\n            this.ranges.sort((a, b) => {\n                return a.source === b.source ? int_compare1(a.start, b.start) : string_compare2(a.source.name, b.source.name);\n            });\n            List_removeIf(this.ranges, (range) => {\n                let previous = current;\n                current = range;\n                return previous !== null && current.overlaps(previous);\n            });\n        }\n    }\n    _appendRange(range, check) {\n        // Sanity check the range to make sure it contains the target name\n        if (check === this.symbol && range !== null && range.toString() === this.symbol.name) {\n            this.ranges.push(range);\n        }\n    }\n    _visitVariable(variable) {\n        this._appendRange(variable.range, variable);\n        this._visit(variable.type);\n        this._visit(variable.arrayCount);\n        this._visit(variable.value());\n    }\n    _visitFunction(_function) {\n        this._appendRange(_function.range, _function);\n        this._appendRange(_function.range, _function.sibling);\n        this._visit(_function.returnType);\n        this._visit(_function.block);\n        for (const argument of _function._arguments) {\n            this._visitVariable(argument);\n        }\n    }\n    _visitStruct(struct) {\n        this._appendRange(struct.range, struct);\n        for (const variable of struct.variables) {\n            this._visitVariable(variable);\n        }\n    }\n    _visit(node) {\n        if (node !== null) {\n            for (let child = node.firstChild(); child !== null; child = child.nextSibling()) {\n                this._visit(child);\n            }\n            switch (node.kind) {\n                case NodeKind.NAME: {\n                    this._appendRange(node.range, node.symbol);\n                    break;\n                }\n                case NodeKind.DOT: {\n                    this._appendRange(node.internalRange, node.symbol);\n                    break;\n                }\n                case NodeKind.TYPE: {\n                    this._appendRange(node.range, node.resolvedType.symbol);\n                    break;\n                }\n                case NodeKind.VARIABLE: {\n                    this._visitVariable(node.symbol.asVariable());\n                    break;\n                }\n                case NodeKind.FUNCTION: {\n                    this._visitFunction(node.symbol.asFunction());\n                    break;\n                }\n                case NodeKind.STRUCT: {\n                    this._visitStruct(node.symbol.asStruct());\n                    break;\n                }\n            }\n        }\n    }\n}\nexport class Completion {\n    constructor(kind, name) {\n        this.kind = kind;\n        this.name = name;\n        this.detail = '';\n        this.documentation = '';\n    }\n}\nexport class CompletionQuery {\n    constructor(source, index) {\n        this.source = source;\n        this.index = index;\n        this._map = new Map();\n        this.completions = [];\n    }\n    run(global) {\n        this._addTextualCompletion('keyword', 'false');\n        this._addTextualCompletion('keyword', 'true');\n        this._addTextualCompletion('keyword', 'void');\n        for (const type of Type.BUILT_INS) {\n            this._addTextualCompletion('struct', type.symbol.name).detail = _tooltipForSymbol(type.symbol);\n        }\n        this._visit(global, true);\n    }\n    _touches(range) {\n        return range !== null && range.source === this.source && range.touches(this.index);\n    }\n    _addTextualCompletion(kind, name) {\n        let completion = null;\n        if (this._map.has(name)) {\n            completion = StringMap_get11(this._map, name);\n        }\n        else {\n            completion = new Completion(kind, name);\n            this.completions.push(completion);\n            StringMap_set2(this._map, name, completion);\n        }\n        return completion;\n    }\n    _addSymbolCompletion(symbol) {\n        let kind = symbol.isFunction() ? 'function' : symbol.isStruct() ? 'struct' : 'variable';\n        let completion = this._addTextualCompletion(kind, symbol.name);\n        if (completion.detail !== '') {\n            completion.detail += '\\n';\n        }\n        else {\n            completion.documentation = _leadingCommentsToMarkdown(symbol.comments);\n        }\n        completion.detail += _tooltipForSymbol(symbol);\n    }\n    _visit(node, isGlobal) {\n        if (node === null) {\n            return false;\n        }\n        let touches = this._touches(node.range);\n        switch (node.kind) {\n            case NodeKind.FUNCTION: {\n                this._addSymbolCompletion(node.symbol);\n                if (touches) {\n                    let _function = node.symbol.asFunction();\n                    this._addTextualCompletion('keyword', 'discard');\n                    this._addTextualCompletion('keyword', 'return');\n                    for (const arg of _function._arguments) {\n                        this._addSymbolCompletion(arg);\n                    }\n                    this._visit(_function.block, false);\n                }\n                break;\n            }\n            case NodeKind.VARIABLE: {\n                this._addSymbolCompletion(node.symbol);\n                break;\n            }\n            case NodeKind.STRUCT: {\n                this._addSymbolCompletion(node.symbol);\n                break;\n            }\n            case NodeKind.FOR:\n            case NodeKind.WHILE:\n            case NodeKind.DO_WHILE: {\n                if (touches) {\n                    this._addTextualCompletion('keyword', 'break');\n                    this._addTextualCompletion('keyword', 'continue');\n                }\n                break;\n            }\n            case NodeKind.DOT: {\n                let dotTarget = node.dotTarget();\n                if (touches && !this._touches(dotTarget.range)) {\n                    this.completions = [];\n                    let type = dotTarget.resolvedType;\n                    let value = type;\n                    if (value === Type.BVEC2 || value === Type.IVEC2 || value === Type.VEC2 || value === Type.BVEC3 || value === Type.IVEC3 || value === Type.VEC3 || value === Type.BVEC4 || value === Type.IVEC4 || value === Type.VEC4 || value === Type.UVEC2 || value === Type.UVEC3 || value === Type.UVEC4) {\n                        for (const set of strings(type.componentCount())) {\n                            for (let count = 1; count <= 4; count = count + 1) {\n                                let counters = [];\n                                for (let i = 0; i < count; i = i + 1) {\n                                    counters.push(0);\n                                }\n                                // Generate all valid permutations\n                                while (true) {\n                                    let name = '';\n                                    for (let i1 = 0; i1 < count; i1 = i1 + 1) {\n                                        name += string_get5(set, List_get2(counters, i1));\n                                    }\n                                    let symbol = swizzleType(type.componentType(), name.length).symbol;\n                                    this._addTextualCompletion('variable', name).detail = `${symbol.name} ${name};`;\n                                    // Increment and carry\n                                    let i2 = 0;\n                                    while (i2 < count) {\n                                        let counter = List_get2(counters, i2);\n                                        if ((counter = counter + 1) === set.length) {\n                                            counter = 0;\n                                        }\n                                        List_set1(counters, i2, counter);\n                                        if (counter !== 0) {\n                                            break;\n                                        }\n                                        i2 = i2 + 1;\n                                    }\n                                    if (i2 === count) {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if (type.symbol !== null && type.symbol.isStruct()) {\n                        for (const variable of type.symbol.asStruct().variables) {\n                            this._addSymbolCompletion(variable);\n                        }\n                    }\n                    return true;\n                }\n                break;\n            }\n        }\n        if (isGlobal || touches || node.kind === NodeKind.VARIABLES) {\n            for (let child = node.firstChild(); child !== null; child = child.nextSibling()) {\n                if (this._visit(child, false)) {\n                    return true;\n                }\n            }\n        }\n        return touches;\n    }\n}\nexport class Signature {\n    constructor(text, _arguments, documentation) {\n        this.text = text;\n        this._arguments = _arguments;\n        this.documentation = documentation;\n    }\n}\nexport class SignatureQuery {\n    constructor(source, index) {\n        this.source = source;\n        this.index = index;\n        this.signatures = [];\n        this.activeArgument = -1;\n        this.activeSignature = -1;\n    }\n    run(global) {\n        this._visit(global);\n    }\n    _touches(range) {\n        return range !== null && range.source === this.source && range.touches(this.index);\n    }\n    _visit(node) {\n        if (node === null) {\n            return false;\n        }\n        if (node.kind !== NodeKind.GLOBAL && !this._touches(node.range)) {\n            return false;\n        }\n        for (let child = node.firstChild(); child !== null; child = child.nextSibling()) {\n            if (this._visit(child)) {\n                return true;\n            }\n        }\n        switch (node.kind) {\n            case NodeKind.FUNCTION: {\n                this._visit(node.symbol.asFunction().block);\n                return true;\n            }\n            case NodeKind.CALL: {\n                let callTarget = node.callTarget();\n                if (!this._touches(callTarget.range)) {\n                    let firstArgument = callTarget.nextSibling();\n                    let type = callTarget.resolvedType;\n                    let symbol = type.symbol;\n                    let _arguments = [];\n                    for (let arg = firstArgument; arg !== null; arg = arg.nextSibling()) {\n                        _arguments.push(arg);\n                    }\n                    if (symbol.isFunction()) {\n                        let overloads = [];\n                        // Collect all relevant overloads but ignore forward-declared functions that also have an implementation\n                        for (let overload = symbol.asFunction(); overload !== null; overload = overload.previousOverload) {\n                            if (!(overloads.indexOf(overload.sibling) !== -1)) {\n                                overloads.push(overload);\n                            }\n                        }\n                        // Show overloads in source order\n                        overloads.reverse();\n                        for (const overload1 of overloads) {\n                            this.signatures.push(new Signature(_tooltipForSymbol(overload1), overload1._arguments.map((arg) => {\n                                return _variableTooltipText(arg);\n                            }), _leadingCommentsToMarkdown(overload1.comments)));\n                        }\n                        // Pick an active overload\n                        if (!(this.signatures.length === 0)) {\n                            this.activeSignature = 0;\n                            // Start off with all overloads\n                            let filteredOverloads = [];\n                            for (let i = 0; i < overloads.length; i = i + 1) {\n                                filteredOverloads.push(i);\n                            }\n                            // Try filtering by argument count\n                            for (let limit = _arguments.length; limit > 0; limit = limit - 1) {\n                                let nextFilteredOverloads = [];\n                                for (const index of filteredOverloads) {\n                                    if (List_get2(overloads, index)._arguments.length >= limit) {\n                                        nextFilteredOverloads.push(index);\n                                    }\n                                }\n                                if (!(nextFilteredOverloads.length === 0)) {\n                                    filteredOverloads = nextFilteredOverloads;\n                                    break;\n                                }\n                            }\n                            // Narrow down by argument types\n                            if (filteredOverloads.length > 1) {\n                                let nextFilteredOverloads1 = filteredOverloads.slice();\n                                List_removeIf(nextFilteredOverloads1, (overloadIndex) => {\n                                    let fromArguments = List_get2(overloads, overloadIndex)._arguments;\n                                    for (let i = 0, count = Math.min(fromArguments.length, _arguments.length); i < count; i = i + 1) {\n                                        let from = List_get2(fromArguments, i).type.resolvedType;\n                                        let to = List_get2(_arguments, i).resolvedType;\n                                        if (to !== Type.ERROR && from !== to) {\n                                            return true;\n                                        }\n                                    }\n                                    return false;\n                                });\n                                // Narrow down by argument types with \"conversions\" to get better error messages\n                                if (nextFilteredOverloads1.length === 0) {\n                                    nextFilteredOverloads1 = filteredOverloads.slice();\n                                    List_removeIf(nextFilteredOverloads1, (overloadIndex) => {\n                                        let fromArguments = List_get2(overloads, overloadIndex)._arguments;\n                                        for (let i = 0, count = Math.min(fromArguments.length, _arguments.length); i < count; i = i + 1) {\n                                            let from = List_get2(fromArguments, i).type.resolvedType;\n                                            let to = List_get2(_arguments, i).resolvedType;\n                                            let fromSize = from.componentCount();\n                                            let toSize = to.componentCount();\n                                            if (to !== Type.ERROR && from !== to && (fromSize === 0 || toSize === 0 || fromSize !== toSize)) {\n                                                return true;\n                                            }\n                                        }\n                                        return false;\n                                    });\n                                }\n                                if (!(nextFilteredOverloads1.length === 0)) {\n                                    filteredOverloads = nextFilteredOverloads1;\n                                }\n                            }\n                            if (!(filteredOverloads.length === 0)) {\n                                this.activeSignature = List_get2(filteredOverloads, 0);\n                            }\n                        }\n                    }\n                    if (symbol.isStruct() && type.componentType() === null) {\n                        // Generate the constructor call signature\n                        let fields = symbol.asStruct().variables.map((arg) => {\n                            return _variableTooltipText(arg);\n                        });\n                        this.signatures.push(new Signature(`${symbol.name}(${fields.join(', ')});`, fields, _leadingCommentsToMarkdown(symbol.comments)));\n                        this.activeSignature = 0;\n                    }\n                    // Compute the active argument index\n                    if (!(_arguments.length === 0)) {\n                        this.activeArgument = 0;\n                        for (const arg1 of _arguments) {\n                            if (this.index <= arg1.range.end || arg1.nextSibling() === null) {\n                                break;\n                            }\n                            this.activeArgument = this.activeArgument + 1;\n                        }\n                    }\n                    return true;\n                }\n                break;\n            }\n        }\n        return false;\n    }\n}\nexport function constantValueToString(node) {\n    switch (node.kind) {\n        case NodeKind.INT: {\n            return node.asInt().toString();\n        }\n        case NodeKind.BOOL: {\n            return node.asBool().toString();\n        }\n        case NodeKind.FLOAT: {\n            return Emitter.floatToString(node.asFloat(), 0 /* NORMAL */);\n        }\n        case NodeKind.CALL: {\n            assert(node.callTarget().kind === NodeKind.TYPE);\n            assert(node.callTarget().resolvedType === node.resolvedType);\n            let callTarget = node.callTarget();\n            let text = `${node.resolvedType}(`;\n            for (let child = callTarget.nextSibling(); child !== null; child = child.nextSibling()) {\n                if (child.previousSibling() !== callTarget) {\n                    text += ', ';\n                }\n                text += constantValueToString(child);\n            }\n            return text + ')';\n        }\n    }\n    return null;\n}\nexport function _tooltipForSymbol(symbol) {\n    if (symbol.isStruct()) {\n        let struct = symbol.asStruct();\n        let text = `${SymbolFlags_toString(struct.flags)}struct ${symbol.name}`;\n        if (!struct.isNative()) {\n            text += ' {\\n';\n            for (const variable of struct.variables) {\n                text += `  ${_variableTooltipText(variable)};\\n`;\n            }\n            text += '}';\n        }\n        return text + ';';\n    }\n    if (symbol.isVariable()) {\n        let variable1 = symbol.asVariable();\n        let text1 = _variableTooltipText(variable1);\n        if (variable1.constantValue !== null) {\n            let constantValue = constantValueToString(variable1.constantValue);\n            if (constantValue !== null) {\n                text1 += ' = ' + constantValue;\n            }\n        }\n        return text1 + ';';\n    }\n    if (symbol.isFunction()) {\n        let _function = symbol.asFunction();\n        let text2 = `${SymbolFlags_toString(_function.flags)}${_function.returnType.resolvedType} ${symbol.name}(`;\n        for (const argument of _function._arguments) {\n            if (argument !== List_first(_function._arguments)) {\n                text2 += ', ';\n            }\n            text2 += _variableTooltipText(argument);\n        }\n        return text2 + ');';\n    }\n    assert(false);\n    return null;\n}\nexport function _variableTooltipText(variable) {\n    let type = variable.type.resolvedType;\n    let text = `${SymbolFlags_toString(variable.flags)}${type.isArrayOf !== null ? type.isArrayOf : type} ${variable.name}`;\n    if (type.isArrayOf !== null) {\n        text += type.arrayCount !== 0 ? `[${type.arrayCount}]` : '[]';\n    }\n    return text;\n}\nexport function _leadingCommentsToMarkdown(comments) {\n    let markdown = '';\n    if (comments !== null) {\n        for (const comment of comments) {\n            let start = 0;\n            let end = comment.length;\n            // Remove the comment marker\n            if (comment.startsWith('//')) {\n                start = start + 2;\n            }\n            else if (comment.startsWith('/*')) {\n                start = start + 2;\n                end = end - 2;\n            }\n            // Trim leading and trailing whitespace\n            while (start < end && string_get12(comment, start) === 32) {\n                start = start + 1;\n            }\n            while (end > start && string_get12(comment, end - 1) === 32) {\n                end = end - 1;\n            }\n            // Append the comment content\n            if (markdown !== '') {\n                markdown += '\\n';\n            }\n            markdown += string_slice2(comment, start, end);\n        }\n    }\n    return markdown;\n}\n","import { List_last } from \"../../native-js\";\nimport { TokenKind } from \"./tokenizer\";\nexport var DiagnosticKind;\n(function (DiagnosticKind) {\n    DiagnosticKind[DiagnosticKind[\"ERROR\"] = 0] = \"ERROR\";\n    DiagnosticKind[DiagnosticKind[\"WARNING\"] = 1] = \"WARNING\";\n})(DiagnosticKind || (DiagnosticKind = {}));\nexport class Diagnostic {\n    constructor(kind, range, text) {\n        this.kind = kind;\n        this.range = range;\n        this.text = text;\n        this.noteRange = null;\n        this.noteText = '';\n    }\n}\nexport class Log {\n    constructor() {\n        this.diagnostics = [];\n        this.unusedSymbols = [];\n        this.defines = new Map();\n        this.warningCount = 0;\n        this.errorCount = 0;\n        this._prevErrorRange = null;\n    }\n    error(range, text) {\n        if (this._prevErrorRange !== null && this._prevErrorRange.start === range.start) {\n            return; // Don't double-report errors in the same spot\n        }\n        this._prevErrorRange = range;\n        this.diagnostics.push(new Diagnostic(DiagnosticKind.ERROR, range, text));\n        this.errorCount = this.errorCount + 1;\n    }\n    warning(range, text) {\n        this.diagnostics.push(new Diagnostic(DiagnosticKind.WARNING, range, text));\n        this.warningCount = this.warningCount + 1;\n    }\n    note(range, text) {\n        let last = List_last(this.diagnostics);\n        last.noteRange = range;\n        last.noteText = text;\n    }\n    syntaxWarningUnknownExtension(range, name) {\n        this.warning(range, `The extension \"${name}\" is not in the known list of valid WebGL extensions`);\n    }\n    syntaxErrorInvalidString(range) {\n        this.error(range, 'Invalid string literal');\n    }\n    syntaxErrorDisabledExtension(range, name, extension) {\n        this.error(range, `Cannot use \"${name}\" from disabled extension \"${extension}\"`);\n    }\n    syntaxErrorExtraData(range, text) {\n        this.error(range, `Syntax error \"${text}\"`);\n    }\n    syntaxErrorReservedWord(range) {\n        this.error(range, `\"${range}\" is a reserved word`);\n    }\n    syntaxErrorUnexpectedToken(token) {\n        this.error(token.range, `Unexpected ${TokenKind[token.kind]}`);\n    }\n    syntaxErrorExpectedToken1(range, expected) {\n        this.error(range, `Expected ${TokenKind[expected]}`);\n    }\n    syntaxErrorExpectedToken2(range, found, expected) {\n        this.error(range, `Expected ${TokenKind[expected]} but found ${TokenKind[found]}`);\n    }\n    syntaxErrorBadSymbolReference(range) {\n        this.error(range, `There is no symbol called \"${range}\" in the current scope`);\n    }\n    syntaxErrorDuplicateSymbolDefinition(range, previous) {\n        this.error(range, `There is already a symbol called \"${range}\" in the current scope`);\n        this.note(previous, `The previous definition of \"${previous}\" is here`);\n    }\n    syntaxErrorOutsideLoop(range) {\n        this.error(range, 'This statement cannot be used outside a loop');\n    }\n    syntaxErrorStructVariableInitializer(range) {\n        this.error(range, 'Cannot initialize struct variables');\n    }\n    syntaxErrorInsideStruct(range) {\n        this.error(range, 'This statement cannot be used inside a struct');\n    }\n    syntaxErrorInsideFunction(range) {\n        this.error(range, 'This statement cannot be used inside a function');\n    }\n    syntaxErrorOutsideFunction(range) {\n        this.error(range, 'This statement cannot be used outside a function');\n    }\n    syntaxErrorIncludeOutsideGlobal(range) {\n        this.error(range, '\"#include\" statements cannot be used here');\n    }\n    semanticErrorIncludeWithoutFileAccess(range) {\n        this.error(range, 'Cannot include files without access to a file system');\n    }\n    semanticErrorIncludeBadPath(range, path) {\n        this.error(range, `Cannot read the file ${JSON.stringify(path)}`);\n    }\n    syntaxErrorDifferentReturnType(range, name, type, expected, previous) {\n        this.error(range, `Cannot change the return type of \"${name}\" to type \"${type}\"`);\n        this.note(previous, `The forward declaration of \"${name}\" has a return type of \"${expected}\"`);\n    }\n    syntaxErrorBadQualifier(range) {\n        this.error(range, 'Cannot use this qualifier here');\n    }\n    syntaxErrorConstantRequired(range) {\n        this.error(range, 'This value must be a compile-time constant');\n    }\n    syntaxErrorInvalidArraySize(range, count) {\n        this.error(range, `Cannot declare an array with a size of \"${count}\"`);\n    }\n    syntaxErrorMissingArraySize(range) {\n        this.error(range, 'All array sizes must be specified');\n    }\n    syntaxErrorMultidimensionalArray(range) {\n        this.error(range, 'Multidimensional arrays are not a part of the language');\n    }\n    syntaxErrorInvalidOperator(range) {\n        this.error(range, `The operator \"${range}\" is reserved and cannot be used`);\n    }\n    semanticErrorBadConversion(range, from, to) {\n        this.error(range, `Cannot convert from type \"${from}\" to type \"${to}\"`);\n    }\n    semanticErrorUnexpectedType(range, type) {\n        this.error(range, `Unexpected type \"${type}\"`);\n    }\n    semanticErrorBadVariableType(range, type) {\n        this.error(range, `Cannot create a variable of type \"${type}\"`);\n    }\n    semanticErrorBadMember(range, type, name) {\n        this.error(range, `Cannot find \"${name}\" on type \"${type}\"`);\n    }\n    semanticErrorBadSwizzle(range, type, name) {\n        this.error(range, `Invalid swizzle \"${name}\" on type \"${type}\"`);\n    }\n    semanticErrorBadSwizzleAssignment(range, field) {\n        this.error(range, `The field \"${field}\" cannot be specified multiple times when used as a storage location`);\n    }\n    semanticErrorMustCallFunction(range, name) {\n        this.error(range, `The function \"${name}\" must be called`);\n    }\n    semanticErrorBadCall(range, type) {\n        this.error(range, `Cannot call type \"${type}\"`);\n    }\n    semanticErrorBadConstructorValue(range, type, constructor) {\n        this.error(range, `Cannot use value of type \"${type}\" when constructing type \"${constructor}\"`);\n    }\n    semanticErrorExtraConstructorValue(range, type, count, total) {\n        this.error(range, `The constructor for type \"${type}\" only takes ${count} argument${Log.plural(count)} and this argument would bring the total to ${total}`);\n    }\n    semanticErrorBadConstructorCount(range, type, count) {\n        this.error(range, `Cannot construct type \"${type}\" with ${count} argument${Log.plural(count)}`);\n    }\n    semanticErrorArgumentCountFunction(range, expected, found, name, _function) {\n        this.error(range, `Expected ${expected} argument${Log.plural(expected)} but found ${found} argument${Log.plural(found)} when calling function \"${name}\"`);\n        if (_function !== null) {\n            this.note(_function, `The definition of function \"${name}\" is here`);\n        }\n    }\n    semanticErrorArgumentCountConstructor(range, expected, found, name, struct) {\n        this.error(range, `Expected ${expected} argument${Log.plural(expected)} but found ${found} argument${Log.plural(found)} when constructing type \"${name}\"`);\n        if (struct !== null) {\n            this.note(struct, `The definition of struct \"${name}\" is here`);\n        }\n    }\n    semanticErrorBadOverloadMatch(range, name) {\n        this.error(range, `No matching overload for function \"${name}\"`);\n    }\n    semanticErrorBadHookTypes(range, left, right) {\n        this.error(range, `Cannot merge type \"${left}\" and type \"${right}\"`);\n    }\n    semanticErrorArrayHook(range, type) {\n        if (type.isArrayOf !== null) {\n            this.error(range, `Cannot use a conditional expression with array type \"${type}\"`);\n        }\n        else {\n            this.error(range, `Cannot use a conditional expression with type \"${type}\" because it contains an array`);\n        }\n    }\n    semanticErrorArrayAssignment(range, type) {\n        if (type.isArrayOf !== null) {\n            this.error(range, `Cannot assign to array type \"${type}\"`);\n        }\n        else {\n            this.error(range, `Cannot assign to type \"${type}\" because it contains an array`);\n        }\n    }\n    semanticErrorBadUnaryOperator(range, operator, type) {\n        this.error(range, `No unary operator \"${operator}\" for type \"${type}\"`);\n    }\n    semanticErrorBadBinaryOperator(range, operator, left, right) {\n        if (left === right) {\n            this.error(range, `There is no operator \"${operator}\" defined for type \"${left}\"`);\n        }\n        else {\n            this.error(range, `No binary operator \"${operator}\" for type \"${left}\" and type \"${right}\"`);\n        }\n    }\n    semanticErrorBadIndex(range, left, right) {\n        this.error(range, `No index operator for type \"${left}\" and type \"${right}\"`);\n    }\n    semanticErrorOutOfBoundsIndex(range, value, type) {\n        this.error(range, `Index \"${value}\" is out of bounds for type \"${type}\"`);\n    }\n    semanticErrorBadStorage(range) {\n        this.error(range, 'Cannot store to this location');\n    }\n    semanticErrorUninitializedConstant(range) {\n        this.error(range, 'Constants must be initialized');\n    }\n    semanticErrorMissingReturn(range, name, type) {\n        this.error(range, `All control paths for \"${name}\" must return a value of type \"${type}\"`);\n    }\n    semanticErrorBadMatrixConstructor(range) {\n        this.error(range, 'If a matrix argument is given to a matrix constructor, it is an error to have any other arguments');\n    }\n    static plural(value) {\n        return value !== 1 ? 's' : '';\n    }\n}\n","import { List_get2, string_get12 } from \"../../native-js\";\nimport { Range } from \"./range\";\nexport class LineColumn {\n    constructor(line, column) {\n        this.line = line;\n        this.column = column;\n    }\n}\nexport class Source {\n    constructor(name, contents) {\n        this.name = name;\n        this.contents = contents;\n        this.tokens = null;\n        this._lineOffsets = null;\n    }\n    entireRange() {\n        return new Range(this, 0, this.contents.length);\n    }\n    indexToLineColumn(index) {\n        this._computeLineOffsets();\n        // Binary search to find the line\n        let count = this._lineOffsets.length;\n        let line = 0;\n        while (count > 0) {\n            let step = count / 2 | 0;\n            let i = line + step;\n            if (List_get2(this._lineOffsets, i) <= index) {\n                line = i + 1;\n                count = count - step - 1;\n            }\n            else {\n                count = step;\n            }\n        }\n        // Use the line to compute the column\n        let column = line > 0 ? index - List_get2(this._lineOffsets, line - 1) : index;\n        return new LineColumn(line - 1, column);\n    }\n    lineColumnToIndex(line, column) {\n        this._computeLineOffsets();\n        if (line >= 0 && line < this._lineOffsets.length) {\n            let index = List_get2(this._lineOffsets, line);\n            if (column >= 0 && index + column < (line + 1 < this._lineOffsets.length ? List_get2(this._lineOffsets, line + 1) : this.contents.length)) {\n                return index + column;\n            }\n        }\n        return -1;\n    }\n    _computeLineOffsets() {\n        if (this._lineOffsets === null) {\n            this._lineOffsets = [0];\n            for (let i = 0, count = this.contents.length; i < count; i = i + 1) {\n                if (string_get12(this.contents, i) === 10) {\n                    this._lineOffsets.push(i + 1);\n                }\n            }\n        }\n    }\n}\n","import { __asString } from \"../../native-js\";\nimport { API_NAME } from \"../core/api\";\nimport { CompilerOptions, rawTypeCheck } from \"../core/compiler\";\nimport { CompletionQuery, RenameQuery, SignatureQuery, SymbolQuery, SymbolsQuery, Tooltip } from \"../core/ide\";\nimport { DiagnosticKind, Log } from \"../core/log\";\nimport { Source } from \"../core/source\";\nexport function sourcesFromInput(input) {\n    if (typeof input === 'string') {\n        return [new Source('<stdin>', input)];\n    }\n    if (Array.isArray(input)) {\n        let sources = [];\n        for (let i = 0, count = input.length; i < count; i = i + 1) {\n            let item = input[i];\n            sources.push(new Source(__asString(item.name), __asString(item.contents)));\n        }\n        return sources;\n    }\n    return [new Source(__asString(input.name), __asString(input.contents))];\n}\nexport function wrapFileAccess(callback) {\n    return (filePath, relativeTo) => {\n        let result = callback(filePath, relativeTo);\n        if (typeof result === 'string') {\n            return new Source(filePath, result);\n        }\n        if (!result) {\n            return null;\n        }\n        let name = result.name;\n        let contents = result.contents;\n        if (typeof name === 'string' && typeof contents === 'string') {\n            return new Source(name, contents);\n        }\n        throw new Error('Invalid file access result');\n    };\n}\nexport function main() {\n    let _this = (() => {\n        return this;\n    })();\n    // @ts-ignore:next-line\n    let root = typeof (exports) !== 'undefined' ? exports : _this.GLSLX = {};\n    root.compileIDE = compileIDE;\n}\nexport let rangeToJSON = (range) => {\n    if (range === null) {\n        return null;\n    }\n    let source = range.source;\n    let start = source.indexToLineColumn(range.start);\n    let end = source.indexToLineColumn(range.end);\n    return {\n        'source': source.name,\n        'start': {\n            'line': start.line,\n            'column': start.column,\n        },\n        'end': {\n            'line': end.line,\n            'column': end.column,\n        },\n    };\n};\n// Do a compile that can have queries done on it later\nexport let compileIDE = (input, args) => {\n    args = args || {};\n    let sources = sourcesFromInput(input);\n    let state = null;\n    let result = null;\n    let log = null;\n    let options = new CompilerOptions();\n    if (args.fileAccess) {\n        options.fileAccess = wrapFileAccess(args.fileAccess);\n    }\n    let handleTooltipQuery = (message) => {\n        let ref;\n        let name = message.source + '';\n        let line = message.line | 0;\n        let column = message.column | 0;\n        let ignoreDiagnostics = !!message.ignoreDiagnostics;\n        let range = null;\n        let tooltip = null;\n        let symbol = null;\n        for (const source of sources) {\n            if (source.name === name) {\n                let index = source.lineColumnToIndex(line, column);\n                if (index !== -1) {\n                    // Search diagnostics first\n                    if (!ignoreDiagnostics && log !== null) {\n                        for (const diagnostic of log.diagnostics) {\n                            if (diagnostic.range !== null && diagnostic.range.source === source && diagnostic.range.touches(index)) {\n                                tooltip = new Tooltip(diagnostic.text, '');\n                                range = diagnostic.range;\n                                break;\n                            }\n                        }\n                    }\n                    // Search the syntax tree next\n                    if (tooltip === null && result !== null) {\n                        let query = new SymbolQuery(source, index);\n                        query.run(result.global);\n                        tooltip = query.generateTooltip();\n                        if (tooltip !== null) {\n                            range = query.range;\n                            symbol = (ref = query.symbol) !== null ? ref.name : null;\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        return {\n            'tooltip': tooltip !== null ? tooltip.code : null,\n            'range': rangeToJSON(range),\n            'symbol': symbol,\n            'documentation': tooltip !== null ? tooltip.documentation : null,\n        };\n    };\n    let handleDefinitionQuery = (message) => {\n        let name = message.source + '';\n        let line = message.line | 0;\n        let column = message.column | 0;\n        let range = null;\n        let definition = null;\n        let symbol = null;\n        // Allow go-to-definition on #include statements\n        for (const include of result.includes) {\n            if (include.originalRange.source.name === name) {\n                let index = include.originalRange.source.lineColumnToIndex(line, column);\n                if (index !== -1 && include.originalRange.touches(index)) {\n                    return {\n                        'definition': rangeToJSON(include.includedRange),\n                        'range': rangeToJSON(include.originalRange),\n                        'symbol': include.includedRange.source.name,\n                    };\n                }\n            }\n        }\n        for (const source of sources) {\n            if (source.name === name) {\n                let index1 = source.lineColumnToIndex(line, column);\n                if (index1 !== -1 && result !== null) {\n                    let query = new SymbolQuery(source, index1);\n                    query.run(result.global);\n                    if (query.symbol !== null && query.symbol.range !== null && query.symbol.range.source.name !== API_NAME) {\n                        definition = query.symbol.range;\n                        range = query.range;\n                        symbol = query.symbol.name;\n                    }\n                }\n                break;\n            }\n        }\n        return {\n            'definition': rangeToJSON(definition),\n            'range': rangeToJSON(range),\n            'symbol': symbol,\n        };\n    };\n    let handleSymbolsQuery = (message) => {\n        let name = message.source + '';\n        let symbols = null;\n        for (const source of sources) {\n            if (source.name === name) {\n                if (result !== null) {\n                    let query = new SymbolsQuery(source);\n                    query.run(result.global);\n                    symbols = query.symbols.map((symbol) => {\n                        return {\n                            'name': symbol.name,\n                            'kind': symbol.isVariable() ? 'variable' : symbol.isFunction() ? 'function' : symbol.isStruct() ? 'struct' : null,\n                            'range': rangeToJSON(symbol.range),\n                        };\n                    });\n                }\n                break;\n            }\n        }\n        return {\n            'symbols': symbols,\n        };\n    };\n    let handleRenameQuery = (message) => {\n        let name = message.source + '';\n        let line = message.line | 0;\n        let column = message.column | 0;\n        let ranges = null;\n        let symbol = null;\n        for (const source of sources) {\n            if (source.name === name) {\n                let index = source.lineColumnToIndex(line, column);\n                if (index !== -1 && result !== null) {\n                    let renameQuery = new RenameQuery(source, index);\n                    renameQuery.run(result.global);\n                    if (renameQuery.symbol !== null && renameQuery.symbol.range !== null && renameQuery.symbol.range.source.name !== API_NAME) {\n                        ranges = renameQuery.ranges.map(rangeToJSON);\n                        symbol = renameQuery.symbol.name;\n                    }\n                }\n                break;\n            }\n        }\n        return {\n            'ranges': ranges,\n            'symbol': symbol,\n        };\n    };\n    let handleCompletionQuery = (message) => {\n        let name = message.source + '';\n        let line = message.line | 0;\n        let column = message.column | 0;\n        let completions = [];\n        for (const source of sources) {\n            if (source.name === name) {\n                let index = source.lineColumnToIndex(line, column);\n                if (index !== -1 && result !== null) {\n                    let completionQuery = new CompletionQuery(source, index);\n                    completionQuery.run(result.global);\n                    completions = completionQuery.completions.map((completion) => {\n                        return {\n                            'kind': completion.kind,\n                            'name': completion.name,\n                            'detail': completion.detail,\n                            'documentation': completion.documentation,\n                        };\n                    });\n                }\n            }\n        }\n        return {\n            'completions': completions,\n        };\n    };\n    let handleSignatureQuery = (message) => {\n        let name = message.source + '';\n        let line = message.line | 0;\n        let column = message.column | 0;\n        let signatures = [];\n        let activeArgument = -1;\n        let activeSignature = -1;\n        for (const source of sources) {\n            if (source.name === name) {\n                let index = source.lineColumnToIndex(line, column);\n                if (index !== -1 && result !== null) {\n                    let signatureQuery = new SignatureQuery(source, index);\n                    signatureQuery.run(result.global);\n                    activeArgument = signatureQuery.activeArgument;\n                    activeSignature = signatureQuery.activeSignature;\n                    signatures = signatureQuery.signatures.map((signature) => {\n                        return {\n                            'text': signature.text,\n                            'arguments': signature._arguments,\n                            'documentation': signature.documentation,\n                        };\n                    });\n                }\n            }\n        }\n        return {\n            'signatures': signatures,\n            'activeArgument': activeArgument,\n            'activeSignature': activeSignature,\n        };\n    };\n    let updateState = () => {\n        log = new Log();\n        result = rawTypeCheck(log, sources, options);\n        state.unusedSymbols = log.unusedSymbols.map((symbol) => {\n            return {\n                'name': symbol.name,\n                'range': rangeToJSON(symbol.range),\n            };\n        });\n        state.diagnostics = log.diagnostics.map((diagnostic) => {\n            return {\n                'kind': DiagnosticKind[diagnostic.kind].toLowerCase(),\n                'range': rangeToJSON(diagnostic.range),\n                'text': diagnostic.text,\n            };\n        });\n        state.log = log;\n    };\n    state = {\n        'log': log,\n        'result': result,\n        'updateState': updateState,\n        'unusedSymbols': null,\n        'diagnostics': null,\n        'sources': sources,\n        'tooltipQuery': handleTooltipQuery,\n        'definitionQuery': handleDefinitionQuery,\n        'symbolsQuery': handleSymbolsQuery,\n        'renameQuery': handleRenameQuery,\n        'completionQuery': handleCompletionQuery,\n        'signatureQuery': handleSignatureQuery,\n    };\n    updateState();\n    return state;\n};\n"],"sourceRoot":""}