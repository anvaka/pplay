(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-4949eea6"],{"6a2f":function(e,t){e.exports="import {\n// Converts a quantity specified in degrees into radians. The return value is `π  * degrees / 180`\nfloat radians(float degrees);\n\n// Converts a quantity specified in degrees into radians. The return value is `π  * degrees / 180`\nvec2 radians(vec2 degrees);\n\n// Converts a quantity specified in degrees into radians. The return value is `π  * degrees / 180`\nvec3 radians(vec3 degrees);\n\n// Converts a quantity specified in degrees into radians. The return value is `π  * degrees / 180`\nvec4 radians(vec4 degrees);\n\n// Converts a quantity specified in radians into degrees. The return value is `180 * radians / π`\nfloat degrees(float radians);\n\n// Converts a quantity specified in radians into degrees. The return value is `180 * radians / π`\nvec2 degrees(vec2 radians);\n\n// Converts a quantity specified in radians into degrees. The return value is `180 * radians / π`\nvec3 degrees(vec3 radians);\n\n// Converts a quantity specified in radians into degrees. The return value is `180 * radians / π`\nvec4 degrees(vec4 radians);\n\n// `sin` returns the trigonometric sine of `angle`.\nfloat sin(float angle);\n\n// `sin` returns the trigonometric sine of `angle`.\nvec2 sin(vec2 angle);\n\n// `sin` returns the trigonometric sine of `angle`.\nvec3 sin(vec3 angle);\n\n// `sin` returns the trigonometric sine of `angle`.\nvec4 sin(vec4 angle);\n\n// `cos` returns the trigonometric cosine of `angle`.\nfloat cos(float angle);\n\n// `cos` returns the trigonometric cosine of `angle`.\nvec2 cos(vec2 angle);\n\n// `cos` returns the trigonometric cosine of `angle`.\nvec3 cos(vec3 angle);\n\n// `cos` returns the trigonometric cosine of `angle`.\nvec4 cos(vec4 angle);\n\n// `tan` returns the trigonometric tangent of `angle`.\nfloat tan(float angle);\n\n// `tan` returns the trigonometric tangent of `angle`.\nvec2 tan(vec2 angle);\n\n// `tan` returns the trigonometric tangent of `angle`.\nvec3 tan(vec3 angle);\n\n// `tan` returns the trigonometric tangent of `angle`.\nvec4 tan(vec4 angle);\n\n// Returns the arcsine of a parameter. The range of values is -π/2 to π/2.\nfloat asin(float x);\n\n// Returns the arcsine of a parameter. The range of values is -π/2 to π/2.\nvec2 asin(vec2 x);\n\n// Returns the arcsine of a parameter. The range of values is -π/2 to π/2.\nvec3 asin(vec3 x);\n\n// Returns the arcsine of a parameter. The range of values is -π/2 to π/2.\nvec4 asin(vec4 x);\n\n// Returns the arccosine of a parameter. The range of values is 0 to π.\nfloat acos(float x);\n\n// Returns the arccosine of a parameter. The range of values is 0 to π.\nvec2 acos(vec2 x);\n\n// Returns the arccosine of a parameter. The range of values is 0 to π.\nvec3 acos(vec3 x);\n\n// Returns the arccosine of a parameter. The range of values is 0 to π.\nvec4 acos(vec4 x);\n\n// Returns the angle whose trigonometric arctangent is `y/x`.\n// The signs of `y` and `x` are used to determine the quadrant that the angle lies in. \n// The value returned by atan in this case is in the range `[-π, π]`. The result is undefined if `x = 0`\nfloat atan(float y, float x);\n\n// Returns the angle whose trigonometric arctangent is `y/x`.\n// The signs of `y` and `x` are used to determine the quadrant that the angle lies in. \n// The value returned by atan in this case is in the range `[-π, π]`. The result is undefined if `x = 0`\nvec2 atan(vec2 y, vec2 x);\n\n// Returns the angle whose trigonometric arctangent is `y/x`.\n// The signs of `y` and `x` are used to determine the quadrant that the angle lies in. \n// The value returned by atan in this case is in the range `[-π, π]`. The result is undefined if `x = 0`\nvec3 atan(vec3 y, vec3 x);\n\n// Returns the angle whose trigonometric arctangent is `y/x`.\n// The signs of `y` and `x` are used to determine the quadrant that the angle lies in. \n// The value returned by atan in this case is in the range `[-π, π]`. The result is undefined if `x = 0`\nvec4 atan(vec4 y, vec4 x);\n\n// Returns the angle whose tangent is `y_over_x`. The range of values is -π/2 to π/2.\nfloat atan(float y_over_x);\n\n// Returns the angle whose tangent is `y_over_x`. The range of values is -π/2 to π/2.\nvec2 atan(vec2 y_over_x);\n\n// Returns the angle whose tangent is `y_over_x`. The range of values is -π/2 to π/2.\nvec3 atan(vec3 y_over_x);\n\n// Returns the angle whose tangent is `y_over_x`. The range of values is -π/2 to π/2.\nvec4 atan(vec4 y_over_x);\n\n// Returns the hyperbolic sine of a parameter. The hyperbolic sine of x is computed as `(exp(x) - exp(-x)) / 2`\nfloat sinh(float x);\n\n// Returns the hyperbolic sine of a parameter. The hyperbolic sine of x is computed as `(exp(x) - exp(-x)) / 2`\nvec2 sinh(vec2 x);\n\n// Returns the hyperbolic sine of a parameter. The hyperbolic sine of x is computed as `(exp(x) - exp(-x)) / 2`\nvec3 sinh(vec3 x);\n\n// Returns the hyperbolic sine of a parameter. The hyperbolic sine of x is computed as `(exp(x) - exp(-x)) / 2`\nvec4 sinh(vec4 x);\n\n// Returns the hyperbolic cosine of a parameter. The hyperbolic cosine of x is computed as `(exp(x) + exp(-x)) / 2`\nfloat cosh(float x);\n\n// Returns the hyperbolic cosine of a parameter. The hyperbolic cosine of x is computed as `(exp(x) + exp(-x)) / 2`\nvec2 cosh(vec2 x);\n\n// Returns the hyperbolic cosine of a parameter. The hyperbolic cosine of x is computed as `(exp(x) + exp(-x)) / 2`\nvec3 cosh(vec3 x);\n\n// Returns the hyperbolic cosine of a parameter. The hyperbolic cosine of x is computed as `(exp(x) + exp(-x)) / 2`\nvec4 cosh(vec4 x);\n\n// Returns the hyperbolic tangent of a parameter. The hyperbolic tangent of x is computed as `sinh(x) / cosh(x)`\nfloat tanh(float x);\n\n// Returns the hyperbolic tangent of a parameter. The hyperbolic tangent of x is computed as `sinh(x) / cosh(x)`\nvec2 tanh(vec2 x);\n\n// Returns the hyperbolic tangent of a parameter. The hyperbolic tangent of x is computed as `sinh(x) / cosh(x)`\nvec3 tanh(vec3 x);\n\n// Returns the hyperbolic tangent of a parameter. The hyperbolic tangent of x is computed as `sinh(x) / cosh(x)`\nvec4 tanh(vec4 x);\n\n// Returns the hyperbolic arcsine of a parameter. The inverse of `sinh`\nfloat asinh(float x);\n\n// Returns the hyperbolic arcsine of a parameter. The inverse of `sinh`\nvec2 asinh(vec2 x);\n\n// Returns the hyperbolic arcsine of a parameter. The inverse of `sinh`\nvec3 asinh(vec3 x);\n\n// Returns the hyperbolic arcsine of a parameter. The inverse of `sinh`\nvec4 asinh(vec4 x);\n\n// Returns the arc hyperbolic cosine of `x`. THe non-negative inverse of `cosh`. The result is undefined if `x < 1`\nfloat acosh(float x);\n\n// Returns the arc hyperbolic cosine of `x`. THe non-negative inverse of `cosh`. The result is undefined if `x < 1`\nvec2 acosh(vec2 x);\n\n// Returns the arc hyperbolic cosine of `x`. THe non-negative inverse of `cosh`. The result is undefined if `x < 1`\nvec3 acosh(vec3 x);\n\n// Returns the arc hyperbolic cosine of `x`. THe non-negative inverse of `cosh`. The result is undefined if `x < 1`\nvec4 acosh(vec4 x);\n\n// Returns the hyperbolic arctangent of `x`. The inverse of `tanh`. The result is undefined if `abs(x) >= 1`\nfloat atanh(float x);\n\n// Returns the hyperbolic arctangent of `x`. The inverse of `tanh`. The result is undefined if `abs(x) >= 1`\nvec2 atanh(vec2 x);\n\n// Returns the hyperbolic arctangent of `x`. The inverse of `tanh`. The result is undefined if `abs(x) >= 1`\nvec3 atanh(vec3 x);\n\n// Returns the hyperbolic arctangent of `x`. The inverse of `tanh`. The result is undefined if `abs(x) >= 1`\nvec4 atanh(vec4 x);\n\n// Returns the value of `x` raised to the `y` power. The result is undefined if `x < 0` or if `x == 0` and `y <= 0`\nfloat pow(float x, float y);\n\n// Returns the value of `x` raised to the `y` power. The result is undefined if `x < 0` or if `x == 0` and `y <= 0`\nvec2 pow(vec2 x, vec2 y);\n\n// Returns the value of `x` raised to the `y` power. The result is undefined if `x < 0` or if `x == 0` and `y <= 0`\nvec3 pow(vec3 x, vec3 y);\n\n// Returns the value of `x` raised to the `y` power. The result is undefined if `x < 0` or if `x == 0` and `y <= 0`\nvec4 pow(vec4 x, vec4 y);\n\n// Returns the value of `e` raised to the power of `x`\nfloat exp(float x);\n\n// Returns the value of `e` raised to the power of `x`\nvec2 exp(vec2 x);\n\n// Returns the value of `e` raised to the power of `x`\nvec3 exp(vec3 x);\n\n// Returns the value of `e` raised to the power of `x`\nvec4 exp(vec4 x);\n\n// Returns the natural logarithm (base `e`) of `x`. I.e. the value `y` which satisfies `x = e^y. The result is undefined if `x <= 0`.\nfloat log(float x);\n\n// Returns the natural logarithm (base `e`) of `x`. I.e. the value `y` which satisfies `x = e^y. The result is undefined if `x <= 0`.\nvec2 log(vec2 x);\n\n// Returns the natural logarithm (base `e`) of `x`. I.e. the value `y` which satisfies `x = e^y. The result is undefined if `x <= 0`.\nvec3 log(vec3 x);\n\n// Returns the natural logarithm (base `e`) of `x`. I.e. the value `y` which satisfies `x = e^y. The result is undefined if `x <= 0`.\nvec4 log(vec4 x);\n\n// Returns 2 raised to the power of `x`. I.e. `2^x`\nfloat exp2(float x);\n\n// Returns 2 raised to the power of `x`. I.e. `2^x`\nvec2 exp2(vec2 x);\n\n// Returns 2 raised to the power of `x`. I.e. `2^x`\nvec3 exp2(vec3 x);\n\n// Returns 2 raised to the power of `x`. I.e. `2^x`\nvec4 exp2(vec4 x);\n\n// Returns the base 2 logarithm of `x`. I.e. the value `y` which satisfies `x = 2^y. The result is undefined if `x <= 0`.\nfloat log2(float x);\n\n// Returns the base 2 logarithm of `x`. I.e. the value `y` which satisfies `x = 2^y. The result is undefined if `x <= 0`.\nvec2 log2(vec2 x);\n\n// Returns the base 2 logarithm of `x`. I.e. the value `y` which satisfies `x = 2^y. The result is undefined if `x <= 0`.\nvec3 log2(vec3 x);\n\n// Returns the base 2 logarithm of `x`. I.e. the value `y` which satisfies `x = 2^y. The result is undefined if `x <= 0`.\nvec4 log2(vec4 x);\n\n// `sqrt` returns the square root of $x$, i.e.\n// the value $\\sqrt { x }$. The result is undefined if $x < 0$.\nfloat sqrt(float x);\n\n// `sqrt` returns the square root of $x$, i.e.\n// the value $\\sqrt { x }$. The result is undefined if $x < 0$.\nvec2 sqrt(vec2 x);\n\n// `sqrt` returns the square root of $x$, i.e.\n// the value $\\sqrt { x }$. The result is undefined if $x < 0$.\nvec3 sqrt(vec3 x);\n\n// `sqrt` returns the square root of $x$, i.e.\n// the value $\\sqrt { x }$. The result is undefined if $x < 0$.\nvec4 sqrt(vec4 x);\n\n// Returns the inverse square root of `x`. I.e. the value 1/sqrt(x). The result is undefined if `x <= 0`.\nfloat inversesqrt(float x);\n\n// Returns the inverse square root of `x`. I.e. the value 1/sqrt(x). The result is undefined if `x <= 0`.\nvec2 inversesqrt(vec2 x);\n\n// Returns the inverse square root of `x`. I.e. the value 1/sqrt(x). The result is undefined if `x <= 0`.\nvec3 inversesqrt(vec3 x);\n\n// Returns the inverse square root of `x`. I.e. the value 1/sqrt(x). The result is undefined if `x <= 0`.\nvec4 inversesqrt(vec4 x);\n\n// `abs` returns `x` if `x` >= 0, otherwise\n// returns -`x`.\nfloat abs(float x);\n\n// `abs` returns `x` if `x` >= 0, otherwise\n// returns -`x`.\nvec2 abs(vec2 x);\n\n// `abs` returns `x` if `x` >= 0, otherwise\n// returns -`x`.\nvec3 abs(vec3 x);\n\n// `abs` returns `x` if `x` >= 0, otherwise\n// returns -`x`.\nvec4 abs(vec4 x);\n\n// `abs` returns `x` if `x` >= 0, otherwise\n// returns -`x`.\nint abs(int x);\n\n// `abs` returns `x` if `x` >= 0, otherwise\n// returns -`x`.\nivec2 abs(ivec2 x);\n\n// `abs` returns `x` if `x` >= 0, otherwise\n// returns -`x`.\nivec3 abs(ivec3 x);\n\n// `abs` returns `x` if `x` >= 0, otherwise\n// returns -`x`.\nivec4 abs(ivec4 x);\n\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\nfloat sign(float x);\n\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\nvec2 sign(vec2 x);\n\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\nvec3 sign(vec3 x);\n\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\nvec4 sign(vec4 x);\n\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\nint sign(int x);\n\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\nivec2 sign(ivec2 x);\n\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\nivec3 sign(ivec3 x);\n\n// Returns the sign of `x`. I.e. -1 if `x < 0`, 0 if `x == 0`, 1 if `x > 0`\nivec4 sign(ivec4 x);\n\n// `floor` returns a value equal to the nearest integer that is less than or equal to `x`.\nfloat floor(float x);\n\n// `floor` returns a value equal to the nearest integer that is less than or equal to `x`.\nvec2 floor(vec2 x);\n\n// `floor` returns a value equal to the nearest integer that is less than or equal to `x`.\nvec3 floor(vec3 x);\n\n// `floor` returns a value equal to the nearest integer that is less than or equal to `x`.\nvec4 floor(vec4 x);\n\n// `trunc` returns a value equal to the nearest integer to `x`\n// whose absolute value is not larger than the absolute value of `x`.\nfloat trunc(float x);\n\n// `trunc` returns a value equal to the nearest integer to `x`\n// whose absolute value is not larger than the absolute value of `x`.\nvec2 trunc(vec2 x);\n\n// `trunc` returns a value equal to the nearest integer to `x`\n// whose absolute value is not larger than the absolute value of `x`.\nvec3 trunc(vec3 x);\n\n// `trunc` returns a value equal to the nearest integer to `x`\n// whose absolute value is not larger than the absolute value of `x`.\nvec4 trunc(vec4 x);\n\n// `round` returns a value equal to the nearest integer to `x`.\n// The fraction 0.5 will round in a direction chosen by the implementation, usually in the direction that is\n// fastest. This includes the possibility that `round`(`x`) returns the\n// same value as `roundEven`(`x`)\n// for all values of `x`.\nfloat round(float x);\n\n// `round` returns a value equal to the nearest integer to `x`.\n// The fraction 0.5 will round in a direction chosen by the implementation, usually in the direction that is\n// fastest. This includes the possibility that `round`(`x`) returns the\n// same value as `roundEven`(`x`)\n// for all values of `x`.\nvec2 round(vec2 x);\n\n// `round` returns a value equal to the nearest integer to `x`.\n// The fraction 0.5 will round in a direction chosen by the implementation, usually in the direction that is\n// fastest. This includes the possibility that `round`(`x`) returns the\n// same value as `roundEven`(`x`)\n// for all values of `x`.\nvec3 round(vec3 x);\n\n// `round` returns a value equal to the nearest integer to `x`.\n// The fraction 0.5 will round in a direction chosen by the implementation, usually in the direction that is\n// fastest. This includes the possibility that `round`(`x`) returns the\n// same value as `roundEven`(`x`)\n// for all values of `x`.\nvec4 round(vec4 x);\n\n// `roundEven` returns a value equal to the nearest integer to `x`.\n// The fractional part of 0.5 will round toward the nearest even integer.\n// For example, both 3.5 and 4.5 will round to 4.0.\nfloat roundEven(float x);\n\n// `roundEven` returns a value equal to the nearest integer to `x`.\n// The fractional part of 0.5 will round toward the nearest even integer.\n// For example, both 3.5 and 4.5 will round to 4.0.\nvec2 roundEven(vec2 x);\n\n// `roundEven` returns a value equal to the nearest integer to `x`.\n// The fractional part of 0.5 will round toward the nearest even integer.\n// For example, both 3.5 and 4.5 will round to 4.0.\nvec3 roundEven(vec3 x);\n\n// `roundEven` returns a value equal to the nearest integer to `x`.\n// The fractional part of 0.5 will round toward the nearest even integer.\n// For example, both 3.5 and 4.5 will round to 4.0.\nvec4 roundEven(vec4 x);\n\n// `ceil` returns a value equal to the nearest integer that is\n// greater than or equal to `x`.\nfloat ceil(float x);\n\n// `ceil` returns a value equal to the nearest integer that is\n// greater than or equal to `x`.\nvec2 ceil(vec2 x);\n\n// `ceil` returns a value equal to the nearest integer that is\n// greater than or equal to `x`.\nvec3 ceil(vec3 x);\n\n// `ceil` returns a value equal to the nearest integer that is\n// greater than or equal to `x`.\nvec4 ceil(vec4 x);\n\n// `fract` returns the fractional part of `x`. This\n// is calculated as `x` - `floor`(`x`).\nfloat fract(float x);\n\n// `fract` returns the fractional part of `x`. This\n// is calculated as `x` - `floor`(`x`).\nvec2 fract(vec2 x);\n\n// `fract` returns the fractional part of `x`. This\n// is calculated as `x` - `floor`(`x`).\nvec3 fract(vec3 x);\n\n// `fract` returns the fractional part of `x`. This\n// is calculated as `x` - `floor`(`x`).\nvec4 fract(vec4 x);\n\n// `mod` returns the value of `x` modulo\n// `y`. This is computed as `x` - `y` *\n// `floor`(`x`/`y`).\nfloat mod(float x, float y);\n\n// `mod` returns the value of `x` modulo\n// `y`. This is computed as `x` - `y` *\n// `floor`(`x`/`y`).\nvec2 mod(vec2 x, float y);\n\n// `mod` returns the value of `x` modulo\n// `y`. This is computed as `x` - `y` *\n// `floor`(`x`/`y`).\nvec3 mod(vec3 x, float y);\n\n// `mod` returns the value of `x` modulo\n// `y`. This is computed as `x` - `y` *\n// `floor`(`x`/`y`).\nvec4 mod(vec4 x, float y);\n\n// `mod` returns the value of `x` modulo\n// `y`. This is computed as `x` - `y` *\n// `floor`(`x`/`y`).\nvec2 mod(vec2 x, vec2 y);\n\n// `mod` returns the value of `x` modulo\n// `y`. This is computed as `x` - `y` *\n// `floor`(`x`/`y`).\nvec3 mod(vec3 x, vec3 y);\n\n// `mod` returns the value of `x` modulo\n// `y`. This is computed as `x` - `y` *\n// `floor`(`x`/`y`).\nvec4 mod(vec4 x, vec4 y);\n\n// `modf` separates a floating point value `x`\n// into its integer and fractional parts. The fractional part of the number is returned\n// from the function and the integer part (as a floating point quantity) is returned\n// in the output parameter `i`.\nfloat modf(float x, out float i);\n\n// `modf` separates a floating point value `x`\n// into its integer and fractional parts. The fractional part of the number is returned\n// from the function and the integer part (as a floating point quantity) is returned\n// in the output parameter `i`.\nvec2 modf(vec2 x, out vec2 i);\n\n// `modf` separates a floating point value `x`\n// into its integer and fractional parts. The fractional part of the number is returned\n// from the function and the integer part (as a floating point quantity) is returned\n// in the output parameter `i`.\nvec3 modf(vec3 x, out vec3 i);\n\n// `modf` separates a floating point value `x`\n// into its integer and fractional parts. The fractional part of the number is returned\n// from the function and the integer part (as a floating point quantity) is returned\n// in the output parameter `i`.\nvec4 modf(vec4 x, out vec4 i);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nfloat min(float x, float y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nvec2 min(vec2 x, vec2 y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nvec3 min(vec3 x, vec3 y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nvec4 min(vec4 x, vec4 y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nvec2 min(vec2 x, float y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nvec3 min(vec3 x, float y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nvec4 min(vec4 x, float y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nint min(int x, int y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nivec2 min(ivec2 x, ivec2 y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nivec3 min(ivec3 x, ivec3 y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nivec4 min(ivec4 x, ivec4 y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nivec2 min(ivec2 x, int y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nivec3 min(ivec3 x, int y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nivec4 min(ivec4 x, int y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nuint min(uint x, uint y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nuvec2 min(uvec2 x, uvec2 y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nuvec3 min(uvec3 x, uvec3 y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nuvec4 min(uvec4 x, uvec4 y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nuvec2 min(uvec2 x, uint y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nuvec3 min(uvec3 x, uint y);\n\n// `min` returns the minimum of the two parameters. It\n// returns `y` if `y` is less than\n// `x`, otherwise it returns `x`.\nuvec4 min(uvec4 x, uint y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nfloat max(float x, float y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nvec2 max(vec2 x, vec2 y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nvec3 max(vec3 x, vec3 y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nvec4 max(vec4 x, vec4 y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nvec2 max(vec2 x, float y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nvec3 max(vec3 x, float y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nvec4 max(vec4 x, float y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nint max(int x, int y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nivec2 max(ivec2 x, ivec2 y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nivec3 max(ivec3 x, ivec3 y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nivec4 max(ivec4 x, ivec4 y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nivec2 max(ivec2 x, int y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nivec3 max(ivec3 x, int y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nivec4 max(ivec4 x, int y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nuint max(uint x, uint y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nuvec2 max(uvec2 x, uvec2 y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nuvec3 max(uvec3 x, uvec3 y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nuvec4 max(uvec4 x, uvec4 y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nuvec2 max(uvec2 x, uint y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nuvec3 max(uvec3 x, uint y);\n\n// `max` returns the maximum of the two parameters. It\n// returns `y` if `y` is greater than\n// `x`, otherwise it returns `x`.\nuvec4 max(uvec4 x, uint y);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nfloat clamp(float x, float minVal, float maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nvec2 clamp(vec2 x, vec2 minVal, vec2 maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nvec3 clamp(vec3 x, vec3 minVal, vec3 maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nvec4 clamp(vec4 x, vec4 minVal, vec4 maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nvec2 clamp(vec2 x, float minVal, float maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nvec3 clamp(vec3 x, float minVal, float maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nvec4 clamp(vec4 x, float minVal, float maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nint clamp(int x, int minVal, int maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nivec2 clamp(ivec2 x, ivec2 minVal, ivec2 maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nivec3 clamp(ivec3 x, ivec3 minVal, ivec3 maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nivec4 clamp(ivec4 x, ivec4 minVal, ivec4 maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nivec2 clamp(ivec2 x, int minVal, int maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nivec3 clamp(ivec3 x, int minVal, int maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nivec4 clamp(ivec4 x, int minVal, int maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nuint clamp(uint x, uint minVal, uint maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nuvec2 clamp(uvec2 x, uvec2 minVal, uvec2 maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nuvec3 clamp(uvec3 x, uvec3 minVal, uvec3 maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nuvec4 clamp(uvec4 x, uvec4 minVal, uvec4 maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nuvec2 clamp(uvec2 x, uint minVal, uint maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nuvec3 clamp(uvec3 x, uint minVal, uint maxVal);\n\n// Clamps `x` to the range `[min, max]`. Computed as `min(max(x, minVal), maxVal)`\nuvec4 clamp(uvec4 x, uint minVal, uint maxVal);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nfloat mix(float x, float y, float a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec2 mix(vec2 x, vec2 y, vec2 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec3 mix(vec3 x, vec3 y, vec3 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec4 mix(vec4 x, vec4 y, vec4 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec2 mix(vec2 x, vec2 y, float a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec3 mix(vec3 x, vec3 y, float a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec4 mix(vec4 x, vec4 y, float a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nfloat mix(float x, float y, bool a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec2 mix(vec2 x, vec2 y, bool a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec3 mix(vec3 x, vec3 y, bool a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec4 mix(vec4 x, vec4 y, bool a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nfloat mix(float x, float y, bvec2 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec2 mix(vec2 x, vec2 y, bvec2 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec3 mix(vec3 x, vec3 y, bvec2 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec4 mix(vec4 x, vec4 y, bvec2 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nfloat mix(float x, float y, bvec3 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec2 mix(vec2 x, vec2 y, bvec3 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec3 mix(vec3 x, vec3 y, bvec3 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec4 mix(vec4 x, vec4 y, bvec3 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nfloat mix(float x, float y, bvec4 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec2 mix(vec2 x, vec2 y, bvec4 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec3 mix(vec3 x, vec3 y, bvec4 a);\n\n// Returns the linear interpolation between `x` and `y` at `a`. I.e. `x * (1 - a) + y * a`\nvec4 mix(vec4 x, vec4 y, bvec4 a);\n\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\nfloat step(float edge, float x);\n\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\nvec2 step(vec2 edge, vec2 x);\n\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\nvec3 step(vec3 edge, vec3 x);\n\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\nvec4 step(vec4 edge, vec4 x);\n\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\nvec2 step(float edge, vec2 x);\n\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\nvec3 step(float edge, vec3 x);\n\n// Returns 0 if `x < edge`, otherwise 1. I.e. `x < edge ? 0 : 1`\nvec4 step(float edge, vec4 x);\n\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\n// `smoothstep` is equivalent to: \n// \n// ```\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n// return t * t * (3.0 - 2.0 * t);\n// ```\nfloat smoothstep(float edge0, float edge1, float x);\n\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\n// `smoothstep` is equivalent to: \n// \n// ```\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n// return t * t * (3.0 - 2.0 * t);\n// ```\nvec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x);\n\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\n// `smoothstep` is equivalent to: \n// \n// ```\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n// return t * t * (3.0 - 2.0 * t);\n// ```\nvec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x);\n\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\n// `smoothstep` is equivalent to: \n// \n// ```\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n// return t * t * (3.0 - 2.0 * t);\n// ```\nvec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x);\n\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\n// `smoothstep` is equivalent to: \n// \n// ```\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n// return t * t * (3.0 - 2.0 * t);\n// ```\nvec2 smoothstep(float edge0, float edge1, vec2 x);\n\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\n// `smoothstep` is equivalent to: \n// \n// ```\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n// return t * t * (3.0 - 2.0 * t);\n// ```\nvec3 smoothstep(float edge0, float edge1, vec3 x);\n\n// Performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`\n// `smoothstep` is equivalent to: \n// \n// ```\n// genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n// return t * t * (3.0 - 2.0 * t);\n// ```\nvec4 smoothstep(float edge0, float edge1, vec4 x);\n\n// For each element `i` of the result, `isnan` returns `true` if `x[i]` is positive or negative floating point `NaN`, and `false` otherwise.\n// NaNs may not be supported by the implementation, in which case `isnan` returns `false`.\nbool isnan(float x);\n\n// For each element `i` of the result, `isnan` returns `true` if `x[i]` is positive or negative floating point `NaN`, and `false` otherwise.\n// NaNs may not be supported by the implementation, in which case `isnan` returns `false`.\nbvec2 isnan(vec2 x);\n\n// For each element `i` of the result, `isnan` returns `true` if `x[i]` is positive or negative floating point `NaN`, and `false` otherwise.\n// NaNs may not be supported by the implementation, in which case `isnan` returns `false`.\nbvec3 isnan(vec3 x);\n\n// For each element `i` of the result, `isnan` returns `true` if `x[i]` is positive or negative floating point `NaN`, and `false` otherwise.\n// NaNs may not be supported by the implementation, in which case `isnan` returns `false`.\nbvec4 isnan(vec4 x);\n\n// For each element `i` of the result, `isinf` returns `true` if `x[i]` is positive or negative floating point `Infinity`, and `false` otherwise.\nbool isinf(float x);\n\n// For each element `i` of the result, `isinf` returns `true` if `x[i]` is positive or negative floating point `Infinity`, and `false` otherwise.\nbvec2 isinf(vec2 x);\n\n// For each element `i` of the result, `isinf` returns `true` if `x[i]` is positive or negative floating point `Infinity`, and `false` otherwise.\nbvec3 isinf(vec3 x);\n\n// For each element `i` of the result, `isinf` returns `true` if `x[i]` is positive or negative floating point `Infinity`, and `false` otherwise.\nbvec4 isinf(vec4 x);\n\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\n// converted to highp floating point and the encoding of that value is returned.\nint floatBitsToInt(float x);\n\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\n// converted to highp floating point and the encoding of that value is returned.\nivec2 floatBitsToInt(vec2 x);\n\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\n// converted to highp floating point and the encoding of that value is returned.\nivec3 floatBitsToInt(vec3 x);\n\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\n// converted to highp floating point and the encoding of that value is returned.\nivec4 floatBitsToInt(vec4 x);\n\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\n// converted to highp floating point and the encoding of that value is returned.\nuint floatBitsToUint(float x);\n\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\n// converted to highp floating point and the encoding of that value is returned.\nuvec2 floatBitsToUint(vec2 x);\n\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\n// converted to highp floating point and the encoding of that value is returned.\nuvec3 floatBitsToUint(vec3 x);\n\n// `floatBitsToInt` and `floatBitsToUint` return the encoding\n// of their floating-point parameters as highp `int` or `uint`, respectively. The\n// floating-point bit-level representation is preserved. For mediump and lowp, the value is first\n// converted to highp floating point and the encoding of that value is returned.\nuvec4 floatBitsToUint(vec4 x);\n\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\n// passed in parameter `x` as a highp floating-point value. If the encoding of\n// a NaN is passed in `x`, it will not signal and the resulting value will\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\n// the resulting floating-point value is the corresponding (positive or negative) floating\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\nfloat intBitsToFloat(float x);\n\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\n// passed in parameter `x` as a highp floating-point value. If the encoding of\n// a NaN is passed in `x`, it will not signal and the resulting value will\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\n// the resulting floating-point value is the corresponding (positive or negative) floating\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\nvec2 intBitsToFloat(vec2 x);\n\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\n// passed in parameter `x` as a highp floating-point value. If the encoding of\n// a NaN is passed in `x`, it will not signal and the resulting value will\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\n// the resulting floating-point value is the corresponding (positive or negative) floating\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\nvec3 intBitsToFloat(vec3 x);\n\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\n// passed in parameter `x` as a highp floating-point value. If the encoding of\n// a NaN is passed in `x`, it will not signal and the resulting value will\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\n// the resulting floating-point value is the corresponding (positive or negative) floating\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\nvec4 intBitsToFloat(vec4 x);\n\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\n// passed in parameter `x` as a highp floating-point value. If the encoding of\n// a NaN is passed in `x`, it will not signal and the resulting value will\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\n// the resulting floating-point value is the corresponding (positive or negative) floating\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\nfloat uintBitsToFloat(float x);\n\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\n// passed in parameter `x` as a highp floating-point value. If the encoding of\n// a NaN is passed in `x`, it will not signal and the resulting value will\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\n// the resulting floating-point value is the corresponding (positive or negative) floating\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\nvec2 uintBitsToFloat(vec2 x);\n\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\n// passed in parameter `x` as a highp floating-point value. If the encoding of\n// a NaN is passed in `x`, it will not signal and the resulting value will\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\n// the resulting floating-point value is the corresponding (positive or negative) floating\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\nvec3 uintBitsToFloat(vec3 x);\n\n// `intBitsToFloat` and `uintBitsToFloat` return the encoding\n// passed in parameter `x` as a highp floating-point value. If the encoding of\n// a NaN is passed in `x`, it will not signal and the resulting value will\n// be undefined. If the encoding of a floating point infinity is passed in parameter `x`,\n// the resulting floating-point value is the corresponding (positive or negative) floating\n// point infinity. For lowp and mediump, the value is first converted to the corresponding signed or\n// unsigned highp integer and then reinterpreted as a highp floating point value as before.\nvec4 uintBitsToFloat(vec4 x);\n\n// Returns the length of a vector. I.e. the square root of the sum of the squares of all components.\nfloat length(float x);\n\n// Returns the length of a vector. I.e. the square root of the sum of the squares of all components.\nfloat length(vec2 x);\n\n// Returns the length of a vector. I.e. the square root of the sum of the squares of all components.\nfloat length(vec3 x);\n\n// Returns the length of a vector. I.e. the square root of the sum of the squares of all components.\nfloat length(vec4 x);\n\n// Returns the distance between two vectors. I.e. `length(p0 - p1)`\nfloat distance(float p0, float p1);\n\n// Returns the distance between two vectors. I.e. `length(p0 - p1)`\nfloat distance(vec2 p0, vec2 p1);\n\n// Returns the distance between two vectors. I.e. `length(p0 - p1)`\nfloat distance(vec3 p0, vec3 p1);\n\n// Returns the distance between two vectors. I.e. `length(p0 - p1)`\nfloat distance(vec4 p0, vec4 p1);\n\n// Returns the dot product of two vectors. I.e. `x[0] * y[0] + x[1] * y[1] + ...`\nfloat dot(float x, float y);\n\n// Returns the dot product of two vectors. I.e. `x[0] * y[0] + x[1] * y[1] + ...`\nfloat dot(vec2 x, vec2 y);\n\n// Returns the dot product of two vectors. I.e. `x[0] * y[0] + x[1] * y[1] + ...`\nfloat dot(vec3 x, vec3 y);\n\n// Returns the dot product of two vectors. I.e. `x[0] * y[0] + x[1] * y[1] + ...`\nfloat dot(vec4 x, vec4 y);\n\n// Returns the cross product of two vectors. I.e. `(x[1] * y[2] - x[2] * y[1], x[2] * y[0] - x[0] * y[2], x[0] * y[1] - x[1] * y[0])`\nvec3 cross(vec3 x, vec3 y);\n\n// `normalize` returns a vector with the same direction as its parameter, `v`, but with length 1.\nfloat normalize(float v);\n\n// `normalize` returns a vector with the same direction as its parameter, `v`, but with length 1.\nvec2 normalize(vec2 v);\n\n// `normalize` returns a vector with the same direction as its parameter, `v`, but with length 1.\nvec3 normalize(vec3 v);\n\n// `normalize` returns a vector with the same direction as its parameter, `v`, but with length 1.\nvec4 normalize(vec4 v);\n\n// `faceforward` orients a vector to point away from a surface as defined by its normal.\n// If `dot(Nref, I) < 0`, then `faceforward` returns `N`, otherwise it returns `-N`\nfloat faceforward(float N, float I, float Nref);\n\n// `faceforward` orients a vector to point away from a surface as defined by its normal.\n// If `dot(Nref, I) < 0`, then `faceforward` returns `N`, otherwise it returns `-N`\nvec2 faceforward(vec2 N, vec2 I, vec2 Nref);\n\n// `faceforward` orients a vector to point away from a surface as defined by its normal.\n// If `dot(Nref, I) < 0`, then `faceforward` returns `N`, otherwise it returns `-N`\nvec3 faceforward(vec3 N, vec3 I, vec3 Nref);\n\n// `faceforward` orients a vector to point away from a surface as defined by its normal.\n// If `dot(Nref, I) < 0`, then `faceforward` returns `N`, otherwise it returns `-N`\nvec4 faceforward(vec4 N, vec4 I, vec4 Nref);\n\n// For a given incident vector `I` and surface normal `N` `reflect` returns\n// the reflection direction calculated as ``I` - 2.0 * dot(`N`, `I`) * `N``.\n// `N` should be normalized in order to achieve the desired result.\nfloat reflect(float I, float N);\n\n// For a given incident vector `I` and surface normal `N` `reflect` returns\n// the reflection direction calculated as ``I` - 2.0 * dot(`N`, `I`) * `N``.\n// `N` should be normalized in order to achieve the desired result.\nvec2 reflect(vec2 I, vec2 N);\n\n// For a given incident vector `I` and surface normal `N` `reflect` returns\n// the reflection direction calculated as ``I` - 2.0 * dot(`N`, `I`) * `N``.\n// `N` should be normalized in order to achieve the desired result.\nvec3 reflect(vec3 I, vec3 N);\n\n// For a given incident vector `I` and surface normal `N` `reflect` returns\n// the reflection direction calculated as ``I` - 2.0 * dot(`N`, `I`) * `N``.\n// `N` should be normalized in order to achieve the desired result.\nvec4 reflect(vec4 I, vec4 N);\n\n// For a given incident vector `I`, surface normal `N` and ratio of\n// indices of refraction, `eta`, `refract` returns the refraction vector,\n// `R`.\n// `R` is calculated as:\n// \n// ```glsl\n//    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n// if (k < 0.0)\n// R = genType(0.0);       // or genDType(0.0)\n// else\n// R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n// ```\n//\n// The input parameters `I` and `N` should be normalized in order to achieve the desired result.\nfloat refract(float I, float N, float eta);\n\n// For a given incident vector `I`, surface normal `N` and ratio of\n// indices of refraction, `eta`, `refract` returns the refraction vector,\n// `R`.\n// `R` is calculated as:\n// \n// ```glsl\n//    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n// if (k < 0.0)\n// R = genType(0.0);       // or genDType(0.0)\n// else\n// R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n// ```\n//\n// The input parameters `I` and `N` should be normalized in order to achieve the desired result.\nvec2 refract(vec2 I, vec2 N, float eta);\n\n// For a given incident vector `I`, surface normal `N` and ratio of\n// indices of refraction, `eta`, `refract` returns the refraction vector,\n// `R`.\n// `R` is calculated as:\n// \n// ```glsl\n//    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n// if (k < 0.0)\n// R = genType(0.0);       // or genDType(0.0)\n// else\n// R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n// ```\n//\n// The input parameters `I` and `N` should be normalized in order to achieve the desired result.\nvec3 refract(vec3 I, vec3 N, float eta);\n\n// For a given incident vector `I`, surface normal `N` and ratio of\n// indices of refraction, `eta`, `refract` returns the refraction vector,\n// `R`.\n// `R` is calculated as:\n// \n// ```glsl\n//    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n// if (k < 0.0)\n// R = genType(0.0);       // or genDType(0.0)\n// else\n// R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n// ```\n//\n// The input parameters `I` and `N` should be normalized in order to achieve the desired result.\nvec4 refract(vec4 I, vec4 N, float eta);\n\n// `outerProduct` treats the first parameter `c` as a column\n// vector (matrix with one column) and the second parameter `r` as a row vector\n// (matrix with one row) and does a linear algebraic matrix multiply `c` * `r`,\n// yielding a matrix whose number of rows is the number of components in `c` and\n// whose number of columns is the number of components in `r`.\nmat2 outerProduct(vec2 c, vec2 r);\n\n// `outerProduct` treats the first parameter `c` as a column\n// vector (matrix with one column) and the second parameter `r` as a row vector\n// (matrix with one row) and does a linear algebraic matrix multiply `c` * `r`,\n// yielding a matrix whose number of rows is the number of components in `c` and\n// whose number of columns is the number of components in `r`.\nmat3 outerProduct(vec3 c, vec3 r);\n\n// `outerProduct` treats the first parameter `c` as a column\n// vector (matrix with one column) and the second parameter `r` as a row vector\n// (matrix with one row) and does a linear algebraic matrix multiply `c` * `r`,\n// yielding a matrix whose number of rows is the number of components in `c` and\n// whose number of columns is the number of components in `r`.\nmat4 outerProduct(vec4 c, vec4 r);\n\n\n// `transpose` returns the transpose of the matrix `m`.\nmat2 transpose(mat2 m);\n\n// `transpose` returns the transpose of the matrix `m`.\nmat3 transpose(mat3 m);\n\n// `transpose` returns the transpose of the matrix `m`.\nmat4 transpose(mat4 m);\n\n// `determinant` returns the determinant of the matrix `m`.\nfloat determinant(mat2 m);\n\n// `determinant` returns the determinant of the matrix `m`.\nfloat determinant(mat3 m);\n\n// `determinant` returns the determinant of the matrix `m`.\nfloat determinant(mat4 m);\n\n// `inverse` returns the inverse of the matrix `m`. The values in the\n// returned matrix are undefined if `m` is singular or poorly-conditioned (nearly singular).\nmat2 inverse(mat2 m);\n\n// `inverse` returns the inverse of the matrix `m`. The values in the\n// returned matrix are undefined if `m` is singular or poorly-conditioned (nearly singular).\nmat3 inverse(mat3 m);\n\n// `inverse` returns the inverse of the matrix `m`. The values in the\n// returned matrix are undefined if `m` is singular or poorly-conditioned (nearly singular).\nmat4 inverse(mat4 m);\n\n// `lessThan` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] < `y`[_i_].\nbvec2 lessThan(vec2 x, vec2 y);\n\n// `lessThan` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] < `y`[_i_].\nbvec3 lessThan(vec3 x, vec3 y);\n\n// `lessThan` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] < `y`[_i_].\nbvec4 lessThan(vec4 x, vec4 y);\n\n// `lessThanEqual` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] =< `y`[_i_].\nbvec2 lessThanEqual(vec2 x, vec2 y);\n\n// `lessThanEqual` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] =< `y`[_i_].\nbvec3 lessThanEqual(vec3 x, vec3 y);\n\n// `lessThanEqual` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] =< `y`[_i_].\nbvec4 lessThanEqual(vec4 x, vec4 y);\n\n// `greaterThan` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] > `y`[_i_].\nbvec2 greaterThan(vec2 x, vec2 y);\n\n// `greaterThan` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] > `y`[_i_].\nbvec3 greaterThan(vec3 x, vec3 y);\n\n// `greaterThan` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] > `y`[_i_].\nbvec4 greaterThan(vec4 x, vec4 y);\n\n// `greaterThanEqual` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] >= `y`[_i_].\nbvec2 greaterThanEqual(vec2 x, vec2 y);\n\n// `greaterThanEqual` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] >= `y`[_i_].\nbvec3 greaterThanEqual(vec3 x, vec3 y);\n\n// `greaterThanEqual` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] >= `y`[_i_].\nbvec4 greaterThanEqual(vec4 x, vec4 y);\n\n// `equal` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] == `y`[_i_].\nbvec2 equal(vec2 x, vec2 y);\n\n// `equal` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] == `y`[_i_].\nbvec3 equal(vec3 x, vec3 y);\n\n// `equal` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] == `y`[_i_].\nbvec4 equal(vec4 x, vec4 y);\n\n// `notEqual` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] != `y`[_i_].\nbvec2 notEqual(vec2 x, vec2 y);\n\n// `notEqual` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] != `y`[_i_].\nbvec3 notEqual(vec3 x, vec3 y);\n\n// `notEqual` returns a boolean vector in which each element _i_ is computed\n// as `x`[_i_] != `y`[_i_].\nbvec4 notEqual(vec4 x, vec4 y);\n\n// `any` returns true if any element of `x` is true and false otherwise.\n// It is functionally equivalent to:\n// \n// ```glsl\n//    bool any(bvec x)       // bvec can be bvec2, bvec3 or bvec4\n// {\n// bool result = false;\n// int i;\n// for (i = 0; i < x.length(); ++i)\n// {\n// result |= x[i];\n// }\n// return result;\n// }\n// ```\n//\nbool any(bvec2 x);\n\n// `any` returns true if any element of `x` is true and false otherwise.\n// It is functionally equivalent to:\n// \n// ```glsl\n//    bool any(bvec x)       // bvec can be bvec2, bvec3 or bvec4\n// {\n// bool result = false;\n// int i;\n// for (i = 0; i < x.length(); ++i)\n// {\n// result |= x[i];\n// }\n// return result;\n// }\n// ```\n//\nbool any(bvec3 x);\n\n// `any` returns true if any element of `x` is true and false otherwise.\n// It is functionally equivalent to:\n// \n// ```glsl\n//    bool any(bvec x)       // bvec can be bvec2, bvec3 or bvec4\n// {\n// bool result = false;\n// int i;\n// for (i = 0; i < x.length(); ++i)\n// {\n// result |= x[i];\n// }\n// return result;\n// }\n// ```\n//\nbool any(bvec4 x);\n\n// `all` returns true if all elements of `x` are true and false otherwise.\n// It is functionally equivalent to:\n// \n// ```glsl\n//    bool all(bvec x)       // bvec can be bvec2, bvec3 or bvec4\n// {\n// bool result = true;\n// int i;\n// for (i = 0; i < x.length(); ++i)\n// {\n// result &amp;= x[i];\n// }\n// return result;\n// }\n// ```\n//\nbool all(bvec2 x);\n\n// `all` returns true if all elements of `x` are true and false otherwise.\n// It is functionally equivalent to:\n// \n// ```glsl\n//    bool all(bvec x)       // bvec can be bvec2, bvec3 or bvec4\n// {\n// bool result = true;\n// int i;\n// for (i = 0; i < x.length(); ++i)\n// {\n// result &amp;= x[i];\n// }\n// return result;\n// }\n// ```\n//\nbool all(bvec3 x);\n\n// `all` returns true if all elements of `x` are true and false otherwise.\n// It is functionally equivalent to:\n// \n// ```glsl\n//    bool all(bvec x)       // bvec can be bvec2, bvec3 or bvec4\n// {\n// bool result = true;\n// int i;\n// for (i = 0; i < x.length(); ++i)\n// {\n// result &amp;= x[i];\n// }\n// return result;\n// }\n// ```\n//\nbool all(bvec4 x);\n\n// `not` logically inverts the boolean vector `x`. It returns\n// a new boolean vector for which each element _i_ is computed as `!`x`[`i`]`.\nbvec2 not(bvec2 x);\n\n// `not` logically inverts the boolean vector `x`. It returns\n// a new boolean vector for which each element _i_ is computed as `!`x`[`i`]`.\nbvec3 not(bvec3 x);\n\n// `not` logically inverts the boolean vector `x`. It returns\n// a new boolean vector for which each element _i_ is computed as `!`x`[`i`]`.\nbvec4 not(bvec4 x);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec2 textureSize(sampler2D sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec2 textureSize(isampler2D sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec2 textureSize(usampler2D sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec3 textureSize(sampler3D sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec3 textureSize(isampler3D sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec3 textureSize(usampler3D sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec2 textureSize(samplerCube sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec2 textureSize(isamplerCube sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec2 textureSize(usamplerCube sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec2 textureSize(sampler2DShadow sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec2 textureSize(samplerCubeShadow sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec3 textureSize(sampler2DArray sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec3 textureSize(isampler2DArray sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec3 textureSize(usampler2DArray sampler, int lod);\n\n// `textureSize` returns the dimensions of level `lod` (if present)\n// of the texture bound to `sampler`. The components in the return value are filled in,\n// in order, with the width, height and depth of the texture. For the array forms, the last component of the\n// return value is the number of layers in the texture array. The return values are returned as highp ints.\nivec3 textureSize(sampler2DArrayShadow sampler, int lod);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nvec4 texture(sampler2D sampler, vec2 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nivec4 texture(isampler2D sampler, vec2 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nuvec4 texture(usampler2D sampler, vec2 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nvec4 texture(sampler2D sampler, vec2 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nivec4 texture(isampler2D sampler, vec2 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nuvec4 texture(usampler2D sampler, vec2 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nvec4 texture(sampler3D sampler, vec3 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nivec4 texture(isampler3D sampler, vec3 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nuvec4 texture(usampler3D sampler, vec3 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nvec4 texture(sampler3D sampler, vec3 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nivec4 texture(isampler3D sampler, vec3 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nuvec4 texture(usampler3D sampler, vec3 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nvec4 texture(samplerCube sampler, vec3 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nivec4 texture(isamplerCube sampler, vec3 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nuvec4 texture(usamplerCube sampler, vec3 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nvec4 texture(samplerCube sampler, vec3 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nivec4 texture(isamplerCube sampler, vec3 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nuvec4 texture(usamplerCube sampler, vec3 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\n// When compare is not present, the last component of `P` is used as Dsub and the array\n// layer is specified in the second to last component of `P`.\nfloat texture(sampler2DShadow sampler, vec3 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\n// When compare is not present, the last component of `P` is used as Dsub and the array\n// layer is specified in the second to last component of `P`.\nfloat texture(sampler2DShadow sampler, vec3 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\n// When compare is not present, the last component of `P` is used as Dsub and the array\n// layer is specified in the second to last component of `P`.\nfloat texture(samplerCubeShadow sampler, vec4 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\n// When compare is not present, the last component of `P` is used as Dsub and the array\n// layer is specified in the second to last component of `P`.\nfloat texture(samplerCubeShadow sampler, vec4 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nvec4 texture(sampler2DArray sampler, vec3 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nivec4 texture(isampler2DArray sampler, vec3 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nuvec4 texture(usampler2DArray sampler, vec3 P, float bias);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nvec4 texture(sampler2DArray sampler, vec3 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nivec4 texture(isampler2DArray sampler, vec3 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// The array layer comes from the last component of `P`\nuvec4 texture(usampler2DArray sampler, vec3 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\n// When compare is not present, the last component of `P` is used as Dsub and the array\n// layer is specified in the second to last component of `P`.\nfloat texture(sampler2DArrayShadow sampler, vec4 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\n// When compare is not present, the last component of `P` is used as Dsub and the array\n// layer is specified in the second to last component of `P`.\nfloat texture(isampler2DArrayShadow sampler, vec4 P);\n\n// `texture` samples texels from the texture bound to `sampler` at texture coordinate `P`.\n// An optional bias, specified in `bias` is included in the level-of-detail computation that\n// is used to choose mipmap(s) from which to sample.\n// \n// When compare is present, it is used as Dsub and the array layer is specified in `P.w`\n// When compare is not present, the last component of `P` is used as Dsub and the array\n// layer is specified in the second to last component of `P`.\nfloat texture(usampler2DArrayShadow sampler, vec4 P);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nvec4 textureProj(sampler2D sampler, vec3 P, float bias);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nivec4 textureProj(isampler2D sampler, vec3 P, float bias);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nuvec4 textureProj(usampler2D sampler, vec3 P, float bias);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nvec4 textureProj(sampler2D sampler, vec3 P);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nivec4 textureProj(isampler2D sampler, vec3 P);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nuvec4 textureProj(usampler2D sampler, vec3 P);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nvec4 textureProj(sampler2D sampler, vec4 P, float bias);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nivec4 textureProj(isampler2D sampler, vec4 P, float bias);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nuvec4 textureProj(usampler2D sampler, vec4 P, float bias);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nvec4 textureProj(sampler2D sampler, vec4 P);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nivec4 textureProj(isampler2D sampler, vec4 P);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nuvec4 textureProj(usampler2D sampler, vec4 P);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nvec4 textureProj(sampler3D sampler, vec4 P, float bias);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nivec4 textureProj(isampler3D sampler, vec4 P, float bias);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nuvec4 textureProj(usampler3D sampler, vec4 P, float bias);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nvec4 textureProj(sampler3D sampler, vec4 P);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nivec4 textureProj(isampler3D sampler, vec4 P);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `texture`.\nuvec4 textureProj(usampler3D sampler, vec4 P);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// The resulting 3rd component of `P` in the shadow forms is used as Dref\n// After these values are computed, the texture lookup proceeds as in `texture`.\nfloat textureProj(sampler2DShadow sampler, vec4 P, float bias);\n\n// `textureProj` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// The resulting 3rd component of `P` in the shadow forms is used as Dref\n// After these values are computed, the texture lookup proceeds as in `texture`.\nfloat textureProj(sampler2DShadow sampler, vec4 P);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nvec4 textureLod(sampler2D sampler, vec2 P, float lod);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nivec4 textureLod(isampler2D sampler, vec2 P, float lod);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nuvec4 textureLod(usampler2D sampler, vec2 P, float lod);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nvec4 textureLod(sampler3D sampler, vec3 P, float lod);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nivec4 textureLod(isampler3D sampler, vec3 P, float lod);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nuvec4 textureLod(usampler3D sampler, vec3 P, float lod);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nvec4 textureLod(samplerCube sampler, vec3 P, float lod);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nivec4 textureLod(isamplerCube sampler, vec3 P, float lod);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nuvec4 textureLod(usamplerCube sampler, vec3 P, float lod);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nfloat textureLod(sampler2DShadow sampler, vec3 P, float lod);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nvec4 textureLod(sampler2DArray sampler, vec3 P, float lod);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nivec4 textureLod(isampler2DArray sampler, vec3 P, float lod);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to sampler with an explicit level-of-detail as specified in `lod`.\nuvec4 textureLod(usampler2DArray sampler, vec3 P, float lod);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nvec4 textureOffset(sampler2D sampler, vec2 P, ivec2 offset, float bias);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nivec4 textureOffset(isampler2D sampler, vec2 P, ivec2 offset, float bias);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nuvec4 textureOffset(usampler2D sampler, vec2 P, ivec2 offset, float bias);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nvec4 textureOffset(sampler2D sampler, vec2 P, ivec2 offset);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nivec4 textureOffset(isampler2D sampler, vec2 P, ivec2 offset);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nuvec4 textureOffset(usampler2D sampler, vec2 P, ivec2 offset);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nvec4 textureOffset(sampler3D sampler, vec3 P, ivec3 offset, float bias);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nivec4 textureOffset(isampler3D sampler, vec3 P, ivec3 offset, float bias);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nuvec4 textureOffset(usampler3D sampler, vec3 P, ivec3 offset, float bias);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nvec4 textureOffset(sampler3D sampler, vec3 P, ivec3 offset);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nivec4 textureOffset(isampler3D sampler, vec3 P, ivec3 offset);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nuvec4 textureOffset(usampler3D sampler, vec3 P, ivec3 offset);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nfloat textureOffset(sampler2DShadow sampler, vec3 P, ivec2 offset, float bias);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nfloat textureOffset(sampler2DShadow sampler, vec3 P, ivec2 offset);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nvec4 textureOffset(sampler2DArray sampler, vec3 P, ivec2 offset, float bias);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nivec4 textureOffset(isampler2DArray sampler, vec3 P, ivec2 offset, float bias);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nuvec4 textureOffset(usampler2DArray sampler, vec3 P, ivec2 offset, float bias);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nvec4 textureOffset(sampler2DArray sampler, vec3 P, ivec2 offset);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nivec4 textureOffset(isampler2DArray sampler, vec3 P, ivec2 offset);\n\n// `textureOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an additional offset, specified in texels in `offset`\n// that will be applied to the (u, v, w) texture coordinates before looking up each texel.\n// The offset value must be a constant expression. A limited range of offset values are supported;\n// the minimum and maximum offset values are implementation-dependent and may be determined\n// by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`,\n// respectively.\n// Note that `offset` does not apply to the layer coordinate for texture arrays. Also note\n// that offsets are not supported for cube maps.\nuvec4 textureOffset(usampler2DArray sampler, vec3 P, ivec2 offset);\n\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched.\nvec4 texelFetch(sampler2D sampler, ivec2 P, int lod);\n\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched.\nivec4 texelFetch(isampler2D sampler, ivec2 P, int lod);\n\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched.\nuvec4 texelFetch(usampler2D sampler, ivec2 P, int lod);\n\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched.\nvec4 texelFetch(sampler3D sampler, ivec3 P, int lod);\n\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched.\nivec4 texelFetch(isampler3D sampler, ivec3 P, int lod);\n\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched.\nuvec4 texelFetch(usampler3D sampler, ivec3 P, int lod);\n\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched.\nvec4 texelFetch(sampler2DArray sampler, ivec3 P, int lod);\n\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched.\nivec4 texelFetch(isampler2DArray sampler, ivec3 P, int lod);\n\n// `texelFetch` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched.\nuvec4 texelFetch(usampler2DArray sampler, ivec3 P, int lod);\n\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\n// returned when reading from a multi-sample texure.\nvec4 texelFetchOffset(sampler2D sampler, ivec2 P, int lod, ivec2 offset);\n\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\n// returned when reading from a multi-sample texure.\nivec4 texelFetchOffset(isampler2D sampler, ivec2 P, int lod, ivec2 offset);\n\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\n// returned when reading from a multi-sample texure.\nuvec4 texelFetchOffset(usampler2D sampler, ivec2 P, int lod, ivec2 offset);\n\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\n// returned when reading from a multi-sample texure.\nvec4 texelFetchOffset(sampler3D sampler, ivec3 P, int lod, ivec3 offset);\n\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\n// returned when reading from a multi-sample texure.\nivec4 texelFetchOffset(isampler3D sampler, ivec3 P, int lod, ivec3 offset);\n\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\n// returned when reading from a multi-sample texure.\nuvec4 texelFetchOffset(usampler3D sampler, ivec3 P, int lod, ivec3 offset);\n\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\n// returned when reading from a multi-sample texure.\nvec4 texelFetchOffset(sampler2DArray sampler, ivec3 P, int lod, ivec2 offset);\n\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\n// returned when reading from a multi-sample texure.\nivec4 texelFetchOffset(isampler2DArray sampler, ivec3 P, int lod, ivec2 offset);\n\n// `texelFetchOffset` performs a lookup of a single texel from texture coordinate `P`\n// in the texture bound to `sampler`. Before fetching the texel, the offset specified in `offset`\n// is added to `P`. `offset` must be a constant expression. The array layer is specified in the last component of\n// `P` for array forms. The `lod` parameter (if present) specifies the level-of-detail\n// from which the texel will be fetched. The `sample` parameter specifies which sample within the texel will be\n// returned when reading from a multi-sample texure.\nuvec4 texelFetchOffset(usampler2DArray sampler, ivec3 P, int lod, ivec2 offset);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nvec4 textureProjOffset(sampler2D sampler, vec3 P, ivec2 offset, float bias);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nivec4 textureProjOffset(isampler2D sampler, vec3 P, ivec2 offset, float bias);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nuvec4 textureProjOffset(usampler2D sampler, vec3 P, ivec2 offset, float bias);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nvec4 textureProjOffset(sampler2D sampler, vec3 P, ivec2 offset);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nivec4 textureProjOffset(isampler2D sampler, vec3 P, ivec2 offset);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nuvec4 textureProjOffset(usampler2D sampler, vec3 P, ivec2 offset);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nvec4 textureProjOffset(sampler2D sampler, vec4 P, ivec2 offset, float bias);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nivec4 textureProjOffset(isampler2D sampler, vec4 P, ivec2 offset, float bias);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nuvec4 textureProjOffset(usampler2D sampler, vec4 P, ivec2 offset, float bias);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nvec4 textureProjOffset(sampler2D sampler, vec4 P, ivec2 offset);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nivec4 textureProjOffset(isampler2D sampler, vec4 P, ivec2 offset);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nuvec4 textureProjOffset(usampler2D sampler, vec4 P, ivec2 offset);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nvec4 textureProjOffset(sampler3D sampler, vec4 P, ivec3 offset, float bias);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nivec4 textureProjOffset(isampler3D sampler, vec4 P, ivec3 offset, float bias);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nuvec4 textureProjOffset(usampler3D sampler, vec4 P, ivec3 offset, float bias);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nvec4 textureProjOffset(sampler3D sampler, vec4 P, ivec3 offset);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nivec4 textureProjOffset(isampler3D sampler, vec4 P, ivec3 offset);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nuvec4 textureProjOffset(usampler3D sampler, vec4 P, ivec3 offset);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// The resulting 3rd component of `P` in the shadow forms is used as Dref\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nfloat textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, float bias);\n\n// `textureProjOffset` performs a texture lookup with projection.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// The resulting 3rd component of `P` in the shadow forms is used as Dref\n// After these values are computed, the texture lookup proceeds as in `textureOffset`,\n// with the `offset` used to offset the computed texture coordinates.\nfloat textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset);\n\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\n// Behavior is the same as in `textureLod` except that before\n// sampling, `offset` is added to `P`.\nvec4 textureLodOffset(sampler2D sampler, vec2 P, float lod, ivec2 offset);\n\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\n// Behavior is the same as in `textureLod` except that before\n// sampling, `offset` is added to `P`.\nivec4 textureLodOffset(isampler2D sampler, vec2 P, float lod, ivec2 offset);\n\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\n// Behavior is the same as in `textureLod` except that before\n// sampling, `offset` is added to `P`.\nuvec4 textureLodOffset(usampler2D sampler, vec2 P, float lod, ivec2 offset);\n\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\n// Behavior is the same as in `textureLod` except that before\n// sampling, `offset` is added to `P`.\nvec4 textureLodOffset(sampler3D sampler, vec3 P, float lod, ivec3 offset);\n\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\n// Behavior is the same as in `textureLod` except that before\n// sampling, `offset` is added to `P`.\nivec4 textureLodOffset(isampler3D sampler, vec3 P, float lod, ivec3 offset);\n\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\n// Behavior is the same as in `textureLod` except that before\n// sampling, `offset` is added to `P`.\nuvec4 textureLodOffset(usampler3D sampler, vec3 P, float lod, ivec3 offset);\n\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\n// Behavior is the same as in `textureLod` except that before\n// sampling, `offset` is added to `P`.\nfloat textureLodOffset(sampler2DShadow sampler, vec3 P, float lod, ivec2 offset);\n\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\n// Behavior is the same as in `textureLod` except that before\n// sampling, `offset` is added to `P`.\nvec4 textureLodOffset(sampler2DArray sampler, vec3 P, float lod, ivec2 offset);\n\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\n// Behavior is the same as in `textureLod` except that before\n// sampling, `offset` is added to `P`.\nivec4 textureLodOffset(isampler2DArray sampler, vec3 P, float lod, ivec2 offset);\n\n// `textureLodOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with an explicit level-of-detail as specified in `lod`.\n// Behavior is the same as in `textureLod` except that before\n// sampling, `offset` is added to `P`.\nuvec4 textureLodOffset(usampler2DArray sampler, vec3 P, float lod, ivec2 offset);\n\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\nvec4 textureProjLod(sampler2D sampler, vec3 P, float lod);\n\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\nivec4 textureProjLod(isampler2D sampler, vec3 P, float lod);\n\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\nuvec4 textureProjLod(usampler2D sampler, vec3 P, float lod);\n\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\nvec4 textureProjLod(sampler2D sampler, vec4 P, float lod);\n\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\nivec4 textureProjLod(isampler2D sampler, vec4 P, float lod);\n\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\nuvec4 textureProjLod(usampler2D sampler, vec4 P, float lod);\n\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\nvec4 textureProjLod(sampler3D sampler, vec4 P, float lod);\n\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\nivec4 textureProjLod(isampler3D sampler, vec4 P, float lod);\n\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\nuvec4 textureProjLod(usampler3D sampler, vec4 P, float lod);\n\n// `textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// The resulting 3rd component of `P` in the shadow forms is used as Dref\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled\nfloat textureProjLod(sampler2DShadow sampler, vec4 P, float lod);\n\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \n// level-of-detail with an offset applied to the texture coordinates before sampling.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\nvec4 textureProjLodOffset(sampler2D sampler, vec3 P, float lod, ivec2 offset);\n\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \n// level-of-detail with an offset applied to the texture coordinates before sampling.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\nivec4 textureProjLodOffset(isampler2D sampler, vec3 P, float lod, ivec2 offset);\n\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \n// level-of-detail with an offset applied to the texture coordinates before sampling.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\nuvec4 textureProjLodOffset(usampler2D sampler, vec3 P, float lod, ivec2 offset);\n\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \n// level-of-detail with an offset applied to the texture coordinates before sampling.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\nvec4 textureProjLodOffset(sampler2D sampler, vec4 P, float lod, ivec2 offset);\n\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \n// level-of-detail with an offset applied to the texture coordinates before sampling.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\nivec4 textureProjLodOffset(isampler2D sampler, vec4 P, float lod, ivec2 offset);\n\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \n// level-of-detail with an offset applied to the texture coordinates before sampling.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\nuvec4 textureProjLodOffset(usampler2D sampler, vec4 P, float lod, ivec2 offset);\n\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \n// level-of-detail with an offset applied to the texture coordinates before sampling.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\nvec4 textureProjLodOffset(sampler3D sampler, vec4 P, float lod, ivec3 offset);\n\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \n// level-of-detail with an offset applied to the texture coordinates before sampling.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\nivec4 textureProjLodOffset(isampler3D sampler, vec4 P, float lod, ivec3 offset);\n\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \n// level-of-detail with an offset applied to the texture coordinates before sampling.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\nuvec4 textureProjLodOffset(usampler3D sampler, vec4 P, float lod, ivec3 offset);\n\n// `textureProjLodOffset` performs a texture lookup with projection from an explicitly specified \n// level-of-detail with an offset applied to the texture coordinates before sampling.\n// The texture coordinates consumed from `P`, not including the last component of `P`,\n// are divided by the last component of `P`.\n// The resulting 3rd component of `P` in the shadow forms is used as Dref\n// After these values are computed, the texture lookup proceeds as in `textureLod`,\n// with `lod` used to specify the level-of-detail from which the texture will be sampled \n// and `offset` used to specify the offset, in texels, to be applied to the texture coordinates before sampling.\nfloat textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, ivec2 offset);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nvec4 textureGrad(sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nivec4 textureGrad(isampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nuvec4 textureGrad(usampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nvec4 textureGrad(sampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nivec4 textureGrad(isampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nuvec4 textureGrad(usampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nvec4 textureGrad(samplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nivec4 textureGrad(isamplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nuvec4 textureGrad(usamplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nfloat textureGrad(sampler2DShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nfloat textureGrad(samplerCubeShadow sampler, vec4 P, vec3 dPdx, vec3 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nvec4 textureGrad(sampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nivec4 textureGrad(isampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nuvec4 textureGrad(usampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nfloat textureGrad(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nfloat textureGrad(isampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy);\n\n// Performs a texture lookup at coordinate `P` from the texture bound to `sampler` with explicit\n// texture coordinate gradients as specified in `dPdx` and `dPdy`\nfloat textureGrad(usampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy);\n\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\n// `textureGrad` and `offset` as\n// `textureOffset`.\nvec4 textureGradOffset(sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\n// `textureGrad` and `offset` as\n// `textureOffset`.\nivec4 textureGradOffset(isampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\n// `textureGrad` and `offset` as\n// `textureOffset`.\nuvec4 textureGradOffset(usampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\n// `textureGrad` and `offset` as\n// `textureOffset`.\nvec4 textureGradOffset(sampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy, ivec3 offset);\n\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\n// `textureGrad` and `offset` as\n// `textureOffset`.\nivec4 textureGradOffset(isampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy, ivec3 offset);\n\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\n// `textureGrad` and `offset` as\n// `textureOffset`.\nuvec4 textureGradOffset(usampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy, ivec3 offset);\n\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\n// `textureGrad` and `offset` as\n// `textureOffset`.\nfloat textureGradOffset(sampler2DShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\n// `textureGrad` and `offset` as\n// `textureOffset`.\nvec4 textureGradOffset(sampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\n// `textureGrad` and `offset` as\n// `textureOffset`.\nivec4 textureGradOffset(isampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\n// `textureGrad` and `offset` as\n// `textureOffset`.\nuvec4 textureGradOffset(usampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// `textureGradOffset` performs a texture lookup at coordinate `P` from the\n// texture bound to `sampler` with explicit texture coordinate gradiends as specified in\n// `dPdx` and `dPdy`. An explicit offset is also supplied in `offset`.\n// `textureGradOffset` consumes `dPdx` and `dPdy` as\n// `textureGrad` and `offset` as\n// `textureOffset`.\nfloat textureGradOffset(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// Perform a texture lookup with projection and explicit gradients\nvec4 textureProjGrad(sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\n\n// Perform a texture lookup with projection and explicit gradients\nivec4 textureProjGrad(isampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\n\n// Perform a texture lookup with projection and explicit gradients\nuvec4 textureProjGrad(usampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\n\n// Perform a texture lookup with projection and explicit gradients\nvec4 textureProjGrad(sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\n\n// Perform a texture lookup with projection and explicit gradients\nivec4 textureProjGrad(isampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\n\n// Perform a texture lookup with projection and explicit gradients\nuvec4 textureProjGrad(usampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\n\n// Perform a texture lookup with projection and explicit gradients\nvec4 textureProjGrad(sampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy);\n\n// Perform a texture lookup with projection and explicit gradients\nivec4 textureProjGrad(isampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy);\n\n// Perform a texture lookup with projection and explicit gradients\nuvec4 textureProjGrad(usampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy);\n\n// Perform a texture lookup with projection and explicit gradients\nfloat textureProjGrad(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy);\n\n// Perform a texture lookup with projection, explicit gradients and offset\nvec4 textureProjGradOffset(sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// Perform a texture lookup with projection, explicit gradients and offset\nivec4 textureProjGradOffset(isampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// Perform a texture lookup with projection, explicit gradients and offset\nuvec4 textureProjGradOffset(usampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// Perform a texture lookup with projection, explicit gradients and offset\nvec4 textureProjGradOffset(sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// Perform a texture lookup with projection, explicit gradients and offset\nivec4 textureProjGradOffset(isampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// Perform a texture lookup with projection, explicit gradients and offset\nuvec4 textureProjGradOffset(usampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// Perform a texture lookup with projection, explicit gradients and offset\nvec4 textureProjGradOffset(sampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy, ivec3 offset);\n\n// Perform a texture lookup with projection, explicit gradients and offset\nivec4 textureProjGradOffset(isampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy, ivec3 offset);\n\n// Perform a texture lookup with projection, explicit gradients and offset\nuvec4 textureProjGradOffset(usampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy, ivec3 offset);\n\n// Perform a texture lookup with projection, explicit gradients and offset\nfloat textureProjGradOffset(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);\n\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\n// via non-uniform control flow may be undefined.\nfloat dFdx(float p);\n\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\n// via non-uniform control flow may be undefined.\nvec2 dFdx(vec2 p);\n\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\n// via non-uniform control flow may be undefined.\nvec3 dFdx(vec3 p);\n\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\n// via non-uniform control flow may be undefined.\nvec4 dFdx(vec4 p);\n\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\n// via non-uniform control flow may be undefined.\nfloat dFdy(float p);\n\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\n// via non-uniform control flow may be undefined.\nvec2 dFdy(vec2 p);\n\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\n// via non-uniform control flow may be undefined.\nvec3 dFdy(vec3 p);\n\n// _Available only in the fragment shader_, `dFdx` and `dFdy`\n// return the partial derivative of expression `p` in x and y, respectively. Deviatives are calculated\n// using local differencing. Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined\n// results, as do mixed-order derivatives such as `dFdx(dFdy(n))`.\n// It is assumed that the expression `p` is continuous and therefore, expressions evaluated\n// via non-uniform control flow may be undefined.\nvec4 dFdy(vec4 p);\n\n// _Available only in the fragment shader_, `fwidth` returns the sum of\n// the absolute derivatives in x and y using local differencing for the input argument `p`.\n// It is equivalent to `abs(dFdx(p)) + abs(dFdy(p))`.\nfloat fwidth(float p);\n\n// _Available only in the fragment shader_, `fwidth` returns the sum of\n// the absolute derivatives in x and y using local differencing for the input argument `p`.\n// It is equivalent to `abs(dFdx(p)) + abs(dFdy(p))`.\nvec2 fwidth(vec2 p);\n\n// _Available only in the fragment shader_, `fwidth` returns the sum of\n// the absolute derivatives in x and y using local differencing for the input argument `p`.\n// It is equivalent to `abs(dFdx(p)) + abs(dFdy(p))`.\nvec3 fwidth(vec3 p);\n\n// _Available only in the fragment shader_, `fwidth` returns the sum of\n// the absolute derivatives in x and y using local differencing for the input argument `p`.\n// It is equivalent to `abs(dFdx(p)) + abs(dFdy(p))`.\nvec4 fwidth(vec4 p);\n\n\n\n}"},eb76:function(e,t,n){"use strict";function r(e){if(!e)throw Error("Assertion failed")}function o(e,t,n){return r(0<=t&&t<e.length),e[t]=n}function i(e){r(!(0===e.length)),e.pop()}function a(e,t){return r(0<=t&&t<e.length),e[t]}function s(e){return r(!(0===e.length)),a(e,e.length-1)}function l(e,t){r(t!==e);for(const n of t)e.push(n)}function u(e,t){let n=0;for(let r=0,i=e.length;r<i;r+=1)t(a(e,r))||(n<r&&o(e,n,a(e,r)),n+=1);while(n<e.length)i(e)}function c(e){return r(!(0===e.length)),a(e,0)}function d(e){return r(!(0===e.length)),e.pop()}function f(e,t,n){return e.set(t,n),n}function h(e,t,n){return e.set(t,n),e}function p(e,t,n){let r=e.get(t);return void 0!==r?r:n}function m(e,t){return r(e.has(t)),e.get(t)}function x(e,t,n){return e.set(t,n),n}function v(e,t,n){let r=e.get(t);return void 0!==r?r:n}function y(e,t){return(t<e|0)-(t>e|0)}function g(e,t){return r(0<=t&&t<=e.length),e.slice(t)}function T(e,t,n){return r(0<=t&&t<=n&&n<=e.length),e.slice(t,n)}function E(e,t){return r(0<=t&&t<e.length),e.charCodeAt(t)}function b(e,t){return r(0<=t&&t<e.length),e[t]}n.r(t),n.d(t,"sourcesFromInput",(function(){return Qt})),n.d(t,"wrapFileAccess",(function(){return Kt})),n.d(t,"main",(function(){return Jt})),n.d(t,"rangeToJSON",(function(){return Zt})),n.d(t,"compileIDE",(function(){return en}));let P=e=>null===e?e:e+"",I="<api>";var A,w;(function(e){e[e["ATTRIBUTE"]=1]="ATTRIBUTE",e[e["CONST"]=2]="CONST",e[e["HIGHP"]=4]="HIGHP",e[e["IN"]=8]="IN",e[e["INOUT"]=16]="INOUT",e[e["LOWP"]=32]="LOWP",e[e["MEDIUMP"]=64]="MEDIUMP",e[e["OUT"]=128]="OUT",e[e["UNIFORM"]=256]="UNIFORM",e[e["VARYING"]=512]="VARYING",e[e["EXPORTED"]=1024]="EXPORTED",e[e["IMPORTED"]=2048]="IMPORTED"})(A||(A={}));class R{constructor(e,t){this.name=e,this.value=t}}class _{constructor(e,t,n,r){this.id=e,this.range=t,this.name=n,this.scope=r,this.flags=0,this.comments=null,this.constantValue=null,this.requiredExtension=null,this._resolvedType=null,this.useCount=0}isConst(){return 0!==(A.CONST&this.flags)}isUniform(){return 0!==(A.UNIFORM&this.flags)}isExported(){return 0!==(A.EXPORTED&this.flags)}isStruct(){return this instanceof S}isFunction(){return this instanceof C}isVariable(){return this instanceof O}isNative(){return this.id<0}asStruct(){return r(this.isStruct()),this}asFunction(){return r(this.isFunction()),this}asVariable(){return r(this.isVariable()),this}resolvedType(){return null===this._resolvedType&&(this._resolvedType=new N(this,null,0)),this._resolvedType}}class S extends _{constructor(e,t,n,r){super(e,t,n,r),this.variables=[]}}class C extends _{constructor(e,t,n,r){super(e,t,n,r),this._arguments=[],this.returnType=null,this.block=null,this.previousOverload=null,this.sibling=null}hasSameArgumentTypesAs(e){if(this._arguments.length!==e._arguments.length)return!1;for(let t=0,n=this._arguments.length;t<n;t+=1)if(a(this._arguments,t).type.resolvedType!==a(e._arguments,t).type.resolvedType)return!1;return!0}}class O extends _{constructor(e,t,n,r,o){super(e,t,n,r),this.kind=o,this.type=null,this.node=null,this.arrayCount=null}value(){let e;return null!==(e=this.node)?e.variableInitializer():null}}function L(e){let t="";return 0!==(A.ATTRIBUTE&e)&&(t+="attribute "),0!==(A.CONST&e)&&(t+="const "),0!==(A.UNIFORM&e)&&(t+="uniform "),0!==(A.VARYING&e)&&(t+="varying "),0!==(A.HIGHP&e)&&(t+="highp "),0!==(A.LOWP&e)&&(t+="lowp "),0!==(A.MEDIUMP&e)&&(t+="mediump "),0!==(A.IN&e)&&(t+="in "),0!==(A.INOUT&e)&&(t+="inout "),0!==(A.OUT&e)&&(t+="out "),t}class N{constructor(e,t,n){this.symbol=e,this.isArrayOf=t,this.arrayCount=n,this.containsArray=!1,this.containsSampler=!1,this._arrayTypes=null}arrayType(e){r(e>=0),null===this._arrayTypes&&(this._arrayTypes=new Map);let t=v(this._arrayTypes,e,null);return null===t&&(x(this._arrayTypes,e,t=new N(null,this,e)),t.containsArray=!0,t.containsSampler=this.containsSampler),t}toString(){return null!==this.isArrayOf?0!==this.arrayCount?`${this.isArrayOf}[${this.arrayCount}]`:this.isArrayOf+"[]":this.symbol.name}indexCount(){let e=this;return e===N.UVEC2||e===N.BVEC2||e===N.VEC2||e===N.IVEC2||e===N.MAT2?2:e===N.UVEC3||e===N.BVEC3||e===N.VEC3||e===N.IVEC3||e===N.MAT3?3:e===N.UVEC4||e===N.BVEC4||e===N.VEC4||e===N.IVEC4||e===N.MAT4?4:this.arrayCount}indexType(){let e=this;return e===N.BVEC2||e===N.BVEC3||e===N.BVEC4?N.BOOL:e===N.VEC2||e===N.VEC3||e===N.VEC4?N.FLOAT:e===N.IVEC2||e===N.IVEC3||e===N.IVEC4?N.INT:e===N.UVEC2||e===N.UVEC3||e===N.UVEC4?N.UINT:e===N.MAT2?N.VEC2:e===N.MAT3?N.VEC3:e===N.MAT4?N.VEC4:this.isArrayOf}componentCount(){let e=this;return e===N.BOOL||e===N.FLOAT||e===N.INT||e===N.UINT?1:e===N.BVEC2||e===N.VEC2||e===N.IVEC2||e===N.UVEC2?2:e===N.BVEC3||e===N.VEC3||e===N.IVEC3||e===N.UVEC3?3:e===N.BVEC4||e===N.VEC4||e===N.IVEC4||e===N.MAT2||e===N.UVEC4?4:e===N.MAT3?9:e===N.MAT4?16:0}componentType(){let e=this;return e===N.BOOL||e===N.BVEC2||e===N.BVEC3||e===N.BVEC4?N.BOOL:e===N.FLOAT||e===N.VEC2||e===N.VEC3||e===N.VEC4||e===N.MAT2||e===N.MAT3||e===N.MAT4?N.FLOAT:e===N.INT||e===N.IVEC2||e===N.IVEC3||e===N.IVEC4?N.INT:e===N.UINT||e===N.UVEC2||e===N.UVEC3||e===N.UVEC4?N.UINT:null}isVector(){let e=this;return e===N.BVEC2||e===N.BVEC3||e===N.BVEC4||e===N.IVEC2||e===N.IVEC3||e===N.IVEC4||e===N.VEC2||e===N.VEC3||e===N.VEC4||e===N.UVEC2||e===N.UVEC3||e===N.UVEC3||e===N.UVEC4}isMatrix(){let e=this;return e===N.MAT2||e===N.MAT3||e===N.MAT4}hasIntComponents(){let e=this;return e===N.INT||e===N.IVEC2||e===N.IVEC3||e===N.IVEC4||e===N.UINT}hasFloatComponents(){let e=this;return e===N.FLOAT||e===N.VEC2||e===N.VEC3||e===N.VEC4||(e===N.MAT2||e===N.MAT3||e===N.MAT4)}isIntOrFloat(){return this.hasIntComponents()||this.hasFloatComponents()}canUseEqualityOperators(){return!this.containsSampler&&!this.containsArray}_setContainsSampler(){return this.containsSampler=!0,this}}N.BOOL=new S(-1,null,"bool",null).resolvedType(),N.BVEC2=new S(-2,null,"bvec2",null).resolvedType(),N.BVEC3=new S(-3,null,"bvec3",null).resolvedType(),N.BVEC4=new S(-4,null,"bvec4",null).resolvedType(),N.ERROR=new S(-5,null,"<error>",null).resolvedType(),N.FLOAT=new S(-6,null,"float",null).resolvedType(),N.INT=new S(-7,null,"int",null).resolvedType(),N.UINT=new S(-8,null,"uint",null).resolvedType(),N.IVEC2=new S(-9,null,"ivec2",null).resolvedType(),N.IVEC3=new S(-10,null,"ivec3",null).resolvedType(),N.IVEC4=new S(-11,null,"ivec4",null).resolvedType(),N.UVEC2=new S(-12,null,"uvec2",null).resolvedType(),N.UVEC3=new S(-13,null,"uvec3",null).resolvedType(),N.UVEC4=new S(-14,null,"uvec4",null).resolvedType(),N.MAT2=new S(-15,null,"mat2",null).resolvedType(),N.MAT3=new S(-16,null,"mat3",null).resolvedType(),N.MAT4=new S(-17,null,"mat4",null).resolvedType(),N.SAMPLER2D=new S(-18,null,"sampler2D",null).resolvedType()._setContainsSampler(),N.SAMPLERCUBE=new S(-19,null,"samplerCube",null).resolvedType()._setContainsSampler(),N.VEC2=new S(-20,null,"vec2",null).resolvedType(),N.VEC3=new S(-21,null,"vec3",null).resolvedType(),N.VEC4=new S(-22,null,"vec4",null).resolvedType(),N.VOID=new S(-23,null,"void",null).resolvedType(),N.SAMPLER3D=new S(-24,null,"sampler3D",null).resolvedType()._setContainsSampler(),N.ISAMPLERCUBE=new S(-25,null,"isamplerCube",null).resolvedType()._setContainsSampler(),N.USAMPLERCUBE=new S(-26,null,"usamplerCube",null).resolvedType()._setContainsSampler(),N.SAMPLER2DARRAY=new S(-27,null,"sampler2DArray",null).resolvedType()._setContainsSampler(),N.ISAMPLER2DARRAY=new S(-28,null,"isampler2DArray",null).resolvedType()._setContainsSampler(),N.USAMPLER2DARRAY=new S(-29,null,"usampler2DArray",null).resolvedType()._setContainsSampler(),N.SAMPLER2DSHADOW=new S(-30,null,"sampler2DShadow",null).resolvedType()._setContainsSampler(),N.SAMPLERCUBESHADOW=new S(-31,null,"samplerCubeShadow",null).resolvedType()._setContainsSampler(),N.SAMPLER2DARRAYSHADOW=new S(-32,null,"sampler2DArrayShadow",null).resolvedType()._setContainsSampler(),N.USAMPLER2DARRAYSHADOW=new S(-33,null,"usampler2DArrayShadow",null).resolvedType()._setContainsSampler(),N.ISAMPLER2D=new S(-34,null,"isampler2D",null).resolvedType()._setContainsSampler(),N.USAMPLER2D=new S(-35,null,"usampler2D",null).resolvedType()._setContainsSampler(),N.ISAMPLER3D=new S(-36,null,"isampler3D",null).resolvedType()._setContainsSampler(),N.USAMPLER3D=new S(-37,null,"usampler3D",null).resolvedType()._setContainsSampler(),N.ISAMPLER2DARRAYSHADOW=new S(-38,null,"isampler2DArrayShadow",null).resolvedType()._setContainsSampler(),N.BUILT_INS=[N.BOOL,N.BVEC2,N.BVEC3,N.BVEC4,N.FLOAT,N.INT,N.UINT,N.IVEC2,N.IVEC3,N.IVEC4,N.UVEC2,N.UVEC3,N.UVEC4,N.MAT2,N.MAT3,N.MAT4,N.SAMPLER2D,N.SAMPLERCUBE,N.VEC2,N.VEC3,N.VEC4,N.SAMPLER3D,N.ISAMPLERCUBE,N.USAMPLERCUBE,N.SAMPLER2DARRAY,N.ISAMPLER2DARRAY,N.USAMPLER2DARRAY,N.SAMPLER2DSHADOW,N.SAMPLERCUBESHADOW,N.SAMPLER2DARRAYSHADOW,N.USAMPLER2DARRAYSHADOW,N.ISAMPLER2D,N.USAMPLER2D,N.ISAMPLER3D,N.USAMPLER3D,N.ISAMPLER2DARRAYSHADOW],function(e){e[e["GLOBAL"]=0]="GLOBAL",e[e["STRUCT_BLOCK"]=1]="STRUCT_BLOCK",e[e["VARIABLE"]=2]="VARIABLE",e[e["BLOCK"]=3]="BLOCK",e[e["BREAK"]=4]="BREAK",e[e["CONTINUE"]=5]="CONTINUE",e[e["DISCARD"]=6]="DISCARD",e[e["DO_WHILE"]=7]="DO_WHILE",e[e["EXPRESSION"]=8]="EXPRESSION",e[e["EXTENSION"]=9]="EXTENSION",e[e["DEFINE"]=10]="DEFINE",e[e["FOR"]=11]="FOR",e[e["FUNCTION"]=12]="FUNCTION",e[e["IF"]=13]="IF",e[e["MODIFIER_BLOCK"]=14]="MODIFIER_BLOCK",e[e["PRECISION"]=15]="PRECISION",e[e["RETURN"]=16]="RETURN",e[e["STRUCT"]=17]="STRUCT",e[e["VARIABLES"]=18]="VARIABLES",e[e["VERSION"]=19]="VERSION",e[e["WHILE"]=20]="WHILE",e[e["CALL"]=21]="CALL",e[e["DOT"]=22]="DOT",e[e["HOOK"]=23]="HOOK",e[e["NAME"]=24]="NAME",e[e["PARSE_ERROR"]=25]="PARSE_ERROR",e[e["SEQUENCE"]=26]="SEQUENCE",e[e["TYPE"]=27]="TYPE",e[e["UNKNOWN_CONSTANT"]=28]="UNKNOWN_CONSTANT",e[e["BOOL"]=29]="BOOL",e[e["FLOAT"]=30]="FLOAT",e[e["INT"]=31]="INT",e[e["NEGATIVE"]=32]="NEGATIVE",e[e["NOT"]=33]="NOT",e[e["POSITIVE"]=34]="POSITIVE",e[e["PREFIX_DECREMENT"]=35]="PREFIX_DECREMENT",e[e["PREFIX_INCREMENT"]=36]="PREFIX_INCREMENT",e[e["POSTFIX_DECREMENT"]=37]="POSTFIX_DECREMENT",e[e["POSTFIX_INCREMENT"]=38]="POSTFIX_INCREMENT",e[e["ADD"]=39]="ADD",e[e["DIVIDE"]=40]="DIVIDE",e[e["EQUAL"]=41]="EQUAL",e[e["GREATER_THAN"]=42]="GREATER_THAN",e[e["GREATER_THAN_OR_EQUAL"]=43]="GREATER_THAN_OR_EQUAL",e[e["INDEX"]=44]="INDEX",e[e["LESS_THAN"]=45]="LESS_THAN",e[e["LESS_THAN_OR_EQUAL"]=46]="LESS_THAN_OR_EQUAL",e[e["LOGICAL_AND"]=47]="LOGICAL_AND",e[e["LOGICAL_OR"]=48]="LOGICAL_OR",e[e["LOGICAL_XOR"]=49]="LOGICAL_XOR",e[e["MULTIPLY"]=50]="MULTIPLY",e[e["NOT_EQUAL"]=51]="NOT_EQUAL",e[e["SUBTRACT"]=52]="SUBTRACT",e[e["ASSIGN"]=53]="ASSIGN",e[e["ASSIGN_ADD"]=54]="ASSIGN_ADD",e[e["ASSIGN_DIVIDE"]=55]="ASSIGN_DIVIDE",e[e["ASSIGN_MULTIPLY"]=56]="ASSIGN_MULTIPLY",e[e["ASSIGN_SUBTRACT"]=57]="ASSIGN_SUBTRACT"}(w||(w={}));class k{constructor(e){this.id=k._createID(),this.kind=e,this.range=null,this.internalRange=null,this.symbol=null,this.resolvedType=null,this._literal=0,this._text=null,this._parent=null,this._firstChild=null,this._lastChild=null,this._previousSibling=null,this._nextSibling=null,this.hasControlFlowAtEnd=!1}_copyMembersFrom(e){this.kind=e.kind,this.range=e.range,this.internalRange=e.internalRange,this.symbol=e.symbol,this.resolvedType=e.resolvedType,this._literal=e._literal,this._text=e._text}cloneWithoutChildren(){let e=new k(this.kind);return e._copyMembersFrom(this),e}clone(){let e=this.cloneWithoutChildren();for(let t=this._firstChild;null!==t;t=t._nextSibling)e.appendChild(t.clone());return e}parent(){return this._parent}firstChild(){return this._firstChild}lastChild(){return this._lastChild}previousSibling(){return this._previousSibling}nextSibling(){return this._nextSibling}hasChildren(){return null!==this._firstChild}childCount(){let e=0;for(let t=this._firstChild;null!==t;t=t._nextSibling)e+=1;return e}childAt(e){r(0<=e&&e<this.childCount());let t=this._firstChild;while(0!==e)t=t._nextSibling,e-=1;return t}withType(e){return this.resolvedType=e,this}withSymbol(e){return this.symbol=e,this}withBool(e){return this._literal=e?1:0,this}withInt(e){return this._literal=e,this}withFloat(e){return this._literal=e,this}withText(e){return this._text=e,this}withRange(e){return this.range=e,this}withInternalRange(e){return this.internalRange=e,this}appendChild(e){return null===e||(r(e!==this),r(null===e._parent),r(null===e._previousSibling),r(null===e._nextSibling),e._parent=this,this.hasChildren()?(e._previousSibling=this._lastChild,this._lastChild._nextSibling=e,this._lastChild=e):this._lastChild=this._firstChild=e),this}remove(){return r(null!==this._parent),null!==this._previousSibling?(r(this._previousSibling._nextSibling===this),this._previousSibling._nextSibling=this._nextSibling):(r(this._parent._firstChild===this),this._parent._firstChild=this._nextSibling),null!==this._nextSibling?(r(this._nextSibling._previousSibling===this),this._nextSibling._previousSibling=this._previousSibling):(r(this._parent._lastChild===this),this._parent._lastChild=this._previousSibling),this._parent=null,this._previousSibling=null,this._nextSibling=null,this}insertChildBefore(e,t){return null===t?this:(r(t!==e),r(null===t._parent),r(null===t._previousSibling),r(null===t._nextSibling),r(null===e||e._parent===this),null===e?this.appendChild(t):(t._parent=this,t._previousSibling=e._previousSibling,t._nextSibling=e,null!==e._previousSibling?(r(e===e._previousSibling._nextSibling),e._previousSibling._nextSibling=t):(r(e===this._firstChild),this._firstChild=t),e._previousSibling=t,this))}isTrue(){return this.kind===w.BOOL&&this.asBool()}isFalse(){return this.kind===w.BOOL&&!this.asBool()}isCallTarget(){return null!==this.parent()&&this.parent().kind===w.CALL&&this.parent().callTarget()===this}isAssignTarget(){return null!==this.parent()&&(U(this.parent().kind)||j(this.parent().kind)&&this.parent().binaryLeft()===this)}isEmptySequence(){return this.kind===w.SEQUENCE&&!this.hasChildren()}looksTheSameAs(e){if(this.kind===e.kind)switch(this.kind){case w.BOOL:return this.asBool()===e.asBool();case w.FLOAT:return this.asFloat()===e.asFloat();case w.INT:return this.asInt()===e.asInt();case w.NAME:return this.symbol===e.symbol;case w.TYPE:return this.resolvedType===e.resolvedType;case w.DOT:return this.dotTarget().looksTheSameAs(e.dotTarget())&&this.symbol===e.symbol&&this.asString()===e.asString();case w.HOOK:return this.hookTest().looksTheSameAs(e.hookTest())&&this.hookTrue().looksTheSameAs(e.hookTrue())&&this.hookFalse().looksTheSameAs(e.hookFalse());case w.CALL:{let t=this.firstChild(),n=e.firstChild();while(null!==t&&null!==n){if(!t.looksTheSameAs(n))return!1;t=t.nextSibling(),n=n.nextSibling()}return null===t&&null===n}default:if(M(this.kind))return this.unaryValue().looksTheSameAs(e.unaryValue());if(G(this.kind))return this.binaryLeft().looksTheSameAs(e.binaryLeft())&&this.binaryRight().looksTheSameAs(e.binaryRight());break}return!1}static createGlobal(){return new k(w.GLOBAL)}static createStructBlock(){return new k(w.STRUCT_BLOCK)}static createVariable(e,t){return new k(w.VARIABLE).withSymbol(e).appendChild(t)}static createBlock(){return new k(w.BLOCK)}static createBreak(){return new k(w.BREAK)}static createContinue(){return new k(w.CONTINUE)}static createDiscard(){return new k(w.DISCARD)}static createDoWhile(e,t){return r(D(e.kind)),r(F(t.kind)),new k(w.DO_WHILE).appendChild(e).appendChild(t)}static createExpression(e){return r(F(e.kind)),new k(w.EXPRESSION).appendChild(e)}static createExtension(e,t){return new k(w.EXTENSION).withText(e).withInt(t)}static createDefine(){return new k(w.DEFINE)}static createFor(e,t,n,o){return r(null===e||F(e.kind)||e.kind===w.VARIABLES),r(null===t||F(t.kind)),r(null===n||F(n.kind)),r(D(o.kind)),new k(w.FOR).appendChild(null===e?k.createSequence():e).appendChild(null===t?k.createSequence():t).appendChild(null===n?k.createSequence():n).appendChild(o)}static createFunction(e){return new k(w.FUNCTION).withSymbol(e)}static createIf(e,t,n){return r(F(e.kind)),r(D(t.kind)),r(null===n||D(n.kind)),new k(w.IF).appendChild(e).appendChild(t).appendChild(n)}static createModifierBlock(){return new k(w.MODIFIER_BLOCK)}static createPrecision(e,t){return r(F(t.kind)),new k(w.PRECISION).withInt(e).appendChild(t)}static createReturn(e){return r(null===e||F(e.kind)),new k(w.RETURN).appendChild(e)}static createStruct(e,t,n){return r(t.kind===w.STRUCT_BLOCK),r(null===n||n.kind===w.VARIABLES),new k(w.STRUCT).withSymbol(e).appendChild(t).appendChild(n)}static createVariables(e,t){return r(F(t.kind)),new k(w.VARIABLES).withInt(e).appendChild(t)}static createVersion(e){return new k(w.VERSION).withInt(e)}static createWhile(e,t){return r(F(e.kind)),r(D(t.kind)),new k(w.WHILE).appendChild(e).appendChild(t)}static createCall(e){return r(F(e.kind)),new k(w.CALL).appendChild(e)}static createConstructorCall(e){return k.createCall(k.createType(e)).withType(e)}static createDot(e,t){return r(F(e.kind)),r(null!==t),new k(w.DOT).appendChild(e).withText(t)}static createHook(e,t,n){return r(F(e.kind)),r(F(t.kind)),r(F(n.kind)),new k(w.HOOK).appendChild(e).appendChild(t).appendChild(n)}static createName(e){return new k(w.NAME).withSymbol(e)}static createParseError(){return new k(w.PARSE_ERROR).withType(N.ERROR)}static createSequence(){return new k(w.SEQUENCE)}static createType(e){return new k(w.TYPE).withType(e)}static createUnknownConstant(e){return new k(w.UNKNOWN_CONSTANT).withType(e)}static createBool(e){return new k(w.BOOL).withBool(e).withType(N.BOOL)}static createInt(e){return new k(w.INT).withInt(e).withType(N.INT)}static createFloat(e){return new k(w.FLOAT).withFloat(e).withType(N.FLOAT)}static createUnary(e,t){return r(M(e)),new k(e).appendChild(t)}static createBinary(e,t,n){return r(G(e)),new k(e).appendChild(t).appendChild(n)}variableInitializer(){return r(this.kind===w.VARIABLE),r(this.childCount()<=1),this._firstChild}doWhileBody(){return r(this.kind===w.DO_WHILE),r(2===this.childCount()),r(D(this._firstChild.kind)),this._firstChild}doWhileTest(){return r(this.kind===w.DO_WHILE),r(2===this.childCount()),r(F(this._lastChild.kind)),this._lastChild}expressionValue(){return r(this.kind===w.EXPRESSION),r(1===this.childCount()),r(F(this._firstChild.kind)),this._firstChild}forSetup(){return r(this.kind===w.FOR),r(4===this.childCount()),r(F(this._firstChild.kind)||this._firstChild.kind===w.VARIABLES),this._firstChild.isEmptySequence()?null:this._firstChild}forTest(){return r(this.kind===w.FOR),r(4===this.childCount()),r(F(this._firstChild._nextSibling.kind)||this._firstChild._nextSibling.kind===w.VARIABLES),this._firstChild._nextSibling.isEmptySequence()?null:this._firstChild._nextSibling}forUpdate(){return r(this.kind===w.FOR),r(4===this.childCount()),r(F(this._lastChild._previousSibling.kind)),this._lastChild._previousSibling.isEmptySequence()?null:this._lastChild._previousSibling}forBody(){return r(this.kind===w.FOR),r(4===this.childCount()),r(D(this._lastChild.kind)),this._lastChild}ifTest(){return r(this.kind===w.IF),r(2===this.childCount()||3===this.childCount()),r(F(this._firstChild.kind)),this._firstChild}ifTrue(){return r(this.kind===w.IF),r(2===this.childCount()||3===this.childCount()),r(D(this._firstChild._nextSibling.kind)),this._firstChild._nextSibling}ifFalse(){return r(this.kind===w.IF),r(2===this.childCount()||3===this.childCount()),r(null===this._firstChild._nextSibling._nextSibling||D(this._firstChild._nextSibling._nextSibling.kind)),this._firstChild._nextSibling._nextSibling}returnValue(){return r(this.kind===w.RETURN),r(this.childCount()<=1),r(null===this._firstChild||F(this._firstChild.kind)),this._firstChild}variablesType(){return r(this.kind===w.VARIABLES),r(this.childCount()>=1),r(F(this._firstChild.kind)),this._firstChild}whileTest(){return r(this.kind===w.WHILE),r(2===this.childCount()),r(F(this._firstChild.kind)),this._firstChild}whileBody(){return r(this.kind===w.WHILE),r(2===this.childCount()),r(D(this._lastChild.kind)),this._lastChild}callTarget(){return r(this.kind===w.CALL),r(this.childCount()>=1),r(F(this._firstChild.kind)),this._firstChild}dotTarget(){return r(this.kind===w.DOT),r(1===this.childCount()),r(F(this._firstChild.kind)),this._firstChild}hookTest(){return r(this.kind===w.HOOK),r(3===this.childCount()),r(F(this._firstChild.kind)),this._firstChild}hookTrue(){return r(this.kind===w.HOOK),r(3===this.childCount()),r(F(this._firstChild._nextSibling.kind)),this._firstChild._nextSibling}hookFalse(){return r(this.kind===w.HOOK),r(3===this.childCount()),r(F(this._lastChild.kind)),this._lastChild}asString(){return r(this.kind===w.DOT),r(null!==this._text),this._text}asBool(){return r(this.kind===w.BOOL),!!this._literal}asFloat(){return r(this.kind===w.FLOAT),this._literal}asInt(){return r(this.kind===w.INT),0|this._literal}unaryValue(){return r(M(this.kind)),r(1===this.childCount()),r(F(this._firstChild.kind)),this._firstChild}binaryLeft(){return r(G(this.kind)),r(2===this.childCount()),r(F(this._firstChild.kind)),this._firstChild}binaryRight(){return r(G(this.kind)),r(2===this.childCount()),r(F(this._lastChild.kind)),this._lastChild}static _createID(){return k._nextID=k._nextID+1,k._nextID}}function D(e){return e>=w.BLOCK&&e<=w.WHILE}function F(e){return e>=w.CALL&&e<=w.ASSIGN_SUBTRACT}function M(e){return e>=w.NEGATIVE&&e<=w.POSTFIX_INCREMENT}function V(e){return e>=w.NEGATIVE&&e<=w.PREFIX_INCREMENT}function B(e){return e>=w.POSTFIX_DECREMENT&&e<=w.POSTFIX_INCREMENT}function U(e){return e>=w.PREFIX_DECREMENT&&e<=w.POSTFIX_INCREMENT}function G(e){return e>=w.ADD&&e<=w.ASSIGN_SUBTRACT}function j(e){return e>=w.ASSIGN&&e<=w.ASSIGN_SUBTRACT}function H(e){return e===w.DO_WHILE||e===w.FOR||e===w.WHILE}function q(e,t){return o(e,e.length-1,t)}function W(e,t){return(t<e?1:0)-(t>e?1:0)}k._nextID=0;let X=!1;function $(e){switch(e){case 2:return Y;case 3:return Q;case 4:return K}return r(!1),null}function z(e,t){let n=e;if(n===N.BOOL)switch(t){case 1:return N.BOOL;case 2:return N.BVEC2;case 3:return N.BVEC3;case 4:return N.BVEC4}else if(n===N.FLOAT)switch(t){case 1:return N.FLOAT;case 2:return N.VEC2;case 3:return N.VEC3;case 4:return N.VEC4}else if(n===N.INT)switch(t){case 1:return N.INT;case 2:return N.IVEC2;case 3:return N.IVEC3;case 4:return N.IVEC4}else if(n===N.UINT)switch(t){case 1:return N.UINT;case 2:return N.UVEC2;case 3:return N.UVEC3;case 4:return N.UVEC4}return r(!1),null}let Y=["xy","st","rg"],Q=["xyz","stp","rgb"],K=["xyzw","stpq","rgba"];function J(e){if(X)return ee(e);{let t=ee(e);return null!==t&&(r(null===t.parent()),t.kind!==w.UNKNOWN_CONSTANT&&Z(t)),t}}function Z(e){switch(e.kind){case w.INT:r(e.resolvedType===N.INT&&!e.hasChildren());break;case w.BOOL:r(e.resolvedType===N.BOOL&&!e.hasChildren());break;case w.FLOAT:r(e.resolvedType===N.FLOAT&&!e.hasChildren());break;case w.CALL:{let t=e.callTarget();r(t.kind===w.TYPE),r(t.resolvedType===e.resolvedType);let n=t.resolvedType.componentType(),o=t.resolvedType.componentCount();if(null!==n){r(e.childCount()===1+o),r(t.resolvedType!==N.INT&&t.resolvedType!==N.BOOL&&t.resolvedType!==N.FLOAT);for(let e=t.nextSibling();null!==e;e=e.nextSibling())r(e.resolvedType===n),r(e.kind!==w.CALL),Z(e)}else{let n=t.resolvedType.symbol.asStruct(),o=0;r(e.childCount()===1+n.variables.length);for(let e=t.nextSibling();null!==e;e=e.nextSibling())r(e.resolvedType===a(n.variables,o).type.resolvedType),Z(e),o+=1}break}default:r(!1);break}}function ee(e){if(r(null!==e.resolvedType),e.resolvedType===N.ERROR)return null;switch(e.kind){case w.INT:case w.FLOAT:case w.BOOL:return e.clone();case w.NAME:return te(e);case w.SEQUENCE:return ne(e);case w.HOOK:return re(e);case w.DOT:return oe(e);case w.INDEX:return ie(e);case w.CALL:return ae(e);case w.NEGATIVE:return Te(e,e=>-e,e=>-e);case w.NOT:return ge(e,e=>!e);case w.POSITIVE:return Te(e,e=>+e,e=>+e);case w.ADD:return be(e,(e,t)=>e+t,(e,t)=>e+t);case w.SUBTRACT:return be(e,(e,t)=>e-t,(e,t)=>e-t);case w.MULTIPLY:return le(e);case w.DIVIDE:return be(e,(e,t)=>0!==t?e/t:0,(e,t)=>0!==t?e/t|0:0);case w.EQUAL:case w.NOT_EQUAL:return fe(e);case w.LOGICAL_AND:return Ee(e,(e,t)=>e&&t);case w.LOGICAL_OR:return Ee(e,(e,t)=>e||t);case w.LOGICAL_XOR:return Ee(e,(e,t)=>e!==t);case w.GREATER_THAN:return Pe(e,(e,t)=>e>t);case w.GREATER_THAN_OR_EQUAL:return Pe(e,(e,t)=>e>=t);case w.LESS_THAN:return Pe(e,(e,t)=>e<t);case w.LESS_THAN_OR_EQUAL:return Pe(e,(e,t)=>e<=t)}return null}function te(e){let t=e.symbol;if(null!==t&&t.isConst()){if(null!==t.constantValue)return t.constantValue.clone();if(0!==t.asVariable().kind)return k.createUnknownConstant(e.resolvedType)}return null}function ne(e){for(let t=e.firstChild();null!==t;t=t.nextSibling()){let n=J(t);if(null===n||t===e.lastChild())return n}return null}function re(e){let t=J(e.hookTest()),n=J(e.hookTrue()),r=J(e.hookFalse());return null!==t&&t.kind===w.BOOL&&null!==n&&null!==r?t.asBool()?n:r:null}function oe(e){let t=J(e.dotTarget());if(null!==t&&t.kind===w.CALL){let n=t.resolvedType,o=e.asString();if(n.isVector()){let e=o.length,r=n.componentCount();for(const i of $(r))if(-1!==i.indexOf(b(o,0))){if(1===e)return t.childAt(1+i.indexOf(o)).remove();let r=z(n.componentType(),e),a=k.createConstructorCall(r);for(let n=0,s=e;n<s;n+=1)a.appendChild(t.childAt(1+i.indexOf(b(o,n))).clone());return a}}else if(null!==n.symbol&&n.symbol.isStruct()){let e=n.symbol.asStruct(),i=e.variables;r(t.childCount()===1+i.length);for(let n=0,r=i.length;n<r;n+=1){let e=a(i,n);if(e.name===o)return t.childAt(1+n).remove()}}}return null}function ie(e){let t=J(e.binaryLeft()),n=J(e.binaryRight());if(null!==t&&t.kind===w.CALL&&null!==n&&n.kind===w.INT){let e=t.resolvedType;if(e.isVector()){let r=e.indexCount(),o=n.asInt();if(0<=o&&o<r)return t.childAt(o+1).remove()}else if(e.isMatrix()){let o=e.indexCount(),i=n.asInt();if(r(t.childCount()===1+o*o),0<=i&&i<o){let n=e.indexType(),r=k.createConstructorCall(n),a=t.childAt(i*o);for(let e=0,t=o;e<t;e+=1)r.appendChild(a.nextSibling().remove());return r}}}return null}function ae(e){let t=e.callTarget();if(t.kind!==w.TYPE)return null;let n=t.resolvedType,r=n.componentType(),o=0,i=[],a=0;for(let s=t.nextSibling();null!==s;s=s.nextSibling()){let e=J(s);if(null===e)return null;if(e.kind===w.CALL&&null!==r&&null!==e.callTarget().resolvedType.componentType())for(let t=e.callTarget().nextSibling();null!==t;t=t.nextSibling()){let e=ue(r,t);if(null===e)return null;i.push(e)}else{if(null!==r&&(e=ue(r,e),null===e))return null;i.push(e)}e.resolvedType.isMatrix()&&(o=e.resolvedType.indexCount()),a+=1}return n.isMatrix()&&0!==o&&1!==a?null:null!==n.componentType()?ce(i,n,n.isMatrix()?o:0):null!==n.symbol&&n.symbol.isStruct()?de(i,n):null}function se(e){let t=[];for(let n=e.callTarget().nextSibling();null!==n;n=n.nextSibling())t.push(n.asFloat());return t}function le(e){let t,n=J(e.binaryLeft()),r=J(e.binaryRight()),o=null!==n?n.resolvedType:null,i=null!==r?r.resolvedType:null;if(null!==n&&null!==r){if(o===N.VEC2&&i===N.MAT2||o===N.VEC3&&i===N.MAT3||o===N.VEC4&&i===N.MAT4){let e=o.indexCount(),t=k.createConstructorCall(o),i=se(n),s=se(r);for(let n=0,r=e;n<r;n+=1){let r=0;for(let t=0,o=e;t<o;t+=1)r+=a(i,t)*a(s,t+n*e);t.appendChild(k.createFloat(r))}return t}if(o===N.MAT2&&i===N.VEC2||o===N.MAT3&&i===N.VEC3||o===N.MAT4&&i===N.VEC4){let e=o.indexCount(),t=k.createConstructorCall(i),s=se(n),l=se(r);for(let n=0,r=e;n<r;n+=1){let r=0;for(let t=0,o=e;t<o;t+=1)r+=a(s,n+t*e)*a(l,t);t.appendChild(k.createFloat(r))}return t}if(o.isMatrix()&&i===o){let e=o.indexCount(),t=k.createConstructorCall(o),i=se(n),s=se(r);for(let n=0,r=e;n<r;n+=1)for(let o=0,l=e;o<l;o+=1){let r=0;for(let t=0,l=e;t<l;t+=1)r+=a(i,o+t*e)*a(s,t+n*e);t.appendChild(k.createFloat(r))}return t}return null!==(t=ve(n,r,(e,t)=>e*t))?t:ye(n,r,(e,t)=>e*t)}return null}function ue(e,t){let n=0;switch(t.kind){case w.BOOL:n=t.asBool()?1:0;break;case w.INT:n=t.asInt();break;case w.FLOAT:n=t.asFloat();break;default:return null}let r=e;return r===N.BOOL?k.createBool(!!n):r===N.INT?k.createInt(0|n):r===N.FLOAT?k.createFloat(n):null}function ce(e,t,n){let o=t.componentCount(),i=t.componentType(),s=k.createConstructorCall(t);if(r(o>0),1===e.length){let n=c(e);if(n.resolvedType!==i)return null;let r=t.isMatrix(),a=t.indexCount();for(let e=0,t=o;e<t;e+=1){let t=r&&e%(a+1)!==0;s.appendChild(t?k.createFloat(0):n.clone())}}else if(0!==n){let i=t.indexCount();r(t.isMatrix()),r(i*i===o);for(let t=0,r=i;t<r;t+=1)for(let o=0,l=i;o<l;o+=1)s.appendChild(o<n&&t<n?a(e,o+t*n):k.createFloat(o===t?1:0))}else{if(e.length<o)return null;for(let t=0,n=o;t<n;t+=1){let n=a(e,t);if(n.resolvedType!==i)return null;s.appendChild(n)}}return null===t.indexType()?s.lastChild().remove():s}function de(e,t){let n=t.symbol.asStruct().variables,r=k.createConstructorCall(t);if(e.length!==n.length)return null;for(let o=0,i=e.length;o<i;o+=1){if(a(e,o).resolvedType!==a(n,o).type.resolvedType)return null;r.appendChild(a(e,o))}return r}function fe(e){let t=J(e.binaryLeft()),n=J(e.binaryRight());if(null!==t&&null!==n){let r=t.looksTheSameAs(n);return k.createBool(e.kind===w.EQUAL?r:!r)}return null}function he(e,t,n,r){if(e.kind===w.CALL&&e.callTarget().kind===w.TYPE&&e.callTarget().resolvedType.componentType()===t){let t=k.createConstructorCall(e.callTarget().resolvedType);for(let o=e.callTarget().nextSibling();null!==o;o=o.nextSibling()){let e=J(o);if(null===e||e.kind!==n)return null;t.appendChild(r(e))}return t}return null}function pe(e,t){return e.kind===w.FLOAT?k.createFloat(t(e.asFloat())):he(e,N.FLOAT,w.FLOAT,e=>k.createFloat(t(e.asFloat())))}function me(e,t){return e.kind===w.INT?k.createInt(t(e.asInt())):he(e,N.INT,w.INT,e=>k.createInt(t(e.asInt())))}function xe(e,t,n,r,o){let i=e.kind===w.CALL&&e.callTarget().kind===w.TYPE&&e.callTarget().resolvedType.componentType()===n,a=t.kind===w.CALL&&t.callTarget().kind===w.TYPE&&t.callTarget().resolvedType.componentType()===n;if(i&&a&&t.resolvedType===e.resolvedType){let n=k.createConstructorCall(e.resolvedType),i=e.callTarget().nextSibling(),a=t.callTarget().nextSibling();while(null!==i&&null!==a){let e=J(i),t=J(a);if(null===e||e.kind!==r||null===t||t.kind!==r)return null;n.appendChild(o(e,t)),i=i.nextSibling(),a=a.nextSibling()}if(null===i&&null===a)return n}else{if(i&&t.kind===r){let n=k.createConstructorCall(e.resolvedType);for(let i=e.callTarget().nextSibling();null!==i;i=i.nextSibling()){let e=J(i);if(null===e||e.kind!==r)return null;n.appendChild(o(e,t))}return n}if(e.kind===r&&a){let n=k.createConstructorCall(t.resolvedType);for(let i=t.callTarget().nextSibling();null!==i;i=i.nextSibling()){let t=J(i);if(null===t||t.kind!==r)return null;n.appendChild(o(e,t))}return n}}return null}function ve(e,t,n){return e.kind===w.FLOAT&&t.kind===w.FLOAT?k.createFloat(n(e.asFloat(),t.asFloat())):xe(e,t,N.FLOAT,w.FLOAT,(e,t)=>k.createFloat(n(e.asFloat(),t.asFloat())))}function ye(e,t,n){return e.kind===w.INT&&t.kind===w.INT?k.createInt(n(e.asInt(),t.asInt())):xe(e,t,N.INT,w.INT,(e,t)=>k.createInt(n(e.asInt(),t.asInt())))}function ge(e,t){let n=J(e.unaryValue());return null!==n&&n.kind===w.BOOL?k.createBool(t(n.asBool())):null}function Te(e,t,n){let r,o=J(e.unaryValue());return null!==o?null!==(r=pe(o,t))?r:me(o,n):null}function Ee(e,t){let n=J(e.binaryLeft()),r=J(e.binaryRight());return null!==n&&null!==r&&n.kind===w.BOOL&&r.kind===w.BOOL?k.createBool(t(n.asBool(),r.asBool())):null}function be(e,t,n){let r,o=J(e.binaryLeft()),i=J(e.binaryRight());return null!==o&&null!==i?null!==(r=ve(o,i,t))?r:ye(o,i,n):null}function Pe(e,t){let n=J(e.binaryLeft()),r=J(e.binaryRight());if(null!==n&&null!==r){if(n.kind===w.FLOAT&&r.kind===w.FLOAT)return k.createBool(t(n.asFloat(),r.asFloat()));if(n.kind===w.INT&&r.kind===w.INT)return k.createBool(t(n.asInt(),r.asInt()))}return null}class Ie{constructor(e,t,n){this.source=e,this.start=t,this.end=n}toString(){return T(this.source.contents,this.start,this.end)}overlaps(e){return this.source===e.source&&this.start<e.end&&e.start<this.end}touches(e){return this.start<=e&&e<=this.end}slice(e,t){return r(e>=0&&e<=t&&t<=this.end-this.start),new Ie(this.source,this.start+e,this.start+t)}lineColumn(){return this.source.indexToLineColumn(this.start)}rangeAtEnd(){return new Ie(this.source,this.end,this.end)}static span(e,t){return r(e.source===t.source),r(e.start<=t.end),new Ie(e.source,e.start,t.end)}}var Ae;(function(e){e[e["SINGLE_LINE_COMMENT"]=0]="SINGLE_LINE_COMMENT",e[e["MULTI_LINE_COMMENT"]=1]="MULTI_LINE_COMMENT",e[e["ATTRIBUTE"]=2]="ATTRIBUTE",e[e["BOOL"]=3]="BOOL",e[e["BREAK"]=4]="BREAK",e[e["BVEC2"]=5]="BVEC2",e[e["BVEC3"]=6]="BVEC3",e[e["BVEC4"]=7]="BVEC4",e[e["CONST"]=8]="CONST",e[e["CONTINUE"]=9]="CONTINUE",e[e["DISCARD"]=10]="DISCARD",e[e["DO"]=11]="DO",e[e["ELSE"]=12]="ELSE",e[e["FALSE"]=13]="FALSE",e[e["FLOAT"]=14]="FLOAT",e[e["FOR"]=15]="FOR",e[e["HIGHP"]=16]="HIGHP",e[e["IF"]=17]="IF",e[e["IN"]=18]="IN",e[e["INOUT"]=19]="INOUT",e[e["INT"]=20]="INT",e[e["UINT"]=21]="UINT",e[e["INVARIANT"]=22]="INVARIANT",e[e["IVEC2"]=23]="IVEC2",e[e["IVEC3"]=24]="IVEC3",e[e["IVEC4"]=25]="IVEC4",e[e["LOWP"]=26]="LOWP",e[e["MAT2"]=27]="MAT2",e[e["MAT3"]=28]="MAT3",e[e["MAT4"]=29]="MAT4",e[e["MEDIUMP"]=30]="MEDIUMP",e[e["OUT"]=31]="OUT",e[e["PRECISION"]=32]="PRECISION",e[e["RETURN"]=33]="RETURN",e[e["SAMPLER2D"]=34]="SAMPLER2D",e[e["SAMPLER3D"]=35]="SAMPLER3D",e[e["SAMPLERCUBE"]=36]="SAMPLERCUBE",e[e["ISAMPLERCUBE"]=37]="ISAMPLERCUBE",e[e["USAMPLERCUBE"]=38]="USAMPLERCUBE",e[e["SAMPLER2DARRAY"]=39]="SAMPLER2DARRAY",e[e["ISAMPLER2DARRAY"]=40]="ISAMPLER2DARRAY",e[e["USAMPLER2DARRAY"]=41]="USAMPLER2DARRAY",e[e["SAMPLER2DSHADOW"]=42]="SAMPLER2DSHADOW",e[e["SAMPLERCUBESHADOW"]=43]="SAMPLERCUBESHADOW",e[e["SAMPLER2DARRAYSHADOW"]=44]="SAMPLER2DARRAYSHADOW",e[e["USAMPLER2DARRAYSHADOW"]=45]="USAMPLER2DARRAYSHADOW",e[e["ISAMPLER2DARRAYSHADOW"]=46]="ISAMPLER2DARRAYSHADOW",e[e["ISAMPLER2D"]=47]="ISAMPLER2D",e[e["USAMPLER2D"]=48]="USAMPLER2D",e[e["ISAMPLER3D"]=49]="ISAMPLER3D",e[e["USAMPLER3D"]=50]="USAMPLER3D",e[e["STRUCT"]=51]="STRUCT",e[e["TRUE"]=52]="TRUE",e[e["UNIFORM"]=53]="UNIFORM",e[e["VARYING"]=54]="VARYING",e[e["VEC2"]=55]="VEC2",e[e["VEC3"]=56]="VEC3",e[e["VEC4"]=57]="VEC4",e[e["UVEC2"]=58]="UVEC2",e[e["UVEC3"]=59]="UVEC3",e[e["UVEC4"]=60]="UVEC4",e[e["VOID"]=61]="VOID",e[e["WHILE"]=62]="WHILE",e[e["EXPORT"]=63]="EXPORT",e[e["IMPORT"]=64]="IMPORT",e[e["COMPLEMENT"]=65]="COMPLEMENT",e[e["DECREMENT"]=66]="DECREMENT",e[e["INCREMENT"]=67]="INCREMENT",e[e["NOT"]=68]="NOT",e[e["BITWISE_AND"]=69]="BITWISE_AND",e[e["BITWISE_OR"]=70]="BITWISE_OR",e[e["BITWISE_XOR"]=71]="BITWISE_XOR",e[e["DIVIDE"]=72]="DIVIDE",e[e["EQUAL"]=73]="EQUAL",e[e["GREATER_THAN"]=74]="GREATER_THAN",e[e["GREATER_THAN_OR_EQUAL"]=75]="GREATER_THAN_OR_EQUAL",e[e["LESS_THAN"]=76]="LESS_THAN",e[e["LESS_THAN_OR_EQUAL"]=77]="LESS_THAN_OR_EQUAL",e[e["LOGICAL_AND"]=78]="LOGICAL_AND",e[e["LOGICAL_OR"]=79]="LOGICAL_OR",e[e["LOGICAL_XOR"]=80]="LOGICAL_XOR",e[e["MINUS"]=81]="MINUS",e[e["MULTIPLY"]=82]="MULTIPLY",e[e["NOT_EQUAL"]=83]="NOT_EQUAL",e[e["PLUS"]=84]="PLUS",e[e["REMAINDER"]=85]="REMAINDER",e[e["SHIFT_LEFT"]=86]="SHIFT_LEFT",e[e["SHIFT_RIGHT"]=87]="SHIFT_RIGHT",e[e["ASSIGN"]=88]="ASSIGN",e[e["ASSIGN_ADD"]=89]="ASSIGN_ADD",e[e["ASSIGN_BITWISE_AND"]=90]="ASSIGN_BITWISE_AND",e[e["ASSIGN_BITWISE_OR"]=91]="ASSIGN_BITWISE_OR",e[e["ASSIGN_BITWISE_XOR"]=92]="ASSIGN_BITWISE_XOR",e[e["ASSIGN_DIVIDE"]=93]="ASSIGN_DIVIDE",e[e["ASSIGN_MULTIPLY"]=94]="ASSIGN_MULTIPLY",e[e["ASSIGN_REMAINDER"]=95]="ASSIGN_REMAINDER",e[e["ASSIGN_SHIFT_LEFT"]=96]="ASSIGN_SHIFT_LEFT",e[e["ASSIGN_SHIFT_RIGHT"]=97]="ASSIGN_SHIFT_RIGHT",e[e["ASSIGN_SUBTRACT"]=98]="ASSIGN_SUBTRACT",e[e["COLON"]=99]="COLON",e[e["COMMA"]=100]="COMMA",e[e["DOT"]=101]="DOT",e[e["LEFT_BRACE"]=102]="LEFT_BRACE",e[e["LEFT_BRACKET"]=103]="LEFT_BRACKET",e[e["LEFT_PARENTHESIS"]=104]="LEFT_PARENTHESIS",e[e["QUESTION"]=105]="QUESTION",e[e["RIGHT_BRACE"]=106]="RIGHT_BRACE",e[e["RIGHT_BRACKET"]=107]="RIGHT_BRACKET",e[e["RIGHT_PARENTHESIS"]=108]="RIGHT_PARENTHESIS",e[e["SEMICOLON"]=109]="SEMICOLON",e[e["EXTENSION"]=110]="EXTENSION",e[e["VERSION"]=111]="VERSION",e[e["INCLUDE"]=112]="INCLUDE",e[e["DEFINE"]=113]="DEFINE",e[e["PRAGMA"]=114]="PRAGMA",e[e["FLOAT_LITERAL"]=115]="FLOAT_LITERAL",e[e["IDENTIFIER"]=116]="IDENTIFIER",e[e["INT_LITERAL"]=117]="INT_LITERAL",e[e["STRING_LITERAL"]=118]="STRING_LITERAL",e[e["END_OF_FILE"]=119]="END_OF_FILE"})(Ae||(Ae={}));class we{constructor(e,t,n){this.range=e,this.kind=t,this.comments=n}}function Re(e,t){let n=null;while(null!==(n=Ce.exec(t.contents))){let t=new R(n[1],n[2]);f(e.defines,t.name,t)}}function _e(e,t){for(const n of Array.from(e.defines.values()))t.contents=t.contents.replace(new RegExp("(?<!#define\\s+)\\b"+n.name+"\\b","g"),n.value)}function Se(e,t,n){let r=t.contents.split(Oe),o=[],i=null,s=0,l=0;for(let u=0,c=r.length;u<c;u+=1){let c=a(r,u),d=c.length,f=l+d,h=new Ie(t,l,f);if(u%2!==0){let t=E(c,0);if(t>=65&&t<=90||t>=97&&t<=122||95===t){let t=p(Ne,c,Ae.END_OF_FILE);t!==Ae.END_OF_FILE?o.push(new we(h,t,i)):De.has(c)?e.syntaxErrorReservedWord(h):o.push(new we(h,Ae.IDENTIFIER,i))}else if(t>=48&&t<=57||46===t&&d>1)o.push(new we(h,Le.test(c)?Ae.INT_LITERAL:Ae.FLOAT_LITERAL,i));else if(35===t){let e=Ae.PRAGMA,t=c;"#version"===t?e=Ae.VERSION:"#extension"===t?e=Ae.EXTENSION:"#include"===t?e=Ae.INCLUDE:"#define"===t&&(e=Ae.DEFINE),o.push(new we(h,e,i))}else if(34===t)o.push(new we(h,Ae.STRING_LITERAL,i));else{let e=p(ke,c,Ae.END_OF_FILE);e===Ae.END_OF_FILE&&(c.startsWith("//")?1===n?e=Ae.SINGLE_LINE_COMMENT:(null!==i?i:i=[]).push(h):c.startsWith("/*")&&(1===n?e=Ae.MULTI_LINE_COMMENT:(null!==i?i:i=[]).push(h))),e!==Ae.END_OF_FILE&&o.push(new we(h,e,i))}}else if(""!==c){e.syntaxErrorExtraData(h,c);break}o.length!==s&&(i=null,s=o.length),l=f}return o.push(new we(new Ie(t,l,l),Ae.END_OF_FILE,i)),o}let Ce=new RegExp("#define\\s+(\\w+\\b)\\s?(.+)?","g"),Oe=new RegExp('(\\.[0-9]+[eE][+-]?[0-9]+\\b|\\.[0-9]+\\b|[0-9]+\\.[0-9]+[eE][+-]?[0-9]+\\b|[0-9]+\\.[0-9]+\\b|[0-9]+\\.[eE][+-]?[0-9]+\\b|[0-9]+\\.|[0-9]+[eE][+-]?[0-9]+\\b|[1-9][0-9]*\\b|0[0-7]*\\b|0[xX][0-9A-Fa-f]+\\b|[ \t\r\n]|/\\*(?:.|\r\n|\n)*?\\*/|//.*|&&|\\|\\||\\^\\^|\\+\\+|--|<<=?|>>=?|[()[\\]{}\\.,?:;]|[+\\-*/%=!<>&|^~]=?|[A-Za-z_][A-Za-z0-9_]*\\b|#\\w+\\b|"(?:[^"\\\\]|\\\\.)*")'),Le=new RegExp("^([1-9][0-9]*|0[0-7]*|0[xX][0-9A-Fa-f]+)$"),Ne=h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(new Map,"attribute",Ae.ATTRIBUTE),"bool",Ae.BOOL),"break",Ae.BREAK),"bvec2",Ae.BVEC2),"bvec3",Ae.BVEC3),"bvec4",Ae.BVEC4),"const",Ae.CONST),"continue",Ae.CONTINUE),"discard",Ae.DISCARD),"do",Ae.DO),"else",Ae.ELSE),"false",Ae.FALSE),"float",Ae.FLOAT),"for",Ae.FOR),"highp",Ae.HIGHP),"if",Ae.IF),"in",Ae.IN),"inout",Ae.INOUT),"int",Ae.INT),"invariant",Ae.INVARIANT),"ivec2",Ae.IVEC2),"ivec3",Ae.IVEC3),"ivec4",Ae.IVEC4),"uint",Ae.UINT),"uvec2",Ae.UVEC2),"uvec3",Ae.UVEC3),"uvec4",Ae.UVEC4),"lowp",Ae.LOWP),"mat2",Ae.MAT2),"mat3",Ae.MAT3),"mat4",Ae.MAT4),"mediump",Ae.MEDIUMP),"out",Ae.OUT),"precision",Ae.PRECISION),"return",Ae.RETURN),"sampler2D",Ae.SAMPLER2D),"sampler3D",Ae.SAMPLER3D),"samplerCube",Ae.SAMPLERCUBE),"isamplerCube",Ae.ISAMPLERCUBE),"usamplerCube",Ae.USAMPLERCUBE),"sampler2DArray",Ae.SAMPLER2DARRAY),"isampler2DArray",Ae.ISAMPLER2DARRAY),"usampler2DArray",Ae.USAMPLER2DARRAY),"sampler2DShadow",Ae.SAMPLER2DSHADOW),"samplerCubeShadow",Ae.SAMPLERCUBESHADOW),"sampler2DArrayShadow",Ae.SAMPLER2DARRAYSHADOW),"usampler2DArrayShadow",Ae.USAMPLER2DARRAYSHADOW),"isampler2DArrayShadow",Ae.ISAMPLER2DARRAYSHADOW),"isampler2D",Ae.ISAMPLER2D),"usampler2D",Ae.USAMPLER2D),"isampler3D",Ae.ISAMPLER3D),"usampler3D",Ae.USAMPLER3D),"struct",Ae.STRUCT),"true",Ae.TRUE),"uniform",Ae.UNIFORM),"varying",Ae.VARYING),"vec2",Ae.VEC2),"vec3",Ae.VEC3),"vec4",Ae.VEC4),"void",Ae.VOID),"while",Ae.WHILE),"export",Ae.EXPORT),"import",Ae.IMPORT),ke=h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(new Map,"~",Ae.COMPLEMENT),"--",Ae.DECREMENT),"++",Ae.INCREMENT),"!",Ae.NOT),"&",Ae.BITWISE_AND),"|",Ae.BITWISE_OR),"^",Ae.BITWISE_XOR),"/",Ae.DIVIDE),"==",Ae.EQUAL),">",Ae.GREATER_THAN),">=",Ae.GREATER_THAN_OR_EQUAL),"<",Ae.LESS_THAN),"<=",Ae.LESS_THAN_OR_EQUAL),"&&",Ae.LOGICAL_AND),"||",Ae.LOGICAL_OR),"^^",Ae.LOGICAL_XOR),"-",Ae.MINUS),"*",Ae.MULTIPLY),"!=",Ae.NOT_EQUAL),"+",Ae.PLUS),"%",Ae.REMAINDER),"<<",Ae.SHIFT_LEFT),">>",Ae.SHIFT_RIGHT),"=",Ae.ASSIGN),"+=",Ae.ASSIGN_ADD),"&=",Ae.ASSIGN_BITWISE_AND),"|=",Ae.ASSIGN_BITWISE_OR),"^=",Ae.ASSIGN_BITWISE_XOR),"/=",Ae.ASSIGN_DIVIDE),"*=",Ae.ASSIGN_MULTIPLY),"%=",Ae.ASSIGN_REMAINDER),"<<=",Ae.ASSIGN_SHIFT_LEFT),">>=",Ae.ASSIGN_SHIFT_RIGHT),"-=",Ae.ASSIGN_SUBTRACT),":",Ae.COLON),",",Ae.COMMA),".",Ae.DOT),"{",Ae.LEFT_BRACE),"[",Ae.LEFT_BRACKET),"(",Ae.LEFT_PARENTHESIS),"?",Ae.QUESTION),"}",Ae.RIGHT_BRACE),"]",Ae.RIGHT_BRACKET),")",Ae.RIGHT_PARENTHESIS),";",Ae.SEMICOLON),De=h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(h(new Map,"asm",0),"cast",0),"class",0),"default",0),"double",0),"dvec2",0),"dvec3",0),"dvec4",0),"enum",0),"extern",0),"external",0),"fixed",0),"flat",0),"fvec2",0),"fvec3",0),"fvec4",0),"goto",0),"half",0),"hvec2",0),"hvec3",0),"hvec4",0),"inline",0),"input",0),"interface",0),"long",0),"namespace",0),"noinline",0),"output",0),"packed",0),"public",0),"sampler1D",0),"sampler1DShadow",0),"sampler2DRect",0),"sampler2DRectShadow",0),"sampler3DRect",0),"short",0),"sizeof",0),"static",0),"superp",0),"switch",0),"template",0),"this",0),"typedef",0),"union",0),"unsigned",0),"using",0),"volatile",0);class Fe{constructor(e,t){this.originalRange=e,this.includedRange=t}}class Me{constructor(e,t,n,r,o){this.log=e,this._tokens=t,this.compilationData=n,this.resolver=r,this.processedIncludes=o,this.includes=[],this.flags=0,this._index=0,this._scope=null}current(){return a(this._tokens,this._index)}next(){let e=this.current();return this._index+1<this._tokens.length&&(this._index=this._index+1),e}spanSince(e){let t=a(this._tokens,this._index>0?this._index-1:0);return t.range.end<e.start?e:Ie.span(e,t.range)}peek(e){return this.current().kind===e}eat(e){return!!this.peek(e)&&(this.next(),!0)}expect(e){if(this.eat(e))return!0;let t=this.current(),n=t.range,r=(this._index>0?a(this._tokens,this._index-1):t).range;return e===Ae.SEMICOLON||r.lineColumn().line!==n.lineColumn().line?this.log.syntaxErrorExpectedToken1(r.rangeAtEnd(),e):this.log.syntaxErrorExpectedToken2(n,t.kind,e),!1}unexpectedToken(){this.log.syntaxErrorUnexpectedToken(this.current())}scope(){return this._scope}pushScope(e){r(e.parent===this._scope),this._scope=e}popScope(){r(null!==this._scope),this._scope=this._scope.parent}}class Ve{constructor(e){this.precedence=e,this.prefix=null,this.infix=null}}class Be{constructor(){this._table=new Map}parselet(e,t){let n=v(this._table,e,null);if(null===n){let r=new Ve(t);n=r,x(this._table,e,r)}else t>n.precedence&&(n.precedence=t);return n}parse(e,t){let n=e.current(),o=v(this._table,n.kind,null);if(null===o||null===o.prefix)return e.unexpectedToken(),null;let i=this.resume(e,t,o.prefix(e));return r(null===i||null!==i.range),i}resume(e,t,n){while(null!==n){let o=e.current().kind,i=v(this._table,o,null);if(null===i||null===i.infix||i.precedence<=t)break;n=i.infix(e,n),r(null===n||null!==n.range)}return n}literal(e,t){this.parselet(e,0).prefix=e=>t(e,e.next())}prefix(e,t,n){this.parselet(e,0).prefix=e=>{let r=e.next(),o=this.parse(e,t);return null!==o?n(e,r,o):null}}postfix(e,t,n){this.parselet(e,t).infix=(e,t)=>n(e,t,e.next())}infix(e,t,n){this.parselet(e,t).infix=(e,r)=>{let o=e.next(),i=this.parse(e,t);return null!==i?n(e,r,o,i):null}}infixRight(e,t,n){this.parselet(e,t).infix=(e,r)=>{let o=e.next(),i=this.parse(e,t-1);return null!==i?n(e,r,o,i):null}}}class Ue{constructor(e,t){this.kind=e,this.parent=t,this.symbols=new Map}define(e){r(!this.symbols.has(e.name)),f(this.symbols,e.name,e)}redefine(e){r(this.symbols.has(e.name)),r(m(this.symbols,e.name)!==e),f(this.symbols,e.name,e)}find(e){let t=p(this.symbols,e,null);return null!==t?t:null!==this.parent?this.parent.find(e):null}}class Ge{constructor(e){this.includes=e}}function je(e){return(t,n)=>k.createType(e).withRange(n.range)}function He(e){return r(V(e)),(t,n,r)=>k.createUnary(e,r).withRange(Ie.span(n.range,r.range)).withInternalRange(n.range)}function qe(e){return r(B(e)),(t,n,r)=>k.createUnary(e,n).withRange(Ie.span(n.range,r.range)).withInternalRange(r.range)}function We(e){return r(G(e)),(t,n,r,o)=>k.createBinary(e,n,o).withRange(Ie.span(n.range,o.range)).withInternalRange(r.range)}function Xe(e){return e.length>1&&48===E(e,0)&&120!==E(e,1)&&88!==E(e,1)?Number.parseInt(e,8):0|e}function $e(e){return+e}function ze(){let e=new Be,t=(e,t,n)=>(e.log.syntaxErrorInvalidOperator(t.range),k.createUnknownConstant(N.ERROR).withRange(Ie.span(t.range,n.range))),n=(e,t,n,r)=>(e.log.syntaxErrorInvalidOperator(n.range),k.createUnknownConstant(N.ERROR).withRange(Ie.span(t.range,r.range)));return e.literal(Ae.TRUE,(e,t)=>k.createBool(!0).withRange(t.range)),e.literal(Ae.FALSE,(e,t)=>k.createBool(!1).withRange(t.range)),e.literal(Ae.INT_LITERAL,(e,t)=>k.createInt(Xe(t.range.toString())).withRange(t.range)),e.literal(Ae.FLOAT_LITERAL,(e,t)=>k.createFloat($e(t.range.toString())).withRange(t.range)),e.literal(Ae.BOOL,je(N.BOOL)),e.literal(Ae.BVEC2,je(N.BVEC2)),e.literal(Ae.BVEC3,je(N.BVEC3)),e.literal(Ae.BVEC4,je(N.BVEC4)),e.literal(Ae.FLOAT,je(N.FLOAT)),e.literal(Ae.INT,je(N.INT)),e.literal(Ae.IVEC2,je(N.IVEC2)),e.literal(Ae.IVEC3,je(N.IVEC3)),e.literal(Ae.IVEC4,je(N.IVEC4)),e.literal(Ae.MAT2,je(N.MAT2)),e.literal(Ae.MAT3,je(N.MAT3)),e.literal(Ae.MAT4,je(N.MAT4)),e.literal(Ae.VEC2,je(N.VEC2)),e.literal(Ae.VEC3,je(N.VEC3)),e.literal(Ae.VEC4,je(N.VEC4)),e.literal(Ae.UINT,je(N.UINT)),e.literal(Ae.UVEC2,je(N.UVEC2)),e.literal(Ae.UVEC3,je(N.UVEC3)),e.literal(Ae.UVEC4,je(N.UVEC4)),e.literal(Ae.VOID,je(N.VOID)),e.prefix(Ae.COMPLEMENT,14,t),e.prefix(Ae.DECREMENT,14,He(w.PREFIX_DECREMENT)),e.prefix(Ae.INCREMENT,14,He(w.PREFIX_INCREMENT)),e.prefix(Ae.MINUS,14,He(w.NEGATIVE)),e.prefix(Ae.NOT,14,He(w.NOT)),e.prefix(Ae.PLUS,14,He(w.POSITIVE)),e.postfix(Ae.DECREMENT,15,qe(w.POSTFIX_DECREMENT)),e.postfix(Ae.INCREMENT,15,qe(w.POSTFIX_INCREMENT)),e.infix(Ae.DIVIDE,13,We(w.DIVIDE)),e.infix(Ae.EQUAL,10,We(w.EQUAL)),e.infix(Ae.GREATER_THAN,10,We(w.GREATER_THAN)),e.infix(Ae.GREATER_THAN_OR_EQUAL,10,We(w.GREATER_THAN_OR_EQUAL)),e.infix(Ae.LESS_THAN,10,We(w.LESS_THAN)),e.infix(Ae.LESS_THAN_OR_EQUAL,10,We(w.LESS_THAN_OR_EQUAL)),e.infix(Ae.MINUS,12,We(w.SUBTRACT)),e.infix(Ae.MULTIPLY,13,We(w.MULTIPLY)),e.infix(Ae.NOT_EQUAL,10,We(w.NOT_EQUAL)),e.infix(Ae.PLUS,12,We(w.ADD)),e.infix(Ae.REMAINDER,13,n),e.infix(Ae.SHIFT_LEFT,11,n),e.infix(Ae.SHIFT_RIGHT,11,n),e.infix(Ae.LOGICAL_OR,3,We(w.LOGICAL_OR)),e.infix(Ae.LOGICAL_XOR,4,We(w.LOGICAL_XOR)),e.infix(Ae.LOGICAL_AND,5,We(w.LOGICAL_AND)),e.infix(Ae.BITWISE_AND,8,n),e.infix(Ae.BITWISE_OR,6,n),e.infix(Ae.BITWISE_XOR,7,n),e.infixRight(Ae.ASSIGN,2,We(w.ASSIGN)),e.infixRight(Ae.ASSIGN_ADD,2,We(w.ASSIGN_ADD)),e.infixRight(Ae.ASSIGN_BITWISE_AND,2,n),e.infixRight(Ae.ASSIGN_BITWISE_OR,2,n),e.infixRight(Ae.ASSIGN_BITWISE_XOR,2,n),e.infixRight(Ae.ASSIGN_DIVIDE,2,We(w.ASSIGN_DIVIDE)),e.infixRight(Ae.ASSIGN_MULTIPLY,2,We(w.ASSIGN_MULTIPLY)),e.infixRight(Ae.ASSIGN_REMAINDER,2,n),e.infixRight(Ae.ASSIGN_SHIFT_LEFT,2,n),e.infixRight(Ae.ASSIGN_SHIFT_RIGHT,2,n),e.infixRight(Ae.ASSIGN_SUBTRACT,2,We(w.ASSIGN_SUBTRACT)),e.literal(Ae.IDENTIFIER,(e,t)=>{let n=t.range.toString(),r=e.scope().find(n);return null===r?(e.log.syntaxErrorBadSymbolReference(t.range),k.createParseError().withRange(t.range)):(null!==r.requiredExtension&&1===e.compilationData.extensionBehavior(r.requiredExtension)&&e.log.syntaxErrorDisabledExtension(t.range,n,r.requiredExtension),r.useCount=r.useCount+1,(r.isStruct()?k.createType(r.resolvedType()):k.createName(r)).withRange(t.range))}),e.infix(Ae.COMMA,1,(e,t,n,r)=>(t.kind!==w.SEQUENCE&&(t=k.createSequence().appendChild(t).withRange(t.range)),t.appendChild(r),t.withRange(e.spanSince(t.range)))),e.parselet(Ae.DOT,16).infix=(e,t)=>{let n=e.current().range;e.next();let r=e.current().range;return e.expect(Ae.IDENTIFIER)?k.createDot(t,r.toString()).withRange(e.spanSince(t.range)).withInternalRange(r):k.createDot(t,"").withRange(e.spanSince(t.range)).withInternalRange(n.rangeAtEnd())},e.parselet(Ae.LEFT_PARENTHESIS,0).prefix=t=>{let n=t.next(),r=e.parse(t,0);return null!==r&&t.expect(Ae.RIGHT_PARENTHESIS)?r.withRange(t.spanSince(n.range)):k.createParseError().withRange(t.spanSince(n.range))},e.parselet(Ae.LEFT_PARENTHESIS,15).infix=(e,t)=>{let n=e.next(),r=k.createCall(t);return Ye(e,r,Ae.RIGHT_PARENTHESIS)?r.withRange(e.spanSince(t.range)).withInternalRange(e.spanSince(n.range)):k.createParseError().withRange(e.spanSince(n.range))},e.parselet(Ae.LEFT_BRACKET,16).infix=(t,n)=>{let r=t.next();if(t.peek(Ae.RIGHT_BRACKET))return t.unexpectedToken(),t.next(),k.createParseError().withRange(t.spanSince(r.range));let o=e.parse(t,0);return null!==o&&t.expect(Ae.RIGHT_BRACKET)?k.createBinary(w.INDEX,n,o).withRange(t.spanSince(n.range)).withInternalRange(t.spanSince(r.range)):k.createParseError().withRange(t.spanSince(r.range))},e.parselet(Ae.QUESTION,2).infix=(t,n)=>{let r=t.next(),o=e.parse(t,1);if(null===o||!t.expect(Ae.COLON))return k.createParseError().withRange(t.spanSince(r.range));let i=e.parse(t,1);return null===i?k.createParseError().withRange(t.spanSince(r.range)):k.createHook(n,o,i).withRange(t.spanSince(n.range))},e}function Ye(e,t,n){let r=!0;while(!e.eat(n)){r||e.expect(Ae.COMMA);let o=e.current(),i=Pt.parse(e,1);if(null!==i)t.appendChild(i);else if(t.appendChild(k.createParseError().withRange(e.spanSince(o.range))),e.current().kind!==Ae.COMMA&&e.current().kind!==n)return!1;r=!1}return!0}function Qe(e){let t=e.next();e.pushScope(new Ue(3,e.scope()));let n=dt(e,2);if(null===n||!e.expect(Ae.WHILE)||!e.expect(Ae.LEFT_PARENTHESIS))return null;let r=Pt.parse(e,0);return null===r?null:e.expect(Ae.RIGHT_PARENTHESIS)?(e.popScope(),lt(e,t.range,k.createDoWhile(n,r))):null}function Ke(e){let t=e.next(),n=e.flags;if(e.flags|=t.kind===Ae.EXPORT?A.EXPORTED:A.IMPORTED,e.eat(Ae.LEFT_BRACE)){let r=k.createModifierBlock();return Et(e,r,1)&&e.expect(Ae.RIGHT_BRACE)?(e.flags=n,r.withRange(e.spanSince(t.range))):null}let r=dt(e,1);return null===r?null:(e.flags=n,r)}function Je(e){let t=e.next(),n=e.current().range;if(!e.expect(Ae.IDENTIFIER))return null;let r=n.toString();if(e.eat(Ae.LEFT_BRACE)){e.compilationData.currentExtensions.has(r)||f(e.compilationData.currentExtensions,r,0);let n=k.createModifierBlock();if(!Et(e,n,1)||!e.expect(Ae.RIGHT_BRACE))return null;for(let e=n.firstChild();null!==e;e=e.nextSibling())if(e.kind===w.VARIABLES)for(let t=e.variablesType().nextSibling();null!==t;t=t.nextSibling())t.symbol.requiredExtension=r;else null!==e.symbol&&(e.symbol.requiredExtension=r);return n.withRange(e.spanSince(t.range))}if(At.has(r)||e.compilationData.currentExtensions.has(r)||e.log.syntaxWarningUnknownExtension(n,r),!e.expect(Ae.COLON))return null;let o=e.current().range.toString();if(!It.has(o))return e.unexpectedToken(),null;e.next();let i=m(It,o);return f(e.compilationData.currentExtensions,r,i),k.createExtension(r,i).withRange(e.spanSince(t.range)).withInternalRange(n)}function Ze(e){let t=e.next();if(e.pushScope(new Ue(3,e.scope())),!e.expect(Ae.LEFT_PARENTHESIS))return null;let n=null;if(!e.eat(Ae.SEMICOLON)){let r=ct(e),o=mt(e,2),i=null;if(0!==o){if(i=xt(e,1),null===i)return null}else i=xt(e,0);if(null!==i){if(n=ut(e,t.range,o,i,0,r),null===n)return null}else{if(n=Pt.parse(e,0),null===n)return null;if(!e.expect(Ae.SEMICOLON))return null}}let r=null;if(!e.eat(Ae.SEMICOLON)){if(r=Pt.parse(e,0),null===r)return null;if(!e.expect(Ae.SEMICOLON))return null}let o=null;if(!e.eat(Ae.RIGHT_PARENTHESIS)){if(o=Pt.parse(e,0),null===o)return null;if(!e.expect(Ae.RIGHT_PARENTHESIS))return null}let i=dt(e,2);return null===i?null:(e.popScope(),k.createFor(n,r,o,i).withRange(e.spanSince(t.range)))}function et(e){let t=e.next();if(!e.expect(Ae.LEFT_PARENTHESIS))return null;let n=e.current(),r=Pt.parse(e,0);if(null===r&&(r=k.createParseError().withRange(e.spanSince(n.range))),!e.expect(Ae.RIGHT_PARENTHESIS))return null;let o=dt(e,2);if(null===o)return null;let i=null;return e.eat(Ae.ELSE)&&(i=dt(e,2),null===i)?null:k.createIf(r,o,i).withRange(e.spanSince(t.range))}function tt(e){let t=e.next(),n=e.current().range;return e.expect(Ae.INT_LITERAL)?k.createVersion(0|n.toString()).withRange(e.spanSince(t.range)):null}function nt(e){let t=e.next().range,n=t.lineColumn().line,r=e.next();if(r.kind!==Ae.IDENTIFIER||r.range.lineColumn().line!==n)return e.unexpectedToken(),null;while(e.current().range.lineColumn().line===n)e.next();return k.createDefine().withRange(e.spanSince(t))}function rt(e){let t=e.next();if(e.pushScope(new Ue(3,e.scope())),!e.expect(Ae.LEFT_PARENTHESIS))return null;let n=e.current(),r=Pt.parse(e,0);if(null===r&&(r=k.createParseError().withRange(e.spanSince(n.range))),!e.expect(Ae.RIGHT_PARENTHESIS))return null;let o=dt(e,2);return null===o?null:(e.popScope(),k.createWhile(r,o).withRange(e.spanSince(t.range)))}function ot(e){let t=e.next(),n=null;if(!e.eat(Ae.SEMICOLON)){let t=e.current();n=Pt.parse(e,0),null===n&&(n=k.createParseError().withRange(e.spanSince(t.range))),e.expect(Ae.SEMICOLON)}return k.createReturn(n).withRange(e.spanSince(t.range))}function it(e){let t=e.next(),n=0;switch(e.current().kind){case Ae.LOWP:n=A.LOWP;break;case Ae.MEDIUMP:n=A.MEDIUMP;break;case Ae.HIGHP:n=A.HIGHP;break;default:return e.unexpectedToken(),null}e.next();let r=xt(e,1);return null===r?null:lt(e,t.range,k.createPrecision(n,r))}function at(e,t,n){let r=e.current().range;if(!e.expect(Ae.IDENTIFIER))return null;let o=new S(e.compilationData.nextSymbolID(),r,r.toString(),new Ue(4,e.scope()));if(o.flags|=e.flags|t,o.comments=n,!Tt(e,o))return null;let i=e.current().range,a=k.createStructBlock(),s=null;if(!e.expect(Ae.LEFT_BRACE))return null;e.pushScope(o.scope);while(!e.peek(Ae.RIGHT_BRACE)&&!e.peek(Ae.END_OF_FILE)){let t=dt(e,3);if(null===t)return null;if(t.kind===w.VARIABLES){a.appendChild(t);for(let n=t.variablesType().nextSibling();null!==n;n=n.nextSibling()){let t=n.symbol.asVariable();o.variables.push(t),null!==t.value()&&e.log.syntaxErrorStructVariableInitializer(t.value().range)}}else e.log.syntaxErrorInsideStruct(t.range)}if(e.popScope(),!e.expect(Ae.RIGHT_BRACE))return null;if(a.withRange(e.spanSince(i)),e.peek(Ae.IDENTIFIER)){if(s=gt(0,k.createType(o.resolvedType()),e.next().range,e,n),null===s)return null}else e.expect(Ae.SEMICOLON);return k.createStruct(o,a,s)}function st(e,t,n){let r=!1;for(let o=e.scope();null!==o;o=o.parent)if(3===o.kind){r=!0;break}return r||e.log.syntaxErrorOutsideLoop(t),lt(e,t,n)}function lt(e,t,n){return e.expect(Ae.SEMICOLON),n.withRange(e.spanSince(t))}function ut(e,t,n,r,o,i){let a=e.current().range;if(0===n&&!e.peek(Ae.IDENTIFIER)){let n=Pt.resume(e,0,r);return null===n?null:lt(e,t,k.createExpression(n))}if(!e.expect(Ae.IDENTIFIER))return null;if(e.eat(Ae.LEFT_PARENTHESIS))return vt(n,r,a,e,i);let s=gt(n,r,a,e,i);return null===s?null:s.withRange(e.spanSince(t))}function ct(e){let t=e.current(),n=t.comments;if(null===n)return null;let r=t.range.start,o=null;for(let i=n.length-1;i>=0;i-=1){let e=a(n,i),t=T(e.source.contents,e.end,r),s=0;for(let n=0;n<t.length;n+=1){let e=E(t,n);13!==e&&10!==e||(s+=1,13===e&&n+1<t.length&&10===E(t,n+1)&&(n+=1))}if(s>1)break;(null!==o?o:o=[]).push(e.toString()),r=e.start}return null!==o&&o.reverse(),o}function dt(e,t){let n=e.current();switch(n.kind){case Ae.BREAK:return st(e,e.next().range,k.createBreak());case Ae.CONTINUE:return st(e,e.next().range,k.createContinue());case Ae.DISCARD:return lt(e,e.next().range,k.createDiscard());case Ae.DO:return Qe(e);case Ae.EXPORT:case Ae.IMPORT:return Ke(e);case Ae.EXTENSION:return Je(e);case Ae.FOR:return Ze(e);case Ae.IF:return et(e);case Ae.LEFT_BRACE:return pt(e);case Ae.PRECISION:return it(e);case Ae.RETURN:return ot(e);case Ae.SEMICOLON:return k.createBlock().withRange(e.next().range);case Ae.VERSION:return tt(e);case Ae.DEFINE:return nt(e);case Ae.WHILE:return rt(e)}let r=ct(e),o=mt(e,t),i=null;if(e.eat(Ae.STRUCT)){let t=at(e,o,r);return null===t?null:t.withRange(e.spanSince(n.range))}if(0!==o){if(i=xt(e,1),null===i)return null}else i=xt(e,0);if(null!==i)return ut(e,n.range,o,i,1,r);let a=Pt.parse(e,0);return null===a?null:lt(e,n.range,k.createExpression(a))}function ft(e,t){if(t.kind===w.VARIABLES||t.kind===w.STRUCT||t.kind===w.DEFINE)return;let n=1===e.scope().kind||4===e.scope().kind,r=t.kind===w.EXTENSION||t.kind===w.FUNCTION||t.kind===w.PRECISION||t.kind===w.VERSION;r&&!n?e.log.syntaxErrorInsideFunction(t.range):!r&&n&&e.log.syntaxErrorOutsideFunction(t.range)}function ht(e,t){let n=e.current().range;if(!e.expect(Ae.STRING_LITERAL))return!1;let r=null;try{r=JSON.parse(n.toString())}catch(l){return e.log.syntaxErrorInvalidString(n),!1}let o=e.compilationData.fileAccess;if(null===o)return e.log.semanticErrorIncludeWithoutFileAccess(n),!1;let i=o(r,n.source.name);if(null===i)return e.log.semanticErrorIncludeBadPath(n,r),!1;if(e.processedIncludes.has(i.name))return!0;f(e.processedIncludes,i.name,!0),e.includes.push(new Fe(n,i.entireRange()));let a=Se(e.log,i,0),s=new Me(e.log,a,e.compilationData,e.resolver,e.processedIncludes);return s.pushScope(e.scope()),!(!Et(s,t,1)||!s.expect(Ae.END_OF_FILE))}function pt(e){let t=e.current(),n=k.createBlock();return e.pushScope(new Ue(2,e.scope())),e.expect(Ae.LEFT_BRACE)&&Et(e,n,2)&&e.expect(Ae.RIGHT_BRACE)?(e.popScope(),n.withRange(e.spanSince(t.range))):null}function mt(e,t){let n=0;while(1){let r=e.current().kind;switch(r){case Ae.ATTRIBUTE:n|=A.ATTRIBUTE;break;case Ae.CONST:n|=A.CONST;break;case Ae.HIGHP:n|=A.HIGHP;break;case Ae.IN:n|=A.IN;break;case Ae.INOUT:n|=A.INOUT;break;case Ae.LOWP:n|=A.LOWP;break;case Ae.MEDIUMP:n|=A.MEDIUMP;break;case Ae.OUT:n|=A.OUT;break;case Ae.UNIFORM:n|=A.UNIFORM;break;case Ae.VARYING:n|=A.VARYING;break;default:return n}(0===t&&(r===Ae.ATTRIBUTE||r===Ae.UNIFORM||r===Ae.VARYING)||3===t&&r!==Ae.LOWP&&r!==Ae.MEDIUMP&&r!==Ae.HIGHP||0!==t&&(r===Ae.INOUT||r===Ae.OUT&&1!==t||r===Ae.IN&&1!==t))&&e.log.syntaxErrorBadQualifier(e.current().range),e.next()}}function xt(e,t){let n=e.current(),r=null;switch(n.kind){case Ae.BOOL:r=N.BOOL;break;case Ae.BVEC2:r=N.BVEC2;break;case Ae.BVEC3:r=N.BVEC3;break;case Ae.BVEC4:r=N.BVEC4;break;case Ae.FLOAT:r=N.FLOAT;break;case Ae.UINT:r=N.UINT;break;case Ae.INT:r=N.INT;break;case Ae.IVEC2:r=N.IVEC2;break;case Ae.IVEC3:r=N.IVEC3;break;case Ae.IVEC4:r=N.IVEC4;break;case Ae.MAT2:r=N.MAT2;break;case Ae.MAT3:r=N.MAT3;break;case Ae.MAT4:r=N.MAT4;break;case Ae.SAMPLER2D:r=N.SAMPLER2D;break;case Ae.SAMPLER3D:r=N.SAMPLER3D;break;case Ae.SAMPLERCUBE:r=N.SAMPLERCUBE;break;case Ae.ISAMPLERCUBE:r=N.ISAMPLERCUBE;break;case Ae.USAMPLERCUBE:r=N.USAMPLERCUBE;break;case Ae.SAMPLER2DARRAY:r=N.SAMPLER2DARRAY;break;case Ae.ISAMPLER2DARRAY:r=N.ISAMPLER2DARRAY;break;case Ae.USAMPLER2DARRAY:r=N.USAMPLER2DARRAY;break;case Ae.SAMPLER2DSHADOW:r=N.SAMPLER2DSHADOW;break;case Ae.SAMPLERCUBESHADOW:r=N.SAMPLERCUBESHADOW;break;case Ae.SAMPLER2DARRAYSHADOW:r=N.SAMPLER2DARRAYSHADOW;break;case Ae.USAMPLER2DARRAYSHADOW:r=N.USAMPLER2DARRAYSHADOW;break;case Ae.ISAMPLER2DARRAYSHADOW:r=N.ISAMPLER2DARRAYSHADOW;break;case Ae.ISAMPLER2D:r=N.ISAMPLER2D;break;case Ae.USAMPLER2D:r=N.USAMPLER2D;break;case Ae.ISAMPLER3D:r=N.ISAMPLER3D;break;case Ae.USAMPLER3D:r=N.USAMPLER3D;break;case Ae.VEC2:r=N.VEC2;break;case Ae.VEC3:r=N.VEC3;break;case Ae.VEC4:r=N.VEC4;break;case Ae.UVEC2:r=N.UVEC2;break;case Ae.UVEC3:r=N.UVEC3;break;case Ae.UVEC4:r=N.UVEC4;break;case Ae.VOID:r=N.VOID;break;case Ae.IDENTIFIER:{let o=e.scope().find(n.range.toString());if(null===o||!o.isStruct())return 1===t&&e.unexpectedToken(),null;r=o.resolvedType();break}default:return 1===t&&e.unexpectedToken(),null}return e.next(),k.createType(r).withRange(e.spanSince(n.range))}function vt(e,t,n,o,i){let a=o.scope(),s=new C(o.compilationData.nextSymbolID(),n,n.toString(),new Ue(0,a));if(s.flags|=o.flags|e|("main"===s.name?A.EXPORTED:0),s.comments=i,s.returnType=t,o.pushScope(s.scope),o.eat(Ae.VOID)){if(!o.expect(Ae.RIGHT_PARENTHESIS))return null}else if(!o.eat(Ae.RIGHT_PARENTHESIS)){while(1){let e=mt(o,0),t=xt(o,1);if(null===t)return null;let n=o.current().range;if(!o.expect(Ae.IDENTIFIER))return null;let r=new O(o.compilationData.nextSymbolID(),n,n.toString(),o.scope(),0);if(r.flags|=e,r.type=t,s._arguments.push(r),Tt(o,r),!yt(o,r))return null;if(!o.eat(Ae.COMMA))break}if(!o.expect(Ae.RIGHT_PARENTHESIS))return null}let l=p(a.symbols,n.toString(),null),u=!o.eat(Ae.SEMICOLON);if(null===l)a.define(s);else{if(!l.isFunction())return o.log.syntaxErrorDuplicateSymbolDefinition(n,l.range),null;for(let e=l.asFunction();null!==e;e=e.previousOverload)if(e.hasSameArgumentTypesAs(s)){e.returnType.resolvedType!==s.returnType.resolvedType?o.log.syntaxErrorDifferentReturnType(s.returnType.range,s.name,s.returnType.resolvedType,e.returnType.resolvedType,e.returnType.range):null===e.block&&u?(r(null===e.sibling),r(null===s.sibling),e.sibling=s,s.sibling=e,s.flags|=e.flags,e.flags=s.flags):o.log.syntaxErrorDuplicateSymbolDefinition(s.range,e.range);break}s.previousOverload=l.asFunction(),a.redefine(s)}if(u){let e=o.flags;if(o.flags&=~(A.EXPORTED|A.IMPORTED),s.block=pt(o),o.flags&=e,null===s.block)return null}return o.popScope(),k.createFunction(s).withRange(o.spanSince(t.range))}function yt(e,t){let n=e.current();if(e.eat(Ae.LEFT_BRACKET)){if(e.eat(Ae.RIGHT_BRACKET))return e.log.syntaxErrorMissingArraySize(e.spanSince(n.range)),!0;if(t.arrayCount=Pt.parse(e,0),null===t.arrayCount||!e.expect(Ae.RIGHT_BRACKET))return!1;let r=0;if(e.resolver.resolveNode(t.arrayCount),e.resolver.checkConversion(t.arrayCount,N.INT),t.arrayCount.resolvedType!==N.ERROR){let n=J(t.arrayCount);if(null===n)e.log.syntaxErrorConstantRequired(t.arrayCount.range);else if(n.kind===w.INT){let o=n.asInt();o<1?e.log.syntaxErrorInvalidArraySize(t.arrayCount.range,o):r=o}}while(e.peek(Ae.LEFT_BRACKET)){if(n=e.next(),!e.peek(Ae.RIGHT_BRACKET)&&null===Pt.parse(e,0)||!e.expect(Ae.RIGHT_BRACKET))return!1;e.log.syntaxErrorMultidimensionalArray(e.spanSince(n.range))}t.type=k.createType(t.type.resolvedType.arrayType(r)).withRange(t.type.range)}return!0}function gt(e,t,n,r,o){let i=k.createVariables(r.flags|e,t);while(1){let a=new O(r.compilationData.nextSymbolID(),n,n.toString(),r.scope(),1===r.scope().kind?1:4===r.scope().kind?3:2);if(a.flags|=r.flags|e,a.comments=o,a.type=t,!yt(r,a))return null;let s=r.current().range,l=null;if(r.eat(Ae.ASSIGN)){let e=r.current();l=Pt.parse(r,1),null===l&&(l=k.createParseError().withRange(r.spanSince(e.range)))}else s=null;let u=k.createVariable(a,l).withRange(r.spanSince(a.range)).withInternalRange(s);if(a.node=u,a.isConst()&&r.resolver.resolveNode(u),i.appendChild(u),Tt(r,a),!r.eat(Ae.COMMA))return r.expect(Ae.SEMICOLON),i;if(n=r.current().range,!r.expect(Ae.IDENTIFIER))return null}}function Tt(e,t){let n=p(e.scope().symbols,t.name,null);return null!==n?(e.log.syntaxErrorDuplicateSymbolDefinition(t.range,n.range),!1):(e.scope().define(t),!0)}function Et(e,t,n){while(!e.peek(Ae.END_OF_FILE)&&!e.peek(Ae.RIGHT_BRACE)){let r=e.current().range;if(e.eat(Ae.INCLUDE)){if(1!==n)return e.log.syntaxErrorIncludeOutsideGlobal(r),e.eat(Ae.STRING_LITERAL),!1;if(!ht(e,t))return!1;continue}let o=dt(e,n);if(null===o)return!1;if(o.kind===w.MODIFIER_BLOCK)while(o.hasChildren()){let n=o.firstChild().remove();ft(e,n),t.appendChild(n)}else ft(e,o),t.appendChild(o)}return!0}function bt(e,t,n,r,o,i){null===Pt&&(Pt=ze());let a=new Map,s=new Me(e,t,r,i,a);return s.pushScope(o),Et(s,n,1)&&s.expect(Ae.END_OF_FILE),new Ge(s.includes)}let Pt=null,It=h(h(h(h(new Map,"disable",1),"enable",2),"require",3),"warn",4),At=h(h(h(h(new Map,"GL_OES_standard_derivatives",0),"GL_EXT_frag_depth",0),"GL_EXT_draw_buffers",0),"GL_EXT_shader_texture_lod",0);class wt{constructor(){this._isLoopBreakTarget=[],this._isControlFlowLive=[]}pushBlock(e){let t=e.parent();this._isControlFlowLive.push(0===this._isControlFlowLive.length||s(this._isControlFlowLive)),null!==t&&H(t.kind)&&this._isLoopBreakTarget.push(!1)}popBlock(e){let t=e.parent(),n=d(this._isControlFlowLive);n&&(e.hasControlFlowAtEnd=!0),null!==t&&H(t.kind)&&!d(this._isLoopBreakTarget)&&(t.kind===w.WHILE&&t.whileTest().isTrue()||t.kind===w.DO_WHILE&&t.doWhileTest().isTrue()||t.kind===w.FOR&&(null===t.forTest()||t.forTest().isTrue()))&&q(this._isControlFlowLive,!1)}visitStatement(e){if(s(this._isControlFlowLive))switch(e.kind){case w.BREAK:0!==this._isLoopBreakTarget.length&&q(this._isLoopBreakTarget,!0),q(this._isControlFlowLive,!1);break;case w.RETURN:case w.DISCARD:case w.CONTINUE:q(this._isControlFlowLive,!1);break;case w.IF:{let t=e.ifTest(),n=e.ifTrue(),r=e.ifFalse();t.isTrue()?n.hasControlFlowAtEnd||q(this._isControlFlowLive,!1):t.isFalse()&&null!==r?r.hasControlFlowAtEnd||q(this._isControlFlowLive,!1):null!==n&&null!==r&&(n.hasControlFlowAtEnd||r.hasControlFlowAtEnd||q(this._isControlFlowLive,!1));break}}}}class Rt{constructor(e,t){this._log=e,this._data=t,this._controlFlow=new wt,this._versions=[],this._generatedExtensions=new Map,this._returnType=null}resolveGlobal(e){this.resolveNode(e);for(const n of this._versions)n.remove();let t=e.firstChild();0!==this._versions.length&&e.insertChildBefore(t,c(this._versions));for(const n of Array.from(this._generatedExtensions.values()))e.insertChildBefore(t,n)}_maybeMarkAsUnused(e){e.range.source.name===I||0!==e.useCount||e.isExported()||this._log.unusedSymbols.push(e)}resolveNode(e){if(null!==e.resolvedType)return;e.resolvedType=N.ERROR;let t=e.kind;switch(t){case w.GLOBAL:case w.STRUCT_BLOCK:this._resolveChildren(e);break;case w.VARIABLE:{let t=e.symbol.asVariable();this._maybeMarkAsUnused(t),this.resolveNode(t.type);let n=t.type.resolvedType;if(n===N.VOID&&(this._log.semanticErrorBadVariableType(t.type.range,n),n=N.ERROR),null!==t.arrayCount&&(this._resolveAsExpression(t.arrayCount),this.checkConversion(t.arrayCount,N.INT)),null!==t.value()&&(this._resolveAsExpression(t.value()),this.checkConversion(t.value(),n),n.containsArray&&this._log.semanticErrorArrayAssignment(e.internalRange,n)),t.isConst())if(null!==t.value()){if(t.value().resolvedType!==N.ERROR){let e=J(t.value());null===e?this._log.syntaxErrorConstantRequired(t.value().range):(r(null===e.parent()),r(null!==e.resolvedType),t.constantValue=e)}}else 2===t.kind&&this._log.semanticErrorUninitializedConstant(t.range);break}case w.BLOCK:this._resolveBlockOrStatement(e);break;case w.BREAK:case w.CONTINUE:case w.DISCARD:break;case w.DO_WHILE:this._resolveBlockOrStatement(e.doWhileBody()),this.resolveNode(e.doWhileTest()),this.checkConversion(e.doWhileTest(),N.BOOL);break;case w.EXPRESSION:this.resolveNode(e.expressionValue());break;case w.EXTENSION:break;case w.DEFINE:break;case w.FOR:null!==e.forSetup()&&this._resolveAsExpression(e.forSetup()),null!==e.forTest()&&(this._resolveAsExpression(e.forTest()),this.checkConversion(e.forTest(),N.BOOL)),null!==e.forUpdate()&&this._resolveAsExpression(e.forUpdate()),this._resolveBlockOrStatement(e.forBody());break;case w.FUNCTION:{let t=e.symbol.asFunction();this._maybeMarkAsUnused(t);for(const e of t._arguments)this.resolveNode(e.type);this.resolveNode(t.returnType),null!==t.block&&(this._returnType=t.returnType.resolvedType,this._resolveBlockOrStatement(t.block),null!==this._returnType&&this._returnType!==N.VOID&&t.block.hasControlFlowAtEnd&&this._log.semanticErrorMissingReturn(t.range,t.name,this._returnType),this._returnType=null);break}case w.IF:this.resolveNode(e.ifTest()),this.checkConversion(e.ifTest(),N.BOOL),this._resolveBlockOrStatement(e.ifTrue()),null!==e.ifFalse()&&this._resolveBlockOrStatement(e.ifFalse());break;case w.PRECISION:break;case w.RETURN:null!==e.returnValue()?(this.resolveNode(e.returnValue()),this.checkConversion(e.returnValue(),null!==this._returnType?this._returnType:N.ERROR)):(e.resolvedType=N.VOID,this.checkConversion(e,null!==this._returnType?this._returnType:N.ERROR));break;case w.STRUCT:{let t=e.symbol.asStruct();this._maybeMarkAsUnused(t),this._resolveChildren(e);let n=t.resolvedType();for(const e of t.asStruct().variables){let t=e.type.resolvedType;t.containsArray&&(n.containsArray=!0),t.containsSampler&&(n.containsSampler=!0)}break}case w.VARIABLES:this._resolveChildren(e);break;case w.VERSION:this._versions.push(e);break;case w.WHILE:this.resolveNode(e.whileTest()),this.checkConversion(e.whileTest(),N.BOOL),this._resolveBlockOrStatement(e.whileBody());break;case w.CALL:this._resolveCall(e);break;case w.DOT:this._resolveDot(e);break;case w.HOOK:{let t=e.hookTest(),n=e.hookFalse(),r=e.hookTrue();this._resolveAsExpression(t),this.checkConversion(t,N.BOOL),this._resolveAsExpression(r),this._resolveAsExpression(n),r.resolvedType!==n.resolvedType?this._log.semanticErrorBadHookTypes(Ie.span(r.range,n.range),r.resolvedType,n.resolvedType):r.resolvedType.containsArray?this._log.semanticErrorArrayHook(Ie.span(r.range,n.range),r.resolvedType):e.resolvedType=r.resolvedType;break}case w.NAME:{let t=e.symbol;t.isVariable()?(this.resolveNode(t.asVariable().type),e.resolvedType=t.asVariable().type.resolvedType):t.isFunction()&&!e.isCallTarget()?this._log.semanticErrorMustCallFunction(e.range,t.name):e.resolvedType=t.resolvedType();let n=t.requiredExtension;null===n||this._generatedExtensions.has(n)||0!==this._data.extensionBehavior(n)||f(this._generatedExtensions,n,k.createExtension(n,2));break}case w.SEQUENCE:for(let t=e.firstChild();null!==t;t=t.nextSibling())this._resolveAsExpression(t);e.resolvedType=e.lastChild().resolvedType;break;default:M(t)?this._resolveUnary(e):G(t)?this._resolveBinary(e):r(!1);break}r(null!==e.resolvedType)}_resolveBlockOrStatement(e){if(r(D(e.kind)),this._controlFlow.pushBlock(e),e.kind===w.BLOCK)for(let t=e.firstChild();null!==t;t=t.nextSibling())this.resolveNode(t),this._controlFlow.visitStatement(t);else this.resolveNode(e),this._controlFlow.visitStatement(e);this._controlFlow.popBlock(e)}_resolveUnary(e){let t=e.unaryValue();this._resolveAsExpression(t),U(e.kind)&&this._checkStorage(t);let n=t.resolvedType;switch(e.kind){case w.NEGATIVE:case w.POSITIVE:case w.PREFIX_DECREMENT:case w.PREFIX_INCREMENT:case w.POSTFIX_DECREMENT:case w.POSTFIX_INCREMENT:e.resolvedType=n.isIntOrFloat()?n:N.ERROR;break;case w.NOT:e.resolvedType=n===N.BOOL?N.BOOL:N.ERROR;break}e.resolvedType===N.ERROR&&n!==N.ERROR&&this._log.semanticErrorBadUnaryOperator(e.internalRange,e.internalRange.toString(),n)}_resolveBinary(e){let t=e.binaryLeft(),n=e.binaryRight();this._resolveAsExpression(t),this._resolveAsExpression(n),j(e.kind)&&this._checkStorage(t);let r=t.resolvedType,o=n.resolvedType,i=r===o;switch(e.kind){case w.ADD:case w.SUBTRACT:case w.MULTIPLY:case w.DIVIDE:e.resolvedType=i&&null!==r.componentType()||r.hasFloatComponents()&&o===N.FLOAT||r.hasIntComponents()&&o===N.INT?r:r===N.FLOAT&&o.hasFloatComponents()||r===N.INT&&o.hasIntComponents()?o:e.kind===w.MULTIPLY&&(r===N.VEC2&&o===N.MAT2||r===N.MAT2&&o===N.VEC2)?N.VEC2:e.kind===w.MULTIPLY&&(r===N.VEC3&&o===N.MAT3||r===N.MAT3&&o===N.VEC3)?N.VEC3:e.kind===w.MULTIPLY&&(r===N.VEC4&&o===N.MAT4||r===N.MAT4&&o===N.VEC4)?N.VEC4:N.ERROR;break;case w.EQUAL:case w.NOT_EQUAL:e.resolvedType=i&&r.canUseEqualityOperators()?N.BOOL:N.ERROR;break;case w.LOGICAL_AND:case w.LOGICAL_OR:case w.LOGICAL_XOR:e.resolvedType=i&&r===N.BOOL?N.BOOL:N.ERROR;break;case w.LESS_THAN:case w.LESS_THAN_OR_EQUAL:case w.GREATER_THAN:case w.GREATER_THAN_OR_EQUAL:e.resolvedType=!i||r!==N.FLOAT&&r!==N.INT?N.ERROR:N.BOOL;break;case w.ASSIGN:return e.resolvedType=r,r.containsArray&&this._log.semanticErrorArrayAssignment(e.internalRange,r),void this.checkConversion(n,r);case w.ASSIGN_ADD:case w.ASSIGN_SUBTRACT:case w.ASSIGN_MULTIPLY:case w.ASSIGN_DIVIDE:e.resolvedType=i&&null!==r.componentType()||r.hasFloatComponents()&&o===N.FLOAT||r.hasIntComponents()&&o===N.INT||e.kind===w.ASSIGN_MULTIPLY&&(r===N.VEC2&&o===N.MAT2||r===N.VEC3&&o===N.MAT3||r===N.VEC4&&o===N.MAT4)?r:N.ERROR;break;case w.INDEX:if(o===N.INT){let t=r.indexType();null!==t&&(e.resolvedType=t);let o=J(n);if(null!==o&&o.kind===w.INT){let e=o.asInt(),t=r.indexCount();(e<0||0!==t&&e>=t)&&this._log.semanticErrorOutOfBoundsIndex(n.range,e,r)}}break}e.resolvedType===N.ERROR&&r!==N.ERROR&&o!==N.ERROR&&(e.kind===w.INDEX?this._log.semanticErrorBadIndex(e.internalRange,r,o):this._log.semanticErrorBadBinaryOperator(e.internalRange,e.internalRange.toString(),r,o))}_resolveCall(e){let t=e.callTarget();this.resolveNode(t);let n=t.resolvedType,r=n.symbol,o=[],i=!1;for(let a=t.nextSibling();null!==a;a=a.nextSibling())this._resolveAsExpression(a),o.push(a),a.resolvedType===N.ERROR&&(i=!0);if(!i){if(null!==r){if(r.isFunction())return void this._resolveFunctionOverloads(r.asFunction(),e,o);if(r.isStruct())return void this._resolveConstructor(n,e,o)}n!==N.ERROR&&this._log.semanticErrorBadCall(t.range,n)}}_resolveDot(e){let t=e.dotTarget(),n=e.asString(),r=e.internalRange;if(this._resolveAsExpression(t),""===n)return;let o=t.resolvedType,i=e.isAssignTarget(),a=o;if(a===N.BVEC2||a===N.IVEC2||a===N.VEC2||a===N.BVEC3||a===N.IVEC3||a===N.VEC3||a===N.BVEC4||a===N.IVEC4||a===N.VEC4||a===N.UVEC2||a===N.UVEC3||a===N.UVEC4)e.resolvedType=this._validateSwizzle(r,o,n,i);else if(a===N.ERROR);else{if(null!==o.symbol&&o.symbol.isStruct())for(const t of o.symbol.asStruct().variables)if(t.name===n){e.symbol=t,this.resolveNode(t.type),e.resolvedType=t.type.resolvedType;break}null===e.symbol&&this._log.semanticErrorBadMember(r,o,n)}}_resolveFunctionOverloads(e,t,n){let r=[];for(let i=e;null!==i;i=i.previousOverload)-1===r.indexOf(i.sibling)&&r.push(i);if(1!==r.length&&(r=r.slice(),u(r,e=>e._arguments.length!==n.length),1!==r.length)){let e=r.slice();u(r,e=>{for(let t=0,r=n.length;t<r;t+=1)if(a(e._arguments,t).type.resolvedType!==a(n,t).resolvedType)return!0;return!1}),1!==r.length&&(r=e,u(r,e=>{for(let t=0,r=n.length;t<r;t+=1){let r=a(e._arguments,t).type.resolvedType,o=a(n,t).resolvedType,i=r.componentCount(),s=o.componentCount();if(r!==o&&(0===i||0===s||i!==s))return!0}return!1}))}if(1!==r.length)return void this._log.semanticErrorBadOverloadMatch(t.callTarget().range,e.name);let o=c(r);if(o._arguments.length!==n.length)this._log.semanticErrorArgumentCountFunction(t.internalRange,o._arguments.length,n.length,o.name,o.range);else for(let i=0,s=n.length;i<s;i+=1)this.checkConversion(a(n,i),a(o._arguments,i).type.resolvedType);t.callTarget().symbol=o,t.resolvedType=o.returnType.resolvedType}_resolveConstructor(e,t,n){if(t.resolvedType=e,e===N.ERROR)return;if(null!==e.componentType()){let r=e.componentCount(),o=!1,i=0;for(const t of n){let n=t.resolvedType,a=n.componentCount();if(null===n.componentType())return void(n!==N.ERROR&&this._log.semanticErrorBadConstructorValue(t.range,n,e));i>=r&&this._log.semanticErrorExtraConstructorValue(t.range,e,r,i+a),n.isMatrix()&&(o=!0),i+=a}let a=e.isMatrix()&&o;return void(a&&1!==n.length?this._log.semanticErrorBadMatrixConstructor(t.internalRange):i<r&&1!==i&&!a&&this._log.semanticErrorBadConstructorCount(t.internalRange,e,i))}let r=e.symbol.asStruct(),o=r.variables,i=o.length,s=n.length;if(i===s)for(let l=0,u=i;l<u;l+=1)this.checkConversion(a(n,l),a(o,l).type.resolvedType);else this._log.semanticErrorArgumentCountConstructor(t.internalRange,i,s,r.name,r.range)}_validateSwizzle(e,t,n,r){let o=n.length;if(o<1||o>4)return this._log.semanticErrorBadSwizzle(e,t,n),N.ERROR;let i=t.componentCount();for(const a of $(i))if(-1!==a.indexOf(b(n,0))){for(let i=1,s=o;i<s;i+=1){if(-1===a.indexOf(b(n,i)))return this._log.semanticErrorBadSwizzle(e,t,n),N.ERROR;if(r&&-1!==T(n,0,i).indexOf(b(n,i)))return this._log.semanticErrorBadSwizzleAssignment(e.slice(i,i+1),b(n,i)),N.ERROR}return z(t.componentType(),o)}return this._log.semanticErrorBadSwizzle(e,t,n),N.ERROR}_resolveAsExpression(e){this.resolveNode(e),e.kind===w.TYPE&&e.resolvedType!==N.ERROR&&(this._log.semanticErrorUnexpectedType(e.range,e.resolvedType),e.resolvedType=N.ERROR)}_resolveChildren(e){for(let t=e.firstChild();null!==t;t=t.nextSibling())this.resolveNode(t)}_checkStorage(e){let t=e;r(F(e.kind));e:while(1){if(t.resolvedType===N.ERROR)break;switch(t.kind){case w.NAME:(t.symbol.isConst()||t.symbol.isUniform())&&this._log.semanticErrorBadStorage(e.range);break e;case w.DOT:t=t.dotTarget();break;case w.INDEX:t=t.binaryLeft();break;default:this._log.semanticErrorBadStorage(e.range);break e}}}checkConversion(e,t){e.resolvedType!==t&&e.resolvedType!==N.ERROR&&t!==N.ERROR&&this._log.semanticErrorBadConversion(e.range,e.resolvedType,t)}}class _t{constructor(){this.compactSyntaxTree=!0,this.removeWhitespace=!0,this.runPreprocessor=!0,this.renameSymbols=0,this.trimSymbols=!0,this.fileAccess=null,this.globals=null}}class St{constructor(e){this.currentExtensions=new Map,this.fileAccess=e,this._nextSymbolID=0}nextSymbolID(){return this._nextSymbolID=this._nextSymbolID+1,this._nextSymbolID}extensionBehavior(e){return p(this.currentExtensions,e,0)}}class Ct{constructor(e,t){this.global=e,this.includes=t}}function Ot(e,t,n){if(n.runPreprocessor){for(const n of t)Re(e,n);for(const n of t)_e(e,n)}for(const l of t)null===l.tokens&&(l.tokens=Se(e,l,0));let r=k.createGlobal(),o=new Ue(1,null),i=new St(n.fileAccess),a=new Rt(e,i),s=[];for(const u of t){let t=bt(e,u.tokens,r,i,o,a);l(s,t.includes)}return a.resolveGlobal(r),new Ct(r,s)}class Lt{static floatToString(e,t){let n=e.toString(),r=e.toExponential();r.length<n.length&&(n=r);let o=n.indexOf("e"),i="";return-1!==o&&(i=g(n,o),n=T(n,0,o)),n=(+(+n).toFixed(6)).toString(),""===i&&-1===n.indexOf(".")&&(n+=1===t?".":".0"),1===t&&n.startsWith("0.")&&"0."!==n&&(n=g(n,1)),1===t&&n.startsWith("-0.")&&"-0."!==n&&(n="-"+g(n,2)),n+i}}class Nt{constructor(e,t){this.code=e,this.documentation=t}}class kt{constructor(e,t){this.source=e,this.index=t,this.resolvedType=null,this.symbol=null,this.range=null,this.swizzleName=null,this.swizzleType=null}generateTooltip(){return null!==this.swizzleName?new Nt(`${this.swizzleType} ${this.swizzleName};`,""):null!==this.symbol?new Nt(jt(this.symbol),qt(this.symbol.comments)):null}run(e){this._visit(e)}_touches(e){return e.source===this.source&&e.touches(this.index)}_visitSymbol(e){return!!this._touches(e.range)&&(this.resolvedType=e.resolvedType(),this.symbol=e,this.range=e.range,!0)}_visitVariable(e){return this._visitSymbol(e)||this._visit(e.type)||this._visit(e.arrayCount)||this._visit(e.value())}_visitFunction(e){for(const t of e._arguments)if(this._visitVariable(t))return!0;return this._visitSymbol(e)||this._visit(e.returnType)||this._visit(e.block)}_visitStruct(e){for(const t of e.variables)if(this._visitVariable(t))return!0;return this._visitSymbol(e)}_visit(e){let t;if(null===e)return!1;for(let n=e.firstChild();null!==n;n=n.nextSibling())if(this._visit(n))return!0;switch(e.kind){case w.NAME:if(this._touches(e.range))return this.resolvedType=e.resolvedType,this.symbol=e.symbol,this.range=e.range,!0;break;case w.TYPE:if(this._touches(e.range))return this.resolvedType=e.resolvedType,this.symbol=(null!==(t=this.resolvedType).isArrayOf?t.isArrayOf:this.resolvedType).symbol,this.range=e.range,!0;break;case w.DOT:if(this._touches(e.internalRange))return this.resolvedType=e.resolvedType,e.dotTarget().resolvedType.isVector()?(this.swizzleName=e.asString(),this.swizzleType=e.resolvedType):this.symbol=e.symbol,this.range=e.internalRange,!0;break;case w.VARIABLE:return this._visitVariable(e.symbol.asVariable());case w.FUNCTION:return this._visitFunction(e.symbol.asFunction());case w.STRUCT:return this._visitStruct(e.symbol.asStruct())}return!1}}class Dt{constructor(e){this.source=e,this.symbols=[]}run(e){this._visit(e)}_visit(e){switch(e.kind){case w.STRUCT:case w.FUNCTION:this._collectSymbol(e.symbol);break;case w.VARIABLES:for(let t=e.variablesType().nextSibling();null!==t;t=t.nextSibling())r(t.kind===w.VARIABLE),this._collectSymbol(t.symbol);break;case w.GLOBAL:for(let t=e.firstChild();null!==t;t=t.nextSibling())this._visit(t);break}}_collectSymbol(e){null!==e.range&&e.range.source===this.source&&this.symbols.push(e)}}class Ft{constructor(e,t){this.source=e,this.index=t,this.ranges=[],this.symbol=null}run(e){let t=new kt(this.source,this.index);if(t.run(e),this.symbol=t.symbol,null!==this.symbol){this._visit(e);let t=null;this.ranges.sort((e,t)=>e.source===t.source?W(e.start,t.start):y(e.source.name,t.source.name)),u(this.ranges,e=>{let n=t;return t=e,null!==n&&t.overlaps(n)})}}_appendRange(e,t){t===this.symbol&&null!==e&&e.toString()===this.symbol.name&&this.ranges.push(e)}_visitVariable(e){this._appendRange(e.range,e),this._visit(e.type),this._visit(e.arrayCount),this._visit(e.value())}_visitFunction(e){this._appendRange(e.range,e),this._appendRange(e.range,e.sibling),this._visit(e.returnType),this._visit(e.block);for(const t of e._arguments)this._visitVariable(t)}_visitStruct(e){this._appendRange(e.range,e);for(const t of e.variables)this._visitVariable(t)}_visit(e){if(null!==e){for(let t=e.firstChild();null!==t;t=t.nextSibling())this._visit(t);switch(e.kind){case w.NAME:this._appendRange(e.range,e.symbol);break;case w.DOT:this._appendRange(e.internalRange,e.symbol);break;case w.TYPE:this._appendRange(e.range,e.resolvedType.symbol);break;case w.VARIABLE:this._visitVariable(e.symbol.asVariable());break;case w.FUNCTION:this._visitFunction(e.symbol.asFunction());break;case w.STRUCT:this._visitStruct(e.symbol.asStruct());break}}}}class Mt{constructor(e,t){this.kind=e,this.name=t,this.detail="",this.documentation=""}}class Vt{constructor(e,t){this.source=e,this.index=t,this._map=new Map,this.completions=[]}run(e){this._addTextualCompletion("keyword","false"),this._addTextualCompletion("keyword","true"),this._addTextualCompletion("keyword","void");for(const t of N.BUILT_INS)this._addTextualCompletion("struct",t.symbol.name).detail=jt(t.symbol);this._visit(e,!0)}_touches(e){return null!==e&&e.source===this.source&&e.touches(this.index)}_addTextualCompletion(e,t){let n=null;return this._map.has(t)?n=m(this._map,t):(n=new Mt(e,t),this.completions.push(n),f(this._map,t,n)),n}_addSymbolCompletion(e){let t=e.isFunction()?"function":e.isStruct()?"struct":"variable",n=this._addTextualCompletion(t,e.name);""!==n.detail?n.detail+="\n":n.documentation=qt(e.comments),n.detail+=jt(e)}_visit(e,t){if(null===e)return!1;let n=this._touches(e.range);switch(e.kind){case w.FUNCTION:if(this._addSymbolCompletion(e.symbol),n){let t=e.symbol.asFunction();this._addTextualCompletion("keyword","discard"),this._addTextualCompletion("keyword","return");for(const e of t._arguments)this._addSymbolCompletion(e);this._visit(t.block,!1)}break;case w.VARIABLE:this._addSymbolCompletion(e.symbol);break;case w.STRUCT:this._addSymbolCompletion(e.symbol);break;case w.FOR:case w.WHILE:case w.DO_WHILE:n&&(this._addTextualCompletion("keyword","break"),this._addTextualCompletion("keyword","continue"));break;case w.DOT:{let t=e.dotTarget();if(n&&!this._touches(t.range)){this.completions=[];let e=t.resolvedType,n=e;if(n===N.BVEC2||n===N.IVEC2||n===N.VEC2||n===N.BVEC3||n===N.IVEC3||n===N.VEC3||n===N.BVEC4||n===N.IVEC4||n===N.VEC4||n===N.UVEC2||n===N.UVEC3||n===N.UVEC4)for(const t of $(e.componentCount()))for(let n=1;n<=4;n+=1){let r=[];for(let e=0;e<n;e+=1)r.push(0);while(1){let i="";for(let e=0;e<n;e+=1)i+=b(t,a(r,e));let s=z(e.componentType(),i.length).symbol;this._addTextualCompletion("variable",i).detail=`${s.name} ${i};`;let l=0;while(l<n){let e=a(r,l);if((e+=1)===t.length&&(e=0),o(r,l,e),0!==e)break;l+=1}if(l===n)break}}else if(null!==e.symbol&&e.symbol.isStruct())for(const t of e.symbol.asStruct().variables)this._addSymbolCompletion(t);return!0}break}}if(t||n||e.kind===w.VARIABLES)for(let r=e.firstChild();null!==r;r=r.nextSibling())if(this._visit(r,!1))return!0;return n}}class Bt{constructor(e,t,n){this.text=e,this._arguments=t,this.documentation=n}}class Ut{constructor(e,t){this.source=e,this.index=t,this.signatures=[],this.activeArgument=-1,this.activeSignature=-1}run(e){this._visit(e)}_touches(e){return null!==e&&e.source===this.source&&e.touches(this.index)}_visit(e){if(null===e)return!1;if(e.kind!==w.GLOBAL&&!this._touches(e.range))return!1;for(let t=e.firstChild();null!==t;t=t.nextSibling())if(this._visit(t))return!0;switch(e.kind){case w.FUNCTION:return this._visit(e.symbol.asFunction().block),!0;case w.CALL:{let t=e.callTarget();if(!this._touches(t.range)){let e=t.nextSibling(),n=t.resolvedType,r=n.symbol,o=[];for(let t=e;null!==t;t=t.nextSibling())o.push(t);if(r.isFunction()){let e=[];for(let t=r.asFunction();null!==t;t=t.previousOverload)-1===e.indexOf(t.sibling)&&e.push(t);e.reverse();for(const t of e)this.signatures.push(new Bt(jt(t),t._arguments.map(e=>Ht(e)),qt(t.comments)));if(0!==this.signatures.length){this.activeSignature=0;let t=[];for(let n=0;n<e.length;n+=1)t.push(n);for(let n=o.length;n>0;n-=1){let r=[];for(const o of t)a(e,o)._arguments.length>=n&&r.push(o);if(0!==r.length){t=r;break}}if(t.length>1){let n=t.slice();u(n,t=>{let n=a(e,t)._arguments;for(let e=0,r=Math.min(n.length,o.length);e<r;e+=1){let t=a(n,e).type.resolvedType,r=a(o,e).resolvedType;if(r!==N.ERROR&&t!==r)return!0}return!1}),0===n.length&&(n=t.slice(),u(n,t=>{let n=a(e,t)._arguments;for(let e=0,r=Math.min(n.length,o.length);e<r;e+=1){let t=a(n,e).type.resolvedType,r=a(o,e).resolvedType,i=t.componentCount(),s=r.componentCount();if(r!==N.ERROR&&t!==r&&(0===i||0===s||i!==s))return!0}return!1})),0!==n.length&&(t=n)}0!==t.length&&(this.activeSignature=a(t,0))}}if(r.isStruct()&&null===n.componentType()){let e=r.asStruct().variables.map(e=>Ht(e));this.signatures.push(new Bt(`${r.name}(${e.join(", ")});`,e,qt(r.comments))),this.activeSignature=0}if(0!==o.length){this.activeArgument=0;for(const e of o){if(this.index<=e.range.end||null===e.nextSibling())break;this.activeArgument=this.activeArgument+1}}return!0}break}}return!1}}function Gt(e){switch(e.kind){case w.INT:return e.asInt().toString();case w.BOOL:return e.asBool().toString();case w.FLOAT:return Lt.floatToString(e.asFloat(),0);case w.CALL:{r(e.callTarget().kind===w.TYPE),r(e.callTarget().resolvedType===e.resolvedType);let t=e.callTarget(),n=e.resolvedType+"(";for(let e=t.nextSibling();null!==e;e=e.nextSibling())e.previousSibling()!==t&&(n+=", "),n+=Gt(e);return n+")"}}return null}function jt(e){if(e.isStruct()){let t=e.asStruct(),n=`${L(t.flags)}struct ${e.name}`;if(!t.isNative()){n+=" {\n";for(const e of t.variables)n+=`  ${Ht(e)};\n`;n+="}"}return n+";"}if(e.isVariable()){let t=e.asVariable(),n=Ht(t);if(null!==t.constantValue){let e=Gt(t.constantValue);null!==e&&(n+=" = "+e)}return n+";"}if(e.isFunction()){let t=e.asFunction(),n=`${L(t.flags)}${t.returnType.resolvedType} ${e.name}(`;for(const e of t._arguments)e!==c(t._arguments)&&(n+=", "),n+=Ht(e);return n+");"}return r(!1),null}function Ht(e){let t=e.type.resolvedType,n=`${L(e.flags)}${null!==t.isArrayOf?t.isArrayOf:t} ${e.name}`;return null!==t.isArrayOf&&(n+=0!==t.arrayCount?`[${t.arrayCount}]`:"[]"),n}function qt(e){let t="";if(null!==e)for(const n of e){let e=0,r=n.length;n.startsWith("//")?e+=2:n.startsWith("/*")&&(e+=2,r-=2);while(e<r&&32===E(n,e))e+=1;while(r>e&&32===E(n,r-1))r-=1;""!==t&&(t+="\n"),t+=T(n,e,r)}return t}var Wt;(function(e){e[e["ERROR"]=0]="ERROR",e[e["WARNING"]=1]="WARNING"})(Wt||(Wt={}));class Xt{constructor(e,t,n){this.kind=e,this.range=t,this.text=n,this.noteRange=null,this.noteText=""}}class $t{constructor(){this.diagnostics=[],this.unusedSymbols=[],this.defines=new Map,this.warningCount=0,this.errorCount=0,this._prevErrorRange=null}error(e,t){null!==this._prevErrorRange&&this._prevErrorRange.start===e.start||(this._prevErrorRange=e,this.diagnostics.push(new Xt(Wt.ERROR,e,t)),this.errorCount=this.errorCount+1)}warning(e,t){this.diagnostics.push(new Xt(Wt.WARNING,e,t)),this.warningCount=this.warningCount+1}note(e,t){let n=s(this.diagnostics);n.noteRange=e,n.noteText=t}syntaxWarningUnknownExtension(e,t){this.warning(e,`The extension "${t}" is not in the known list of valid WebGL extensions`)}syntaxErrorInvalidString(e){this.error(e,"Invalid string literal")}syntaxErrorDisabledExtension(e,t,n){this.error(e,`Cannot use "${t}" from disabled extension "${n}"`)}syntaxErrorExtraData(e,t){this.error(e,`Syntax error "${t}"`)}syntaxErrorReservedWord(e){this.error(e,`"${e}" is a reserved word`)}syntaxErrorUnexpectedToken(e){this.error(e.range,"Unexpected "+Ae[e.kind])}syntaxErrorExpectedToken1(e,t){this.error(e,"Expected "+Ae[t])}syntaxErrorExpectedToken2(e,t,n){this.error(e,`Expected ${Ae[n]} but found ${Ae[t]}`)}syntaxErrorBadSymbolReference(e){this.error(e,`There is no symbol called "${e}" in the current scope`)}syntaxErrorDuplicateSymbolDefinition(e,t){this.error(e,`There is already a symbol called "${e}" in the current scope`),this.note(t,`The previous definition of "${t}" is here`)}syntaxErrorOutsideLoop(e){this.error(e,"This statement cannot be used outside a loop")}syntaxErrorStructVariableInitializer(e){this.error(e,"Cannot initialize struct variables")}syntaxErrorInsideStruct(e){this.error(e,"This statement cannot be used inside a struct")}syntaxErrorInsideFunction(e){this.error(e,"This statement cannot be used inside a function")}syntaxErrorOutsideFunction(e){this.error(e,"This statement cannot be used outside a function")}syntaxErrorIncludeOutsideGlobal(e){this.error(e,'"#include" statements cannot be used here')}semanticErrorIncludeWithoutFileAccess(e){this.error(e,"Cannot include files without access to a file system")}semanticErrorIncludeBadPath(e,t){this.error(e,"Cannot read the file "+JSON.stringify(t))}syntaxErrorDifferentReturnType(e,t,n,r,o){this.error(e,`Cannot change the return type of "${t}" to type "${n}"`),this.note(o,`The forward declaration of "${t}" has a return type of "${r}"`)}syntaxErrorBadQualifier(e){this.error(e,"Cannot use this qualifier here")}syntaxErrorConstantRequired(e){this.error(e,"This value must be a compile-time constant")}syntaxErrorInvalidArraySize(e,t){this.error(e,`Cannot declare an array with a size of "${t}"`)}syntaxErrorMissingArraySize(e){this.error(e,"All array sizes must be specified")}syntaxErrorMultidimensionalArray(e){this.error(e,"Multidimensional arrays are not a part of the language")}syntaxErrorInvalidOperator(e){this.error(e,`The operator "${e}" is reserved and cannot be used`)}semanticErrorBadConversion(e,t,n){this.error(e,`Cannot convert from type "${t}" to type "${n}"`)}semanticErrorUnexpectedType(e,t){this.error(e,`Unexpected type "${t}"`)}semanticErrorBadVariableType(e,t){this.error(e,`Cannot create a variable of type "${t}"`)}semanticErrorBadMember(e,t,n){this.error(e,`Cannot find "${n}" on type "${t}"`)}semanticErrorBadSwizzle(e,t,n){this.error(e,`Invalid swizzle "${n}" on type "${t}"`)}semanticErrorBadSwizzleAssignment(e,t){this.error(e,`The field "${t}" cannot be specified multiple times when used as a storage location`)}semanticErrorMustCallFunction(e,t){this.error(e,`The function "${t}" must be called`)}semanticErrorBadCall(e,t){this.error(e,`Cannot call type "${t}"`)}semanticErrorBadConstructorValue(e,t,n){this.error(e,`Cannot use value of type "${t}" when constructing type "${n}"`)}semanticErrorExtraConstructorValue(e,t,n,r){this.error(e,`The constructor for type "${t}" only takes ${n} argument${$t.plural(n)} and this argument would bring the total to ${r}`)}semanticErrorBadConstructorCount(e,t,n){this.error(e,`Cannot construct type "${t}" with ${n} argument${$t.plural(n)}`)}semanticErrorArgumentCountFunction(e,t,n,r,o){this.error(e,`Expected ${t} argument${$t.plural(t)} but found ${n} argument${$t.plural(n)} when calling function "${r}"`),null!==o&&this.note(o,`The definition of function "${r}" is here`)}semanticErrorArgumentCountConstructor(e,t,n,r,o){this.error(e,`Expected ${t} argument${$t.plural(t)} but found ${n} argument${$t.plural(n)} when constructing type "${r}"`),null!==o&&this.note(o,`The definition of struct "${r}" is here`)}semanticErrorBadOverloadMatch(e,t){this.error(e,`No matching overload for function "${t}"`)}semanticErrorBadHookTypes(e,t,n){this.error(e,`Cannot merge type "${t}" and type "${n}"`)}semanticErrorArrayHook(e,t){null!==t.isArrayOf?this.error(e,`Cannot use a conditional expression with array type "${t}"`):this.error(e,`Cannot use a conditional expression with type "${t}" because it contains an array`)}semanticErrorArrayAssignment(e,t){null!==t.isArrayOf?this.error(e,`Cannot assign to array type "${t}"`):this.error(e,`Cannot assign to type "${t}" because it contains an array`)}semanticErrorBadUnaryOperator(e,t,n){this.error(e,`No unary operator "${t}" for type "${n}"`)}semanticErrorBadBinaryOperator(e,t,n,r){n===r?this.error(e,`There is no operator "${t}" defined for type "${n}"`):this.error(e,`No binary operator "${t}" for type "${n}" and type "${r}"`)}semanticErrorBadIndex(e,t,n){this.error(e,`No index operator for type "${t}" and type "${n}"`)}semanticErrorOutOfBoundsIndex(e,t,n){this.error(e,`Index "${t}" is out of bounds for type "${n}"`)}semanticErrorBadStorage(e){this.error(e,"Cannot store to this location")}semanticErrorUninitializedConstant(e){this.error(e,"Constants must be initialized")}semanticErrorMissingReturn(e,t,n){this.error(e,`All control paths for "${t}" must return a value of type "${n}"`)}semanticErrorBadMatrixConstructor(e){this.error(e,"If a matrix argument is given to a matrix constructor, it is an error to have any other arguments")}static plural(e){return 1!==e?"s":""}}class zt{constructor(e,t){this.line=e,this.column=t}}class Yt{constructor(e,t){this.name=e,this.contents=t,this.tokens=null,this._lineOffsets=null}entireRange(){return new Ie(this,0,this.contents.length)}indexToLineColumn(e){this._computeLineOffsets();let t=this._lineOffsets.length,n=0;while(t>0){let r=t/2|0,o=n+r;a(this._lineOffsets,o)<=e?(n=o+1,t=t-r-1):t=r}let r=n>0?e-a(this._lineOffsets,n-1):e;return new zt(n-1,r)}lineColumnToIndex(e,t){if(this._computeLineOffsets(),e>=0&&e<this._lineOffsets.length){let n=a(this._lineOffsets,e);if(t>=0&&n+t<(e+1<this._lineOffsets.length?a(this._lineOffsets,e+1):this.contents.length))return n+t}return-1}_computeLineOffsets(){if(null===this._lineOffsets){this._lineOffsets=[0];for(let e=0,t=this.contents.length;e<t;e+=1)10===E(this.contents,e)&&this._lineOffsets.push(e+1)}}}function Qt(e){if("string"===typeof e)return[new Yt("<stdin>",e)];if(Array.isArray(e)){let t=[];for(let n=0,r=e.length;n<r;n+=1){let r=e[n];t.push(new Yt(P(r.name),P(r.contents)))}return t}return[new Yt(P(e.name),P(e.contents))]}function Kt(e){return(t,n)=>{let r=e(t,n);if("string"===typeof r)return new Yt(t,r);if(!r)return null;let o=r.name,i=r.contents;if("string"===typeof o&&"string"===typeof i)return new Yt(o,i);throw new Error("Invalid file access result")}}function Jt(){let e=(()=>this)(),t="undefined"!==typeof exports?exports:e.GLSLX={};t.compileIDE=en}let Zt=e=>{if(null===e)return null;let t=e.source,n=t.indexToLineColumn(e.start),r=t.indexToLineColumn(e.end);return{source:t.name,start:{line:n.line,column:n.column},end:{line:r.line,column:r.column}}},en=(e,t)=>{t=t||{};let n=Qt(e),r=null,o=null,i=null,a=new _t;t.fileAccess&&(a.fileAccess=Kt(t.fileAccess));let s=e=>{let t,r=e.source+"",a=0|e.line,s=0|e.column,l=!!e.ignoreDiagnostics,u=null,c=null,d=null;for(const f of n)if(f.name===r){let e=f.lineColumnToIndex(a,s);if(-1!==e){if(!l&&null!==i)for(const t of i.diagnostics)if(null!==t.range&&t.range.source===f&&t.range.touches(e)){c=new Nt(t.text,""),u=t.range;break}if(null===c&&null!==o){let n=new kt(f,e);n.run(o.global),c=n.generateTooltip(),null!==c&&(u=n.range,d=null!==(t=n.symbol)?t.name:null)}}break}return{tooltip:null!==c?c.code:null,range:Zt(u),symbol:d,documentation:null!==c?c.documentation:null}},l=e=>{let t=e.source+"",r=0|e.line,i=0|e.column,a=null,s=null,l=null;for(const n of o.includes)if(n.originalRange.source.name===t){let e=n.originalRange.source.lineColumnToIndex(r,i);if(-1!==e&&n.originalRange.touches(e))return{definition:Zt(n.includedRange),range:Zt(n.originalRange),symbol:n.includedRange.source.name}}for(const u of n)if(u.name===t){let e=u.lineColumnToIndex(r,i);if(-1!==e&&null!==o){let t=new kt(u,e);t.run(o.global),null!==t.symbol&&null!==t.symbol.range&&t.symbol.range.source.name!==I&&(s=t.symbol.range,a=t.range,l=t.symbol.name)}break}return{definition:Zt(s),range:Zt(a),symbol:l}},u=e=>{let t=e.source+"",r=null;for(const i of n)if(i.name===t){if(null!==o){let e=new Dt(i);e.run(o.global),r=e.symbols.map(e=>({name:e.name,kind:e.isVariable()?"variable":e.isFunction()?"function":e.isStruct()?"struct":null,range:Zt(e.range)}))}break}return{symbols:r}},c=e=>{let t=e.source+"",r=0|e.line,i=0|e.column,a=null,s=null;for(const l of n)if(l.name===t){let e=l.lineColumnToIndex(r,i);if(-1!==e&&null!==o){let t=new Ft(l,e);t.run(o.global),null!==t.symbol&&null!==t.symbol.range&&t.symbol.range.source.name!==I&&(a=t.ranges.map(Zt),s=t.symbol.name)}break}return{ranges:a,symbol:s}},d=e=>{let t=e.source+"",r=0|e.line,i=0|e.column,a=[];for(const s of n)if(s.name===t){let e=s.lineColumnToIndex(r,i);if(-1!==e&&null!==o){let t=new Vt(s,e);t.run(o.global),a=t.completions.map(e=>({kind:e.kind,name:e.name,detail:e.detail,documentation:e.documentation}))}}return{completions:a}},f=e=>{let t=e.source+"",r=0|e.line,i=0|e.column,a=[],s=-1,l=-1;for(const u of n)if(u.name===t){let e=u.lineColumnToIndex(r,i);if(-1!==e&&null!==o){let t=new Ut(u,e);t.run(o.global),s=t.activeArgument,l=t.activeSignature,a=t.signatures.map(e=>({text:e.text,arguments:e._arguments,documentation:e.documentation}))}}return{signatures:a,activeArgument:s,activeSignature:l}},h=()=>{i=new $t,o=Ot(i,n,a),r.unusedSymbols=i.unusedSymbols.map(e=>({name:e.name,range:Zt(e.range)})),r.diagnostics=i.diagnostics.map(e=>({kind:Wt[e.kind].toLowerCase(),range:Zt(e.range),text:e.text})),r.log=i};return r={log:i,result:o,updateState:h,unusedSymbols:null,diagnostics:null,sources:n,tooltipQuery:s,definitionQuery:l,symbolsQuery:u,renameQuery:c,completionQuery:d,signatureQuery:f},h(),r}}}]);
//# sourceMappingURL=chunk-4949eea6.97e1cc03.js.map